{"ast":null,"code":"'use strict';\n\nexports.name = 'removeAttrs';\nexports.description = 'removes specified attributes';\nconst DEFAULT_SEPARATOR = ':';\nconst ENOATTRS = `Warning: The plugin \"removeAttrs\" requires the \"attrs\" parameter.\nIt should have a pattern to remove, otherwise the plugin is a noop.\nConfig example:\n\nplugins: [\n  {\n    name: \"removeAttrs\",\n    params: {\n      attrs: \"(fill|stroke)\"\n    }\n  }\n]\n`;\n\n/**\n * Remove attributes\n *\n * @example elemSeparator\n *   format: string\n *\n * @example preserveCurrentColor\n *   format: boolean\n *\n * @example attrs:\n *\n *   format: [ element* : attribute* : value* ]\n *\n *   element   : regexp (wrapped into ^...$), single * or omitted > all elements (must be present when value is used)\n *   attribute : regexp (wrapped into ^...$)\n *   value     : regexp (wrapped into ^...$), single * or omitted > all values\n *\n *   examples:\n *\n *     > basic: remove fill attribute\n *     ---\n *     removeAttrs:\n *       attrs: 'fill'\n *\n *     > remove fill attribute on path element\n *     ---\n *       attrs: 'path:fill'\n *\n *     > remove fill attribute on path element where value is none\n *     ---\n *       attrs: 'path:fill:none'\n *\n *\n *     > remove all fill and stroke attribute\n *     ---\n *       attrs:\n *         - 'fill'\n *         - 'stroke'\n *\n *     [is same as]\n *\n *       attrs: '(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '*:(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '.*:(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '.*:(fill|stroke):.*'\n *\n *\n *     > remove all stroke related attributes\n *     ----\n *     attrs: 'stroke.*'\n *\n *\n * @author Benny Schudel\n *\n * @type {import('./plugins-types').Plugin<'removeAttrs'>}\n */\nexports.fn = (root, params) => {\n  if (typeof params.attrs == 'undefined') {\n    console.warn(ENOATTRS);\n    return null;\n  }\n  const elemSeparator = typeof params.elemSeparator == 'string' ? params.elemSeparator : DEFAULT_SEPARATOR;\n  const preserveCurrentColor = typeof params.preserveCurrentColor == 'boolean' ? params.preserveCurrentColor : false;\n  const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];\n  return {\n    element: {\n      enter: node => {\n        for (let pattern of attrs) {\n          // if no element separators (:), assume it's attribute name, and apply to all elements *regardless of value*\n          if (pattern.includes(elemSeparator) === false) {\n            pattern = ['.*', elemSeparator, pattern, elemSeparator, '.*'].join('');\n            // if only 1 separator, assume it's element and attribute name, and apply regardless of attribute value\n          } else if (pattern.split(elemSeparator).length < 3) {\n            pattern = [pattern, elemSeparator, '.*'].join('');\n          }\n\n          // create regexps for element, attribute name, and attribute value\n          const list = pattern.split(elemSeparator).map(value => {\n            // adjust single * to match anything\n            if (value === '*') {\n              value = '.*';\n            }\n            return new RegExp(['^', value, '$'].join(''), 'i');\n          });\n\n          // matches element\n          if (list[0].test(node.name)) {\n            // loop attributes\n            for (const [name, value] of Object.entries(node.attributes)) {\n              const isFillCurrentColor = preserveCurrentColor && name == 'fill' && value == 'currentColor';\n              const isStrokeCurrentColor = preserveCurrentColor && name == 'stroke' && value == 'currentColor';\n              if (!isFillCurrentColor && !isStrokeCurrentColor &&\n              // matches attribute name\n              list[1].test(name) &&\n              // matches attribute value\n              list[2].test(value)) {\n                delete node.attributes[name];\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["exports","name","description","DEFAULT_SEPARATOR","ENOATTRS","fn","root","params","attrs","console","warn","elemSeparator","preserveCurrentColor","Array","isArray","element","enter","node","pattern","includes","join","split","length","list","map","value","RegExp","test","Object","entries","attributes","isFillCurrentColor","isStrokeCurrentColor"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/removeAttrs.js"],"sourcesContent":["'use strict';\n\nexports.name = 'removeAttrs';\nexports.description = 'removes specified attributes';\n\nconst DEFAULT_SEPARATOR = ':';\nconst ENOATTRS = `Warning: The plugin \"removeAttrs\" requires the \"attrs\" parameter.\nIt should have a pattern to remove, otherwise the plugin is a noop.\nConfig example:\n\nplugins: [\n  {\n    name: \"removeAttrs\",\n    params: {\n      attrs: \"(fill|stroke)\"\n    }\n  }\n]\n`;\n\n/**\n * Remove attributes\n *\n * @example elemSeparator\n *   format: string\n *\n * @example preserveCurrentColor\n *   format: boolean\n *\n * @example attrs:\n *\n *   format: [ element* : attribute* : value* ]\n *\n *   element   : regexp (wrapped into ^...$), single * or omitted > all elements (must be present when value is used)\n *   attribute : regexp (wrapped into ^...$)\n *   value     : regexp (wrapped into ^...$), single * or omitted > all values\n *\n *   examples:\n *\n *     > basic: remove fill attribute\n *     ---\n *     removeAttrs:\n *       attrs: 'fill'\n *\n *     > remove fill attribute on path element\n *     ---\n *       attrs: 'path:fill'\n *\n *     > remove fill attribute on path element where value is none\n *     ---\n *       attrs: 'path:fill:none'\n *\n *\n *     > remove all fill and stroke attribute\n *     ---\n *       attrs:\n *         - 'fill'\n *         - 'stroke'\n *\n *     [is same as]\n *\n *       attrs: '(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '*:(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '.*:(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '.*:(fill|stroke):.*'\n *\n *\n *     > remove all stroke related attributes\n *     ----\n *     attrs: 'stroke.*'\n *\n *\n * @author Benny Schudel\n *\n * @type {import('./plugins-types').Plugin<'removeAttrs'>}\n */\nexports.fn = (root, params) => {\n  if (typeof params.attrs == 'undefined') {\n    console.warn(ENOATTRS);\n    return null;\n  }\n\n  const elemSeparator =\n    typeof params.elemSeparator == 'string'\n      ? params.elemSeparator\n      : DEFAULT_SEPARATOR;\n  const preserveCurrentColor =\n    typeof params.preserveCurrentColor == 'boolean'\n      ? params.preserveCurrentColor\n      : false;\n  const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];\n\n  return {\n    element: {\n      enter: (node) => {\n        for (let pattern of attrs) {\n          // if no element separators (:), assume it's attribute name, and apply to all elements *regardless of value*\n          if (pattern.includes(elemSeparator) === false) {\n            pattern = ['.*', elemSeparator, pattern, elemSeparator, '.*'].join(\n              ''\n            );\n            // if only 1 separator, assume it's element and attribute name, and apply regardless of attribute value\n          } else if (pattern.split(elemSeparator).length < 3) {\n            pattern = [pattern, elemSeparator, '.*'].join('');\n          }\n\n          // create regexps for element, attribute name, and attribute value\n          const list = pattern.split(elemSeparator).map((value) => {\n            // adjust single * to match anything\n            if (value === '*') {\n              value = '.*';\n            }\n            return new RegExp(['^', value, '$'].join(''), 'i');\n          });\n\n          // matches element\n          if (list[0].test(node.name)) {\n            // loop attributes\n            for (const [name, value] of Object.entries(node.attributes)) {\n              const isFillCurrentColor =\n                preserveCurrentColor &&\n                name == 'fill' &&\n                value == 'currentColor';\n              const isStrokeCurrentColor =\n                preserveCurrentColor &&\n                name == 'stroke' &&\n                value == 'currentColor';\n              if (\n                !isFillCurrentColor &&\n                !isStrokeCurrentColor &&\n                // matches attribute name\n                list[1].test(name) &&\n                // matches attribute value\n                list[2].test(value)\n              ) {\n                delete node.attributes[name];\n              }\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}