{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n * @typedef {import('../lib/types').XastNode} XastNode\n */\nexports.name = 'reusePaths';\nexports.description = 'Finds <path> elements with the same d, fill, and ' + 'stroke, and converts them to <use> elements ' + 'referencing a single <path> def.';\n\n/**\n * Finds <path> elements with the same d, fill, and stroke, and converts them to\n * <use> elements referencing a single <path> def.\n *\n * @author Jacob Howcroft\n *\n * @type {import('./plugins-types').Plugin<'reusePaths'>}\n */\nexports.fn = () => {\n  /**\n   * @type {Map<string, Array<XastElement>>}\n   */\n  const paths = new Map();\n  return {\n    element: {\n      enter: node => {\n        if (node.name === 'path' && node.attributes.d != null) {\n          const d = node.attributes.d;\n          const fill = node.attributes.fill || '';\n          const stroke = node.attributes.stroke || '';\n          const key = d + ';s:' + stroke + ';f:' + fill;\n          let list = paths.get(key);\n          if (list == null) {\n            list = [];\n            paths.set(key, list);\n          }\n          list.push(node);\n        }\n      },\n      exit: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          /**\n           * @type {XastElement}\n           */\n          const defsTag = {\n            type: 'element',\n            name: 'defs',\n            attributes: {},\n            children: []\n          };\n          // TODO remove legacy parentNode in v4\n          Object.defineProperty(defsTag, 'parentNode', {\n            writable: true,\n            value: node\n          });\n          let index = 0;\n          for (const list of paths.values()) {\n            if (list.length > 1) {\n              // add reusable path to defs\n              /**\n               * @type {XastElement}\n               */\n              const reusablePath = {\n                type: 'element',\n                name: 'path',\n                attributes: {\n                  ...list[0].attributes\n                },\n                children: []\n              };\n              delete reusablePath.attributes.transform;\n              let id;\n              if (reusablePath.attributes.id == null) {\n                id = 'reuse-' + index;\n                index += 1;\n                reusablePath.attributes.id = id;\n              } else {\n                id = reusablePath.attributes.id;\n                delete list[0].attributes.id;\n              }\n              // TODO remove legacy parentNode in v4\n              Object.defineProperty(reusablePath, 'parentNode', {\n                writable: true,\n                value: defsTag\n              });\n              defsTag.children.push(reusablePath);\n              // convert paths to <use>\n              for (const pathNode of list) {\n                pathNode.name = 'use';\n                pathNode.attributes['xlink:href'] = '#' + id;\n                delete pathNode.attributes.d;\n                delete pathNode.attributes.stroke;\n                delete pathNode.attributes.fill;\n              }\n            }\n          }\n          if (defsTag.children.length !== 0) {\n            if (node.attributes['xmlns:xlink'] == null) {\n              node.attributes['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';\n            }\n            node.children.unshift(defsTag);\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["exports","name","description","fn","paths","Map","element","enter","node","attributes","d","fill","stroke","key","list","get","set","push","exit","parentNode","type","defsTag","children","Object","defineProperty","writable","value","index","values","length","reusablePath","transform","id","pathNode","unshift"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/reusePaths.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n * @typedef {import('../lib/types').XastNode} XastNode\n */\n\nexports.name = 'reusePaths';\nexports.description =\n  'Finds <path> elements with the same d, fill, and ' +\n  'stroke, and converts them to <use> elements ' +\n  'referencing a single <path> def.';\n\n/**\n * Finds <path> elements with the same d, fill, and stroke, and converts them to\n * <use> elements referencing a single <path> def.\n *\n * @author Jacob Howcroft\n *\n * @type {import('./plugins-types').Plugin<'reusePaths'>}\n */\nexports.fn = () => {\n  /**\n   * @type {Map<string, Array<XastElement>>}\n   */\n  const paths = new Map();\n\n  return {\n    element: {\n      enter: (node) => {\n        if (node.name === 'path' && node.attributes.d != null) {\n          const d = node.attributes.d;\n          const fill = node.attributes.fill || '';\n          const stroke = node.attributes.stroke || '';\n          const key = d + ';s:' + stroke + ';f:' + fill;\n          let list = paths.get(key);\n          if (list == null) {\n            list = [];\n            paths.set(key, list);\n          }\n          list.push(node);\n        }\n      },\n\n      exit: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          /**\n           * @type {XastElement}\n           */\n          const defsTag = {\n            type: 'element',\n            name: 'defs',\n            attributes: {},\n            children: [],\n          };\n          // TODO remove legacy parentNode in v4\n          Object.defineProperty(defsTag, 'parentNode', {\n            writable: true,\n            value: node,\n          });\n          let index = 0;\n          for (const list of paths.values()) {\n            if (list.length > 1) {\n              // add reusable path to defs\n              /**\n               * @type {XastElement}\n               */\n              const reusablePath = {\n                type: 'element',\n                name: 'path',\n                attributes: { ...list[0].attributes },\n                children: [],\n              };\n              delete reusablePath.attributes.transform;\n              let id;\n              if (reusablePath.attributes.id == null) {\n                id = 'reuse-' + index;\n                index += 1;\n                reusablePath.attributes.id = id;\n              } else {\n                id = reusablePath.attributes.id;\n                delete list[0].attributes.id;\n              }\n              // TODO remove legacy parentNode in v4\n              Object.defineProperty(reusablePath, 'parentNode', {\n                writable: true,\n                value: defsTag,\n              });\n              defsTag.children.push(reusablePath);\n              // convert paths to <use>\n              for (const pathNode of list) {\n                pathNode.name = 'use';\n                pathNode.attributes['xlink:href'] = '#' + id;\n                delete pathNode.attributes.d;\n                delete pathNode.attributes.stroke;\n                delete pathNode.attributes.fill;\n              }\n            }\n          }\n          if (defsTag.children.length !== 0) {\n            if (node.attributes['xmlns:xlink'] == null) {\n              node.attributes['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';\n            }\n            node.children.unshift(defsTag);\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}