{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastInstruction} XastInstruction\n * @typedef {import('./types').XastDoctype} XastDoctype\n * @typedef {import('./types').XastComment} XastComment\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastCdata} XastCdata\n * @typedef {import('./types').XastText} XastText\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\n// @ts-ignore sax will be replaced with something else later\nconst SAX = require('@trysound/sax');\nconst {\n  textElems\n} = require('../plugins/_collections.js');\nclass SvgoParserError extends Error {\n  /**\n   * @param message {string}\n   * @param line {number}\n   * @param column {number}\n   * @param source {string}\n   * @param file {void | string}\n   */\n  constructor(message, line, column, source, file) {\n    super(message);\n    this.name = 'SvgoParserError';\n    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;\n    this.reason = message;\n    this.line = line;\n    this.column = column;\n    this.source = source;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SvgoParserError);\n    }\n  }\n  toString() {\n    const lines = this.source.split(/\\r?\\n/);\n    const startLine = Math.max(this.line - 3, 0);\n    const endLine = Math.min(this.line + 2, lines.length);\n    const lineNumberWidth = String(endLine).length;\n    const startColumn = Math.max(this.column - 54, 0);\n    const endColumn = Math.max(this.column + 20, 80);\n    const code = lines.slice(startLine, endLine).map((line, index) => {\n      const lineSlice = line.slice(startColumn, endColumn);\n      let ellipsisPrefix = '';\n      let ellipsisSuffix = '';\n      if (startColumn !== 0) {\n        ellipsisPrefix = startColumn > line.length - 1 ? ' ' : '…';\n      }\n      if (endColumn < line.length - 1) {\n        ellipsisSuffix = '…';\n      }\n      const number = startLine + 1 + index;\n      const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;\n      if (number === this.line) {\n        const gutterSpacing = gutter.replace(/[^|]/g, ' ');\n        const lineSpacing = (ellipsisPrefix + line.slice(startColumn, this.column - 1)).replace(/[^\\t]/g, ' ');\n        const spacing = gutterSpacing + lineSpacing;\n        return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\\n ${spacing}^`;\n      }\n      return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;\n    }).join('\\n');\n    return `${this.name}: ${this.message}\\n\\n${code}\\n`;\n  }\n}\nconst entityDeclaration = /<!ENTITY\\s+(\\S+)\\s+(?:'([^']+)'|\"([^\"]+)\")\\s*>/g;\nconst config = {\n  strict: true,\n  trim: false,\n  normalize: false,\n  lowercase: true,\n  xmlns: true,\n  position: true\n};\n\n/**\n * Convert SVG (XML) string to SVG-as-JS object.\n *\n * @type {(data: string, from?: string) => XastRoot}\n */\nconst parseSvg = (data, from) => {\n  const sax = SAX.parser(config.strict, config);\n  /**\n   * @type {XastRoot}\n   */\n  const root = {\n    type: 'root',\n    children: []\n  };\n  /**\n   * @type {XastParent}\n   */\n  let current = root;\n  /**\n   * @type {Array<XastParent>}\n   */\n  const stack = [root];\n\n  /**\n   * @type {(node: XastChild) => void}\n   */\n  const pushToContent = node => {\n    // TODO remove legacy parentNode in v4\n    Object.defineProperty(node, 'parentNode', {\n      writable: true,\n      value: current\n    });\n    current.children.push(node);\n  };\n\n  /**\n   * @type {(doctype: string) => void}\n   */\n  sax.ondoctype = doctype => {\n    /**\n     * @type {XastDoctype}\n     */\n    const node = {\n      type: 'doctype',\n      // TODO parse doctype for name, public and system to match xast\n      name: 'svg',\n      data: {\n        doctype\n      }\n    };\n    pushToContent(node);\n    const subsetStart = doctype.indexOf('[');\n    if (subsetStart >= 0) {\n      entityDeclaration.lastIndex = subsetStart;\n      let entityMatch = entityDeclaration.exec(data);\n      while (entityMatch != null) {\n        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];\n        entityMatch = entityDeclaration.exec(data);\n      }\n    }\n  };\n\n  /**\n   * @type {(data: { name: string, body: string }) => void}\n   */\n  sax.onprocessinginstruction = data => {\n    /**\n     * @type {XastInstruction}\n     */\n    const node = {\n      type: 'instruction',\n      name: data.name,\n      value: data.body\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(comment: string) => void}\n   */\n  sax.oncomment = comment => {\n    /**\n     * @type {XastComment}\n     */\n    const node = {\n      type: 'comment',\n      value: comment.trim()\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(cdata: string) => void}\n   */\n  sax.oncdata = cdata => {\n    /**\n     * @type {XastCdata}\n     */\n    const node = {\n      type: 'cdata',\n      value: cdata\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}\n   */\n  sax.onopentag = data => {\n    /**\n     * @type {XastElement}\n     */\n    let element = {\n      type: 'element',\n      name: data.name,\n      attributes: {},\n      children: []\n    };\n    for (const [name, attr] of Object.entries(data.attributes)) {\n      element.attributes[name] = attr.value;\n    }\n    pushToContent(element);\n    current = element;\n    stack.push(element);\n  };\n\n  /**\n   * @type {(text: string) => void}\n   */\n  sax.ontext = text => {\n    if (current.type === 'element') {\n      // prevent trimming of meaningful whitespace inside textual tags\n      if (textElems.includes(current.name)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text\n        };\n        pushToContent(node);\n      } else if (/\\S/.test(text)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text.trim()\n        };\n        pushToContent(node);\n      }\n    }\n  };\n  sax.onclosetag = () => {\n    stack.pop();\n    current = stack[stack.length - 1];\n  };\n\n  /**\n   * @type {(e: any) => void}\n   */\n  sax.onerror = e => {\n    const error = new SvgoParserError(e.reason, e.line + 1, e.column, data, from);\n    if (e.message.indexOf('Unexpected end') === -1) {\n      throw error;\n    }\n  };\n  sax.write(data).close();\n  return root;\n};\nexports.parseSvg = parseSvg;","map":{"version":3,"names":["SAX","require","textElems","SvgoParserError","Error","constructor","message","line","column","source","file","name","reason","captureStackTrace","toString","lines","split","startLine","Math","max","endLine","min","length","lineNumberWidth","String","startColumn","endColumn","code","slice","map","index","lineSlice","ellipsisPrefix","ellipsisSuffix","number","gutter","padStart","gutterSpacing","replace","lineSpacing","spacing","join","entityDeclaration","config","strict","trim","normalize","lowercase","xmlns","position","parseSvg","data","from","sax","parser","root","type","children","current","stack","pushToContent","node","Object","defineProperty","writable","value","push","ondoctype","doctype","subsetStart","indexOf","lastIndex","entityMatch","exec","ENTITIES","onprocessinginstruction","body","oncomment","comment","oncdata","cdata","onopentag","element","attributes","attr","entries","ontext","text","includes","test","onclosetag","pop","onerror","e","error","write","close","exports"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/lib/parser.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastInstruction} XastInstruction\n * @typedef {import('./types').XastDoctype} XastDoctype\n * @typedef {import('./types').XastComment} XastComment\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastCdata} XastCdata\n * @typedef {import('./types').XastText} XastText\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\n// @ts-ignore sax will be replaced with something else later\nconst SAX = require('@trysound/sax');\nconst { textElems } = require('../plugins/_collections.js');\n\nclass SvgoParserError extends Error {\n  /**\n   * @param message {string}\n   * @param line {number}\n   * @param column {number}\n   * @param source {string}\n   * @param file {void | string}\n   */\n  constructor(message, line, column, source, file) {\n    super(message);\n    this.name = 'SvgoParserError';\n    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;\n    this.reason = message;\n    this.line = line;\n    this.column = column;\n    this.source = source;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SvgoParserError);\n    }\n  }\n  toString() {\n    const lines = this.source.split(/\\r?\\n/);\n    const startLine = Math.max(this.line - 3, 0);\n    const endLine = Math.min(this.line + 2, lines.length);\n    const lineNumberWidth = String(endLine).length;\n    const startColumn = Math.max(this.column - 54, 0);\n    const endColumn = Math.max(this.column + 20, 80);\n    const code = lines\n      .slice(startLine, endLine)\n      .map((line, index) => {\n        const lineSlice = line.slice(startColumn, endColumn);\n        let ellipsisPrefix = '';\n        let ellipsisSuffix = '';\n        if (startColumn !== 0) {\n          ellipsisPrefix = startColumn > line.length - 1 ? ' ' : '…';\n        }\n        if (endColumn < line.length - 1) {\n          ellipsisSuffix = '…';\n        }\n        const number = startLine + 1 + index;\n        const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;\n        if (number === this.line) {\n          const gutterSpacing = gutter.replace(/[^|]/g, ' ');\n          const lineSpacing = (\n            ellipsisPrefix + line.slice(startColumn, this.column - 1)\n          ).replace(/[^\\t]/g, ' ');\n          const spacing = gutterSpacing + lineSpacing;\n          return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\\n ${spacing}^`;\n        }\n        return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;\n      })\n      .join('\\n');\n    return `${this.name}: ${this.message}\\n\\n${code}\\n`;\n  }\n}\n\nconst entityDeclaration = /<!ENTITY\\s+(\\S+)\\s+(?:'([^']+)'|\"([^\"]+)\")\\s*>/g;\n\nconst config = {\n  strict: true,\n  trim: false,\n  normalize: false,\n  lowercase: true,\n  xmlns: true,\n  position: true,\n};\n\n/**\n * Convert SVG (XML) string to SVG-as-JS object.\n *\n * @type {(data: string, from?: string) => XastRoot}\n */\nconst parseSvg = (data, from) => {\n  const sax = SAX.parser(config.strict, config);\n  /**\n   * @type {XastRoot}\n   */\n  const root = { type: 'root', children: [] };\n  /**\n   * @type {XastParent}\n   */\n  let current = root;\n  /**\n   * @type {Array<XastParent>}\n   */\n  const stack = [root];\n\n  /**\n   * @type {(node: XastChild) => void}\n   */\n  const pushToContent = (node) => {\n    // TODO remove legacy parentNode in v4\n    Object.defineProperty(node, 'parentNode', {\n      writable: true,\n      value: current,\n    });\n    current.children.push(node);\n  };\n\n  /**\n   * @type {(doctype: string) => void}\n   */\n  sax.ondoctype = (doctype) => {\n    /**\n     * @type {XastDoctype}\n     */\n    const node = {\n      type: 'doctype',\n      // TODO parse doctype for name, public and system to match xast\n      name: 'svg',\n      data: {\n        doctype,\n      },\n    };\n    pushToContent(node);\n    const subsetStart = doctype.indexOf('[');\n    if (subsetStart >= 0) {\n      entityDeclaration.lastIndex = subsetStart;\n      let entityMatch = entityDeclaration.exec(data);\n      while (entityMatch != null) {\n        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];\n        entityMatch = entityDeclaration.exec(data);\n      }\n    }\n  };\n\n  /**\n   * @type {(data: { name: string, body: string }) => void}\n   */\n  sax.onprocessinginstruction = (data) => {\n    /**\n     * @type {XastInstruction}\n     */\n    const node = {\n      type: 'instruction',\n      name: data.name,\n      value: data.body,\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(comment: string) => void}\n   */\n  sax.oncomment = (comment) => {\n    /**\n     * @type {XastComment}\n     */\n    const node = {\n      type: 'comment',\n      value: comment.trim(),\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(cdata: string) => void}\n   */\n  sax.oncdata = (cdata) => {\n    /**\n     * @type {XastCdata}\n     */\n    const node = {\n      type: 'cdata',\n      value: cdata,\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}\n   */\n  sax.onopentag = (data) => {\n    /**\n     * @type {XastElement}\n     */\n    let element = {\n      type: 'element',\n      name: data.name,\n      attributes: {},\n      children: [],\n    };\n    for (const [name, attr] of Object.entries(data.attributes)) {\n      element.attributes[name] = attr.value;\n    }\n    pushToContent(element);\n    current = element;\n    stack.push(element);\n  };\n\n  /**\n   * @type {(text: string) => void}\n   */\n  sax.ontext = (text) => {\n    if (current.type === 'element') {\n      // prevent trimming of meaningful whitespace inside textual tags\n      if (textElems.includes(current.name)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text,\n        };\n        pushToContent(node);\n      } else if (/\\S/.test(text)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text.trim(),\n        };\n        pushToContent(node);\n      }\n    }\n  };\n\n  sax.onclosetag = () => {\n    stack.pop();\n    current = stack[stack.length - 1];\n  };\n\n  /**\n   * @type {(e: any) => void}\n   */\n  sax.onerror = (e) => {\n    const error = new SvgoParserError(\n      e.reason,\n      e.line + 1,\n      e.column,\n      data,\n      from\n    );\n    if (e.message.indexOf('Unexpected end') === -1) {\n      throw error;\n    }\n  };\n\n  sax.write(data).close();\n  return root;\n};\nexports.parseSvg = parseSvg;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}