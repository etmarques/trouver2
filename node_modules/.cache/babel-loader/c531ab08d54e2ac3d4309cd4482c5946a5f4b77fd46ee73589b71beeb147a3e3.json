{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nvar _core = require(\"@babel/core\");\nconst buildForAwait = (0, _core.template)(`\n  async function wrapper() {\n    var ITERATOR_ABRUPT_COMPLETION = false;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;\n        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;\n        ITERATOR_ABRUPT_COMPLETION = false\n      ) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n`);\nfunction _default(path, _ref) {\n  let {\n    getAsyncIterator\n  } = _ref;\n  const {\n    node,\n    scope,\n    parent\n  } = path;\n  const stepKey = scope.generateUidIdentifier(\"step\");\n  const stepValue = _core.types.memberExpression(stepKey, _core.types.identifier(\"value\"));\n  const left = node.left;\n  let declar;\n  if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {\n    declar = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, stepValue));\n  } else if (_core.types.isVariableDeclaration(left)) {\n    declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);\n  }\n  let template = buildForAwait({\n    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n    ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier(\"iteratorAbruptCompletion\"),\n    ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n    ITERATOR_KEY: scope.generateUidIdentifier(\"iterator\"),\n    GET_ITERATOR: getAsyncIterator,\n    OBJECT: node.right,\n    STEP_KEY: _core.types.cloneNode(stepKey)\n  });\n  template = template.body.body;\n  const isLabeledParent = _core.types.isLabeledStatement(parent);\n  const tryBody = template[3].block.body;\n  const loop = tryBody[0];\n  if (isLabeledParent) {\n    tryBody[0] = _core.types.labeledStatement(parent.label, loop);\n  }\n  return {\n    replaceParent: isLabeledParent,\n    node: template,\n    declar,\n    loop\n  };\n}","map":{"version":3,"names":["_core","require","buildForAwait","template","_default","path","_ref","getAsyncIterator","node","scope","parent","stepKey","generateUidIdentifier","stepValue","types","memberExpression","identifier","left","declar","isIdentifier","isPattern","isMemberExpression","expressionStatement","assignmentExpression","isVariableDeclaration","variableDeclaration","kind","variableDeclarator","declarations","id","ITERATOR_HAD_ERROR_KEY","ITERATOR_ABRUPT_COMPLETION","ITERATOR_ERROR_KEY","ITERATOR_KEY","GET_ITERATOR","OBJECT","right","STEP_KEY","cloneNode","body","isLabeledParent","isLabeledStatement","tryBody","block","loop","labeledStatement","label","replaceParent"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@babel\\plugin-transform-async-generator-functions\\src\\for-await.ts"],"sourcesContent":["import { types as t, template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nconst buildForAwait = template(`\n  async function wrapper() {\n    var ITERATOR_ABRUPT_COMPLETION = false;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;\n        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;\n        ITERATOR_ABRUPT_COMPLETION = false\n      ) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n`);\n\nexport default function (\n  path: NodePath<t.ForOfStatement>,\n  { getAsyncIterator }: { getAsyncIterator: t.Identifier },\n) {\n  const { node, scope, parent } = path;\n\n  const stepKey = scope.generateUidIdentifier(\"step\");\n  const stepValue = t.memberExpression(stepKey, t.identifier(\"value\"));\n  const left = node.left;\n  let declar;\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    // for await (i of test), for await ({ i } of test)\n    declar = t.expressionStatement(\n      t.assignmentExpression(\"=\", left, stepValue),\n    );\n  } else if (t.isVariableDeclaration(left)) {\n    // for await (let i of test)\n    declar = t.variableDeclaration(left.kind, [\n      t.variableDeclarator(left.declarations[0].id, stepValue),\n    ]);\n  }\n  let template = buildForAwait({\n    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n    ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier(\n      \"iteratorAbruptCompletion\",\n    ),\n    ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n    ITERATOR_KEY: scope.generateUidIdentifier(\"iterator\"),\n    GET_ITERATOR: getAsyncIterator,\n    OBJECT: node.right,\n    STEP_KEY: t.cloneNode(stepKey),\n  });\n\n  // remove async function wrapper\n  // @ts-expect-error todo(flow->ts) improve type annotation for buildForAwait\n  template = template.body.body as t.Statement[];\n\n  const isLabeledParent = t.isLabeledStatement(parent);\n  const tryBody = (template[3] as t.TryStatement).block.body;\n  const loop = tryBody[0] as t.ForStatement;\n\n  if (isLabeledParent) {\n    tryBody[0] = t.labeledStatement(parent.label, loop);\n  }\n\n  return {\n    replaceParent: isLabeledParent,\n    node: template,\n    declar,\n    loop,\n  };\n}\n"],"mappings":";;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAGA,MAAMC,aAAa,GAAG,IAAAF,KAAA,CAAAG,QAAQ,EAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC;AAEa,SAAAC,SACbC,IAAgC,EAAAC,IAAA,EAEhC;EAAA,IADA;IAAEC;EAAqD,CAAC,GAAAD,IAAA;EAExD,MAAM;IAAEE,IAAI;IAAEC,KAAK;IAAEC;EAAO,CAAC,GAAGL,IAAI;EAEpC,MAAMM,OAAO,GAAGF,KAAK,CAACG,qBAAqB,CAAC,MAAM,CAAC;EACnD,MAAMC,SAAS,GAAGb,KAAA,CAAAc,KAAC,CAACC,gBAAgB,CAACJ,OAAO,EAAEX,KAAA,CAAAc,KAAC,CAACE,UAAU,CAAC,OAAO,CAAC,CAAC;EACpE,MAAMC,IAAI,GAAGT,IAAI,CAACS,IAAI;EACtB,IAAIC,MAAM;EAEV,IAAIlB,KAAA,CAAAc,KAAC,CAACK,YAAY,CAACF,IAAI,CAAC,IAAIjB,KAAA,CAAAc,KAAC,CAACM,SAAS,CAACH,IAAI,CAAC,IAAIjB,KAAA,CAAAc,KAAC,CAACO,kBAAkB,CAACJ,IAAI,CAAC,EAAE;IAE3EC,MAAM,GAAGlB,KAAA,CAAAc,KAAC,CAACQ,mBAAmB,CAC5BtB,KAAA,CAAAc,KAAC,CAACS,oBAAoB,CAAC,GAAG,EAAEN,IAAI,EAAEJ,SAAS,CAC7C,CAAC;EACH,CAAC,MAAM,IAAIb,KAAA,CAAAc,KAAC,CAACU,qBAAqB,CAACP,IAAI,CAAC,EAAE;IAExCC,MAAM,GAAGlB,KAAA,CAAAc,KAAC,CAACW,mBAAmB,CAACR,IAAI,CAACS,IAAI,EAAE,CACxC1B,KAAA,CAAAc,KAAC,CAACa,kBAAkB,CAACV,IAAI,CAACW,YAAY,CAAC,CAAC,CAAC,CAACC,EAAE,EAAEhB,SAAS,CAAC,CACzD,CAAC;EACJ;EACA,IAAIV,QAAQ,GAAGD,aAAa,CAAC;IAC3B4B,sBAAsB,EAAErB,KAAK,CAACG,qBAAqB,CAAC,kBAAkB,CAAC;IACvEmB,0BAA0B,EAAEtB,KAAK,CAACG,qBAAqB,CACrD,0BACF,CAAC;IACDoB,kBAAkB,EAAEvB,KAAK,CAACG,qBAAqB,CAAC,eAAe,CAAC;IAChEqB,YAAY,EAAExB,KAAK,CAACG,qBAAqB,CAAC,UAAU,CAAC;IACrDsB,YAAY,EAAE3B,gBAAgB;IAC9B4B,MAAM,EAAE3B,IAAI,CAAC4B,KAAK;IAClBC,QAAQ,EAAErC,KAAA,CAAAc,KAAC,CAACwB,SAAS,CAAC3B,OAAO;EAC/B,CAAC,CAAC;EAIFR,QAAQ,GAAGA,QAAQ,CAACoC,IAAI,CAACA,IAAqB;EAE9C,MAAMC,eAAe,GAAGxC,KAAA,CAAAc,KAAC,CAAC2B,kBAAkB,CAAC/B,MAAM,CAAC;EACpD,MAAMgC,OAAO,GAAIvC,QAAQ,CAAC,CAAC,CAAC,CAAoBwC,KAAK,CAACJ,IAAI;EAC1D,MAAMK,IAAI,GAAGF,OAAO,CAAC,CAAC,CAAmB;EAEzC,IAAIF,eAAe,EAAE;IACnBE,OAAO,CAAC,CAAC,CAAC,GAAG1C,KAAA,CAAAc,KAAC,CAAC+B,gBAAgB,CAACnC,MAAM,CAACoC,KAAK,EAAEF,IAAI,CAAC;EACrD;EAEA,OAAO;IACLG,aAAa,EAAEP,eAAe;IAC9BhC,IAAI,EAAEL,QAAQ;IACde,MAAM;IACN0B;EACF,CAAC;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}