{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar syntaxOptionalChaining = require('@babel/plugin-syntax-optional-chaining');\nvar core = require('@babel/core');\nvar helperSkipTransparentExpressionWrappers = require('@babel/helper-skip-transparent-expression-wrappers');\nfunction willPathCastToBoolean(path) {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    node,\n    parentPath\n  } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const {\n      operator,\n      right\n    } = parentPath.node;\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const {\n      expressions\n    } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isLoop({\n    test: node\n  });\n}\nfunction findOutermostTransparentParent(path) {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\nconst {\n  ast\n} = core.template.expression;\nfunction isSimpleMemberExpression(expression) {\n  expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression);\n  return core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n}\nfunction needsMemoize(path) {\n  let optionalPath = path;\n  const {\n    scope\n  } = path;\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n    const childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.isOptionalMemberExpression() ? optionalPath.get(\"object\") : optionalPath.get(\"callee\"));\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n    optionalPath = childPath;\n  }\n}\nfunction transform(path, _ref) {\n  let {\n    pureGetters,\n    noDocumentAll\n  } = _ref;\n  const {\n    scope\n  } = path;\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    parentPath\n  } = maybeWrapped;\n  const willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);\n  let isDeleteOperation = false;\n  const parentIsCall = parentPath.isCallExpression({\n    callee: maybeWrapped.node\n  }) && path.isOptionalMemberExpression();\n  const optionals = [];\n  let optionalPath = path;\n  if (scope.path.isPattern() && needsMemoize(optionalPath)) {\n    path.replaceWith(core.template.ast`(() => ${path.node})()`);\n    return;\n  }\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n    if (optionalPath.isOptionalMemberExpression()) {\n      optionalPath.node.type = \"MemberExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      optionalPath.node.type = \"CallExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n  let replacementPath = path;\n  if (parentPath.isUnaryExpression({\n    operator: \"delete\"\n  })) {\n    replacementPath = parentPath;\n    isDeleteOperation = true;\n  }\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i];\n    const isCall = core.types.isCallExpression(node);\n    const chainWithTypes = isCall ? node.callee : node.object;\n    const chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);\n    let ref;\n    let check;\n    if (isCall && core.types.isIdentifier(chain, {\n      name: \"eval\"\n    })) {\n      check = ref = chain;\n      node.callee = core.types.sequenceExpression([core.types.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      check = ref = node.callee;\n    } else {\n      ref = scope.maybeGenerateMemoised(chain);\n      if (ref) {\n        check = core.types.assignmentExpression(\"=\", core.types.cloneNode(ref), chainWithTypes);\n        isCall ? node.callee = ref : node.object = ref;\n      } else {\n        check = ref = chainWithTypes;\n      }\n    }\n    if (isCall && core.types.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        node.callee = chainWithTypes;\n      } else {\n        const {\n          object\n        } = chain;\n        let context;\n        if (core.types.isSuper(object)) {\n          context = core.types.thisExpression();\n        } else {\n          const memoized = scope.maybeGenerateMemoised(object);\n          if (memoized) {\n            context = memoized;\n            chain.object = core.types.assignmentExpression(\"=\", memoized, object);\n          } else {\n            context = object;\n          }\n        }\n        node.arguments.unshift(core.types.cloneNode(context));\n        node.callee = core.types.memberExpression(node.callee, core.types.identifier(\"call\"));\n      }\n    }\n    let replacement = replacementPath.node;\n    if (i === 0 && parentIsCall) {\n      var _baseRef;\n      const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);\n      let baseRef;\n      if (!pureGetters || !isSimpleMemberExpression(object)) {\n        baseRef = scope.maybeGenerateMemoised(object);\n        if (baseRef) {\n          replacement.object = core.types.assignmentExpression(\"=\", baseRef, object);\n        }\n      }\n      replacement = core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier(\"bind\")), [core.types.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)]);\n    }\n    if (willReplacementCastToBoolean) {\n      const nonNullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} != null` : ast`\n            ${core.types.cloneNode(check)} !== null && ${core.types.cloneNode(ref)} !== void 0`;\n      replacementPath.replaceWith(core.types.logicalExpression(\"&&\", nonNullishCheck, replacement));\n      replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get(\"right\"));\n    } else {\n      const nullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} == null` : ast`\n            ${core.types.cloneNode(check)} === null || ${core.types.cloneNode(ref)} === void 0`;\n      const returnValue = isDeleteOperation ? ast`true` : ast`void 0`;\n      replacementPath.replaceWith(core.types.conditionalExpression(nullishCheck, returnValue, replacement));\n      replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get(\"alternate\"));\n    }\n  }\n}\nvar index = helperPluginUtils.declare((api, options) => {\n  var _api$assumption, _api$assumption2;\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n  const noDocumentAll = (_api$assumption = api.assumption(\"noDocumentAll\")) != null ? _api$assumption : loose;\n  const pureGetters = (_api$assumption2 = api.assumption(\"pureGetters\")) != null ? _api$assumption2 : loose;\n  return {\n    name: \"transform-optional-chaining\",\n    inherits: syntaxOptionalChaining.default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        transform(path, {\n          noDocumentAll,\n          pureGetters\n        });\n      }\n    }\n  };\n});\nexports[\"default\"] = index;\nexports.transform = transform;","map":{"version":3,"names":["willPathCastToBoolean","path","maybeWrapped","findOutermostTransparentParent","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","findParent","p","helperSkipTransparentExpressionWrappers","isTransparentExprWrapper","ast","core","template","expression","isSimpleMemberExpression","skipTransparentExprWrapperNodes","types","isIdentifier","isSuper","isMemberExpression","computed","object","needsMemoize","optionalPath","scope","isOptionalMemberExpression","isOptionalCallExpression","childPath","skipTransparentExprWrappers","get","optional","isStatic","transform","_ref","pureGetters","noDocumentAll","willReplacementCastToBoolean","isDeleteOperation","parentIsCall","isCallExpression","callee","optionals","isPattern","replaceWith","push","type","replacementPath","i","isCall","chainWithTypes","chain","ref","check","name","sequenceExpression","numericLiteral","maybeGenerateMemoised","assignmentExpression","cloneNode","context","thisExpression","memoized","arguments","unshift","memberExpression","identifier","replacement","_baseRef","baseRef","callExpression","nonNullishCheck","logicalExpression","nullishCheck","returnValue","conditionalExpression","index","helperPluginUtils","declare","api","options","_api$assumption","_api$assumption2","assertVersion","loose","assumption","inherits","syntaxOptionalChaining","default","visitor","OptionalCallExpression|OptionalMemberExpression"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@babel\\plugin-transform-optional-chaining\\src\\util.ts","C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@babel\\plugin-transform-optional-chaining\\src\\transform.ts","C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@babel\\plugin-transform-optional-chaining\\src\\index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport { isTransparentExprWrapper } from \"@babel/helper-skip-transparent-expression-wrappers\";\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n * It respects transparent expression wrappers defined in\n * \"@babel/helper-skip-transparent-expression-wrappers\"\n *\n * @example\n * // returns true\n * const nodePathADotB = NodePath(\"if (a.b) {}\").get(\"test\"); // a.b\n * willPathCastToBoolean(nodePathADotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a.b\"))\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n\n/**\n * Return the outermost transparent expression wrapper of a given path,\n * otherwise returns path itself.\n * @example\n * const nodePathADotB = NodePath(\"(a.b as any)\").get(\"expression\"); // a.b\n * // returns NodePath(\"(a.b as any)\")\n * findOutermostTransparentParent(nodePathADotB);\n * @param {NodePath} path\n * @returns {NodePath}\n */\nexport function findOutermostTransparentParent(path: NodePath): NodePath {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\n","import { types as t, template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport {\n  skipTransparentExprWrapperNodes,\n  skipTransparentExprWrappers,\n} from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport { willPathCastToBoolean, findOutermostTransparentParent } from \"./util\";\n\nconst { ast } = template.expression;\n\nfunction isSimpleMemberExpression(\n  expression: t.Expression | t.Super,\n): expression is t.Identifier | t.Super | t.MemberExpression {\n  expression = skipTransparentExprWrapperNodes(expression);\n  return (\n    t.isIdentifier(expression) ||\n    t.isSuper(expression) ||\n    (t.isMemberExpression(expression) &&\n      !expression.computed &&\n      isSimpleMemberExpression(expression.object))\n  );\n}\n\n/**\n * Test if a given optional chain `path` needs to be memoized\n * @param {NodePath} path\n * @returns {boolean}\n */\nfunction needsMemoize(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n) {\n  let optionalPath: NodePath = path;\n  const { scope } = path;\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    const childPath = skipTransparentExprWrappers(\n      // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n      optionalPath.isOptionalMemberExpression()\n        ? optionalPath.get(\"object\")\n        : optionalPath.get(\"callee\"),\n    );\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n\n    optionalPath = childPath;\n  }\n}\n\nexport function transform(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n  {\n    pureGetters,\n    noDocumentAll,\n  }: { pureGetters: boolean; noDocumentAll: boolean },\n) {\n  const { scope } = path;\n  // maybeWrapped points to the outermost transparent expression wrapper\n  // or the path itself\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { parentPath } = maybeWrapped;\n  const willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);\n  let isDeleteOperation = false;\n  const parentIsCall =\n    parentPath.isCallExpression({ callee: maybeWrapped.node }) &&\n    // note that the first condition must implies that `path.optional` is `true`,\n    // otherwise the parentPath should be an OptionalCallExpression\n    path.isOptionalMemberExpression();\n\n  const optionals = [];\n\n  let optionalPath = path;\n  // Replace `function (a, x = a.b?.c) {}` to `function (a, x = (() => a.b?.c)() ){}`\n  // so the temporary variable can be injected in correct scope\n  if (scope.path.isPattern() && needsMemoize(optionalPath)) {\n    path.replaceWith(template.ast`(() => ${path.node})()` as t.Statement);\n    // The injected optional chain will be queued and eventually transformed when visited\n    return;\n  }\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n    // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n    if (optionalPath.isOptionalMemberExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"MemberExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"CallExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n\n  // todo: Improve replacementPath typings\n  let replacementPath: NodePath<any> = path;\n  if (parentPath.isUnaryExpression({ operator: \"delete\" })) {\n    replacementPath = parentPath;\n    isDeleteOperation = true;\n  }\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i] as unknown as\n      | t.MemberExpression\n      | t.CallExpression;\n\n    const isCall = t.isCallExpression(node);\n\n    const chainWithTypes = isCall\n      ? // V8 intrinsics must not be an optional call\n        (node.callee as t.Expression)\n      : node.object;\n    const chain = skipTransparentExprWrapperNodes(chainWithTypes);\n\n    let ref;\n    let check;\n    if (isCall && t.isIdentifier(chain, { name: \"eval\" })) {\n      check = ref = chain;\n      // `eval?.()` is an indirect eval call transformed to `(0,eval)()`\n      node.callee = t.sequenceExpression([t.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      // If we assume getters are pure (avoiding a Function#call) and we are at the call,\n      // we can avoid a needless memoize. We only do this if the callee is a simple member\n      // expression, to avoid multiple calls to nested call expressions.\n      check = ref = node.callee;\n    } else {\n      ref = scope.maybeGenerateMemoised(chain);\n      if (ref) {\n        check = t.assignmentExpression(\n          \"=\",\n          t.cloneNode(ref),\n          // Here `chainWithTypes` MUST NOT be cloned because it could be\n          // updated when generating the memoised context of a call\n          // expression. It must be an Expression when `ref` is an identifier\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n          chainWithTypes as t.Expression,\n        );\n\n        isCall ? (node.callee = ref) : (node.object = ref);\n      } else {\n        check = ref = chainWithTypes;\n      }\n    }\n\n    // Ensure call expressions have the proper `this`\n    // `foo.bar()` has context `foo`.\n    if (isCall && t.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        // To avoid a Function#call, we can instead re-grab the property from the context object.\n        // `a.?b.?()` translates roughly to `_a.b != null && _a.b()`\n        node.callee = chainWithTypes;\n      } else {\n        // Otherwise, we need to memoize the context object, and change the call into a Function#call.\n        // `a.?b.?()` translates roughly to `(_b = _a.b) != null && _b.call(_a)`\n        const { object } = chain;\n        let context: t.Expression;\n        if (t.isSuper(object)) {\n          context = t.thisExpression();\n        } else {\n          const memoized = scope.maybeGenerateMemoised(object);\n          if (memoized) {\n            context = memoized;\n            chain.object = t.assignmentExpression(\"=\", memoized, object);\n          } else {\n            context = object;\n          }\n        }\n\n        node.arguments.unshift(t.cloneNode(context));\n        // @ts-expect-error node.callee can not be an V8IntrinsicIdentifier: V8 intrinsic is disallowed in optional chain\n        node.callee = t.memberExpression(node.callee, t.identifier(\"call\"));\n      }\n    }\n    let replacement = replacementPath.node;\n    // Ensure (a?.b)() has proper `this`\n    // The `parentIsCall` is constant within loop, we should check i === 0\n    // to ensure that it is only applied to the first optional chain element\n    // i.e. `?.b` in `(a?.b.c)()`\n    if (i === 0 && parentIsCall) {\n      // `(a?.b)()` to `(a == null ? undefined : a.b.bind(a))()`\n      // object must not be Super as super?.foo is invalid\n      const object = skipTransparentExprWrapperNodes(\n        replacement.object,\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      ) as any as t.Expression;\n      let baseRef;\n      if (!pureGetters || !isSimpleMemberExpression(object)) {\n        // memoize the context object when getters are not always pure\n        // or the object is not a simple member expression\n        // `(a?.b.c)()` to `(a == null ? undefined : (_a$b = a.b).c.bind(_a$b))()`\n        baseRef = scope.maybeGenerateMemoised(object);\n        if (baseRef) {\n          replacement.object = t.assignmentExpression(\"=\", baseRef, object);\n        }\n      }\n      replacement = t.callExpression(\n        t.memberExpression(replacement, t.identifier(\"bind\")),\n        [t.cloneNode(baseRef ?? object)],\n      );\n    }\n\n    if (willReplacementCastToBoolean) {\n      // `if (a?.b) {}` transformed to `if (a != null && a.b) {}`\n      // we don't need to return `void 0` because the returned value will\n      // eventually cast to boolean.\n      const nonNullishCheck = noDocumentAll\n        ? ast`${t.cloneNode(check)} != null`\n        : ast`\n            ${t.cloneNode(check)} !== null && ${t.cloneNode(ref)} !== void 0`;\n      replacementPath.replaceWith(\n        t.logicalExpression(\"&&\", nonNullishCheck, replacement),\n      );\n      replacementPath = skipTransparentExprWrappers(\n        // @ts-expect-error todo(flow->ts)\n        replacementPath.get(\"right\"),\n      );\n    } else {\n      const nullishCheck = noDocumentAll\n        ? ast`${t.cloneNode(check)} == null`\n        : ast`\n            ${t.cloneNode(check)} === null || ${t.cloneNode(ref)} === void 0`;\n\n      const returnValue = isDeleteOperation ? ast`true` : ast`void 0`;\n      replacementPath.replaceWith(\n        t.conditionalExpression(nullishCheck, returnValue, replacement),\n      );\n      replacementPath = skipTransparentExprWrappers(\n        // @ts-expect-error todo(flow->ts)\n        replacementPath.get(\"alternate\"),\n      );\n    }\n  }\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxOptionalChaining from \"@babel/plugin-syntax-optional-chaining\";\nimport { transform } from \"./transform\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\nexport interface Options {\n  loose?: boolean;\n}\nexport default declare((api, options: Options) => {\n  api.assertVersion(7);\n\n  const { loose = false } = options;\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? loose;\n  const pureGetters = api.assumption(\"pureGetters\") ?? loose;\n\n  return {\n    name: \"transform-optional-chaining\",\n    inherits: syntaxOptionalChaining.default,\n\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(\n        path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n      ) {\n        transform(path, { noDocumentAll, pureGetters });\n      },\n    },\n  };\n});\n\nexport { transform };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}