{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\nconst {\n  cleanupOutData\n} = require('../lib/svgo/tools.js');\nconst {\n  transform2js,\n  transformsMultiply,\n  matrixToTransform\n} = require('./_transforms.js');\nexports.name = 'convertTransform';\nexports.description = 'collapses multiple transformations and optimizes it';\n\n/**\n * Convert matrices to the short aliases,\n * convert long translate, scale or rotate transform notations to the shorts ones,\n * convert transforms to the matrices and multiply them all into one,\n * remove useless transforms.\n *\n * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'convertTransform'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    convertToShorts = true,\n    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default\n    degPrecision,\n    floatPrecision = 3,\n    transformPrecision = 5,\n    matrixToTransform = true,\n    shortTranslate = true,\n    shortScale = true,\n    shortRotate = true,\n    removeUseless = true,\n    collapseIntoOne = true,\n    leadingZero = true,\n    negativeExtraSpace = false\n  } = params;\n  const newParams = {\n    convertToShorts,\n    degPrecision,\n    floatPrecision,\n    transformPrecision,\n    matrixToTransform,\n    shortTranslate,\n    shortScale,\n    shortRotate,\n    removeUseless,\n    collapseIntoOne,\n    leadingZero,\n    negativeExtraSpace\n  };\n  return {\n    element: {\n      enter: node => {\n        // transform\n        if (node.attributes.transform != null) {\n          convertTransform(node, 'transform', newParams);\n        }\n        // gradientTransform\n        if (node.attributes.gradientTransform != null) {\n          convertTransform(node, 'gradientTransform', newParams);\n        }\n        // patternTransform\n        if (node.attributes.patternTransform != null) {\n          convertTransform(node, 'patternTransform', newParams);\n        }\n      }\n    }\n  };\n};\n\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   degPrecision?: number,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Main function.\n *\n * @type {(item: XastElement, attrName: string, params: TransformParams) => void}\n */\nconst convertTransform = (item, attrName, params) => {\n  let data = transform2js(item.attributes[attrName]);\n  params = definePrecision(data, params);\n  if (params.collapseIntoOne && data.length > 1) {\n    data = [transformsMultiply(data)];\n  }\n  if (params.convertToShorts) {\n    data = convertToShorts(data, params);\n  } else {\n    data.forEach(item => roundTransform(item, params));\n  }\n  if (params.removeUseless) {\n    data = removeUseless(data);\n  }\n  if (data.length) {\n    item.attributes[attrName] = js2transform(data, params);\n  } else {\n    delete item.attributes[attrName];\n  }\n};\n\n/**\n * Defines precision to work with certain parts.\n * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),\n * floatPrecision - for translate including two last matrix and rotate parameters,\n * degPrecision - for rotate and skew. By default it's equal to (rougly)\n * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.\n *\n * @type {(data: Array<TransformItem>, params: TransformParams) => TransformParams}\n *\n * clone params so it don't affect other elements transformations.\n */\nconst definePrecision = (data, _ref) => {\n  let {\n    ...newParams\n  } = _ref;\n  const matrixData = [];\n  for (const item of data) {\n    if (item.name == 'matrix') {\n      matrixData.push(...item.data.slice(0, 4));\n    }\n  }\n  let significantDigits = newParams.transformPrecision;\n  // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.\n  if (matrixData.length) {\n    newParams.transformPrecision = Math.min(newParams.transformPrecision, Math.max.apply(Math, matrixData.map(floatDigits)) || newParams.transformPrecision);\n    significantDigits = Math.max.apply(Math, matrixData.map(n => n.toString().replace(/\\D+/g, '').length // Number of digits in a number. 123.45 → 5\n    ));\n  }\n  // No sense in angle precision more then number of significant digits in matrix.\n  if (newParams.degPrecision == null) {\n    newParams.degPrecision = Math.max(0, Math.min(newParams.floatPrecision, significantDigits - 2));\n  }\n  return newParams;\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst degRound = (data, params) => {\n  if (params.degPrecision != null && params.degPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.degPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst floatRound = (data, params) => {\n  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.floatPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst transformRound = (data, params) => {\n  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.transformPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * Returns number of digits after the point. 0.125 → 3\n *\n * @type {(n: number) => number}\n */\nconst floatDigits = n => {\n  const str = n.toString();\n  return str.slice(str.indexOf('.')).length - 1;\n};\n\n/**\n * Convert transforms to the shorthand alternatives.\n *\n * @type {(transforms: Array<TransformItem>, params: TransformParams) => Array<TransformItem>}\n */\nconst convertToShorts = (transforms, params) => {\n  for (var i = 0; i < transforms.length; i++) {\n    var transform = transforms[i];\n\n    // convert matrix to the short aliases\n    if (params.matrixToTransform && transform.name === 'matrix') {\n      var decomposed = matrixToTransform(transform, params);\n      if (js2transform(decomposed, params).length <= js2transform([transform], params).length) {\n        transforms.splice(i, 1, ...decomposed);\n      }\n      transform = transforms[i];\n    }\n\n    // fixed-point numbers\n    // 12.754997 → 12.755\n    roundTransform(transform, params);\n\n    // convert long translate transform notation to the shorts one\n    // translate(10 0) → translate(10)\n    if (params.shortTranslate && transform.name === 'translate' && transform.data.length === 2 && !transform.data[1]) {\n      transform.data.pop();\n    }\n\n    // convert long scale transform notation to the shorts one\n    // scale(2 2) → scale(2)\n    if (params.shortScale && transform.name === 'scale' && transform.data.length === 2 && transform.data[0] === transform.data[1]) {\n      transform.data.pop();\n    }\n\n    // convert long rotate transform notation to the short one\n    // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)\n    if (params.shortRotate && transforms[i - 2] && transforms[i - 2].name === 'translate' && transforms[i - 1].name === 'rotate' && transforms[i].name === 'translate' && transforms[i - 2].data[0] === -transforms[i].data[0] && transforms[i - 2].data[1] === -transforms[i].data[1]) {\n      transforms.splice(i - 2, 3, {\n        name: 'rotate',\n        data: [transforms[i - 1].data[0], transforms[i - 2].data[0], transforms[i - 2].data[1]]\n      });\n\n      // splice compensation\n      i -= 2;\n    }\n  }\n  return transforms;\n};\n\n/**\n * Remove useless transforms.\n *\n * @type {(trasforms: Array<TransformItem>) => Array<TransformItem>}\n */\nconst removeUseless = transforms => {\n  return transforms.filter(transform => {\n    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)\n    if (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 && (transform.data.length == 1 || transform.name == 'rotate') && !transform.data[0] ||\n    // translate(0, 0)\n    transform.name == 'translate' && !transform.data[0] && !transform.data[1] ||\n    // scale(1)\n    transform.name == 'scale' && transform.data[0] == 1 && (transform.data.length < 2 || transform.data[1] == 1) ||\n    // matrix(1 0 0 1 0 0)\n    transform.name == 'matrix' && transform.data[0] == 1 && transform.data[3] == 1 && !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])) {\n      return false;\n    }\n    return true;\n  });\n};\n\n/**\n * Convert transforms JS representation to string.\n *\n * @type {(transformJS: Array<TransformItem>, params: TransformParams) => string}\n */\nconst js2transform = (transformJS, params) => {\n  var transformString = '';\n\n  // collect output value string\n  transformJS.forEach(transform => {\n    roundTransform(transform, params);\n    transformString += (transformString && ' ') + transform.name + '(' + cleanupOutData(transform.data, params) + ')';\n  });\n  return transformString;\n};\n\n/**\n * @type {(transform: TransformItem, params: TransformParams) => TransformItem}\n */\nconst roundTransform = (transform, params) => {\n  switch (transform.name) {\n    case 'translate':\n      transform.data = floatRound(transform.data, params);\n      break;\n    case 'rotate':\n      transform.data = [...degRound(transform.data.slice(0, 1), params), ...floatRound(transform.data.slice(1), params)];\n      break;\n    case 'skewX':\n    case 'skewY':\n      transform.data = degRound(transform.data, params);\n      break;\n    case 'scale':\n      transform.data = transformRound(transform.data, params);\n      break;\n    case 'matrix':\n      transform.data = [...transformRound(transform.data.slice(0, 4), params), ...floatRound(transform.data.slice(4), params)];\n      break;\n  }\n  return transform;\n};\n\n/**\n * Rounds numbers in array.\n *\n * @type {(data: Array<number>) => Array<number>}\n */\nconst round = data => {\n  return data.map(Math.round);\n};\n\n/**\n * Decrease accuracy of floating-point numbers\n * in transforms keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @type {(precision: number, data: Array<number>) => Array<number>}\n */\nconst smartRound = (precision, data) => {\n  for (var i = data.length, tolerance = +Math.pow(0.1, precision).toFixed(precision); i--;) {\n    if (Number(data[i].toFixed(precision)) !== data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance ? +data[i].toFixed(precision) : rounded;\n    }\n  }\n  return data;\n};","map":{"version":3,"names":["cleanupOutData","require","transform2js","transformsMultiply","matrixToTransform","exports","name","description","fn","_root","params","convertToShorts","degPrecision","floatPrecision","transformPrecision","shortTranslate","shortScale","shortRotate","removeUseless","collapseIntoOne","leadingZero","negativeExtraSpace","newParams","element","enter","node","attributes","transform","convertTransform","gradientTransform","patternTransform","item","attrName","data","definePrecision","length","forEach","roundTransform","js2transform","_ref","matrixData","push","slice","significantDigits","Math","min","max","apply","map","floatDigits","n","toString","replace","degRound","smartRound","round","floatRound","transformRound","str","indexOf","transforms","i","decomposed","splice","pop","filter","transformJS","transformString","precision","tolerance","pow","toFixed","Number","rounded","abs"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/convertTransform.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { cleanupOutData } = require('../lib/svgo/tools.js');\nconst {\n  transform2js,\n  transformsMultiply,\n  matrixToTransform,\n} = require('./_transforms.js');\n\nexports.name = 'convertTransform';\nexports.description = 'collapses multiple transformations and optimizes it';\n\n/**\n * Convert matrices to the short aliases,\n * convert long translate, scale or rotate transform notations to the shorts ones,\n * convert transforms to the matrices and multiply them all into one,\n * remove useless transforms.\n *\n * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'convertTransform'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    convertToShorts = true,\n    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default\n    degPrecision,\n    floatPrecision = 3,\n    transformPrecision = 5,\n    matrixToTransform = true,\n    shortTranslate = true,\n    shortScale = true,\n    shortRotate = true,\n    removeUseless = true,\n    collapseIntoOne = true,\n    leadingZero = true,\n    negativeExtraSpace = false,\n  } = params;\n  const newParams = {\n    convertToShorts,\n    degPrecision,\n    floatPrecision,\n    transformPrecision,\n    matrixToTransform,\n    shortTranslate,\n    shortScale,\n    shortRotate,\n    removeUseless,\n    collapseIntoOne,\n    leadingZero,\n    negativeExtraSpace,\n  };\n  return {\n    element: {\n      enter: (node) => {\n        // transform\n        if (node.attributes.transform != null) {\n          convertTransform(node, 'transform', newParams);\n        }\n        // gradientTransform\n        if (node.attributes.gradientTransform != null) {\n          convertTransform(node, 'gradientTransform', newParams);\n        }\n        // patternTransform\n        if (node.attributes.patternTransform != null) {\n          convertTransform(node, 'patternTransform', newParams);\n        }\n      },\n    },\n  };\n};\n\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   degPrecision?: number,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Main function.\n *\n * @type {(item: XastElement, attrName: string, params: TransformParams) => void}\n */\nconst convertTransform = (item, attrName, params) => {\n  let data = transform2js(item.attributes[attrName]);\n  params = definePrecision(data, params);\n\n  if (params.collapseIntoOne && data.length > 1) {\n    data = [transformsMultiply(data)];\n  }\n\n  if (params.convertToShorts) {\n    data = convertToShorts(data, params);\n  } else {\n    data.forEach((item) => roundTransform(item, params));\n  }\n\n  if (params.removeUseless) {\n    data = removeUseless(data);\n  }\n\n  if (data.length) {\n    item.attributes[attrName] = js2transform(data, params);\n  } else {\n    delete item.attributes[attrName];\n  }\n};\n\n/**\n * Defines precision to work with certain parts.\n * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),\n * floatPrecision - for translate including two last matrix and rotate parameters,\n * degPrecision - for rotate and skew. By default it's equal to (rougly)\n * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.\n *\n * @type {(data: Array<TransformItem>, params: TransformParams) => TransformParams}\n *\n * clone params so it don't affect other elements transformations.\n */\nconst definePrecision = (data, { ...newParams }) => {\n  const matrixData = [];\n  for (const item of data) {\n    if (item.name == 'matrix') {\n      matrixData.push(...item.data.slice(0, 4));\n    }\n  }\n  let significantDigits = newParams.transformPrecision;\n  // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.\n  if (matrixData.length) {\n    newParams.transformPrecision = Math.min(\n      newParams.transformPrecision,\n      Math.max.apply(Math, matrixData.map(floatDigits)) ||\n        newParams.transformPrecision\n    );\n    significantDigits = Math.max.apply(\n      Math,\n      matrixData.map(\n        (n) => n.toString().replace(/\\D+/g, '').length // Number of digits in a number. 123.45 → 5\n      )\n    );\n  }\n  // No sense in angle precision more then number of significant digits in matrix.\n  if (newParams.degPrecision == null) {\n    newParams.degPrecision = Math.max(\n      0,\n      Math.min(newParams.floatPrecision, significantDigits - 2)\n    );\n  }\n  return newParams;\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst degRound = (data, params) => {\n  if (\n    params.degPrecision != null &&\n    params.degPrecision >= 1 &&\n    params.floatPrecision < 20\n  ) {\n    return smartRound(params.degPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst floatRound = (data, params) => {\n  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.floatPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst transformRound = (data, params) => {\n  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.transformPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * Returns number of digits after the point. 0.125 → 3\n *\n * @type {(n: number) => number}\n */\nconst floatDigits = (n) => {\n  const str = n.toString();\n  return str.slice(str.indexOf('.')).length - 1;\n};\n\n/**\n * Convert transforms to the shorthand alternatives.\n *\n * @type {(transforms: Array<TransformItem>, params: TransformParams) => Array<TransformItem>}\n */\nconst convertToShorts = (transforms, params) => {\n  for (var i = 0; i < transforms.length; i++) {\n    var transform = transforms[i];\n\n    // convert matrix to the short aliases\n    if (params.matrixToTransform && transform.name === 'matrix') {\n      var decomposed = matrixToTransform(transform, params);\n      if (\n        js2transform(decomposed, params).length <=\n        js2transform([transform], params).length\n      ) {\n        transforms.splice(i, 1, ...decomposed);\n      }\n      transform = transforms[i];\n    }\n\n    // fixed-point numbers\n    // 12.754997 → 12.755\n    roundTransform(transform, params);\n\n    // convert long translate transform notation to the shorts one\n    // translate(10 0) → translate(10)\n    if (\n      params.shortTranslate &&\n      transform.name === 'translate' &&\n      transform.data.length === 2 &&\n      !transform.data[1]\n    ) {\n      transform.data.pop();\n    }\n\n    // convert long scale transform notation to the shorts one\n    // scale(2 2) → scale(2)\n    if (\n      params.shortScale &&\n      transform.name === 'scale' &&\n      transform.data.length === 2 &&\n      transform.data[0] === transform.data[1]\n    ) {\n      transform.data.pop();\n    }\n\n    // convert long rotate transform notation to the short one\n    // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)\n    if (\n      params.shortRotate &&\n      transforms[i - 2] &&\n      transforms[i - 2].name === 'translate' &&\n      transforms[i - 1].name === 'rotate' &&\n      transforms[i].name === 'translate' &&\n      transforms[i - 2].data[0] === -transforms[i].data[0] &&\n      transforms[i - 2].data[1] === -transforms[i].data[1]\n    ) {\n      transforms.splice(i - 2, 3, {\n        name: 'rotate',\n        data: [\n          transforms[i - 1].data[0],\n          transforms[i - 2].data[0],\n          transforms[i - 2].data[1],\n        ],\n      });\n\n      // splice compensation\n      i -= 2;\n    }\n  }\n\n  return transforms;\n};\n\n/**\n * Remove useless transforms.\n *\n * @type {(trasforms: Array<TransformItem>) => Array<TransformItem>}\n */\nconst removeUseless = (transforms) => {\n  return transforms.filter((transform) => {\n    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)\n    if (\n      (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 &&\n        (transform.data.length == 1 || transform.name == 'rotate') &&\n        !transform.data[0]) ||\n      // translate(0, 0)\n      (transform.name == 'translate' &&\n        !transform.data[0] &&\n        !transform.data[1]) ||\n      // scale(1)\n      (transform.name == 'scale' &&\n        transform.data[0] == 1 &&\n        (transform.data.length < 2 || transform.data[1] == 1)) ||\n      // matrix(1 0 0 1 0 0)\n      (transform.name == 'matrix' &&\n        transform.data[0] == 1 &&\n        transform.data[3] == 1 &&\n        !(\n          transform.data[1] ||\n          transform.data[2] ||\n          transform.data[4] ||\n          transform.data[5]\n        ))\n    ) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\n/**\n * Convert transforms JS representation to string.\n *\n * @type {(transformJS: Array<TransformItem>, params: TransformParams) => string}\n */\nconst js2transform = (transformJS, params) => {\n  var transformString = '';\n\n  // collect output value string\n  transformJS.forEach((transform) => {\n    roundTransform(transform, params);\n    transformString +=\n      (transformString && ' ') +\n      transform.name +\n      '(' +\n      cleanupOutData(transform.data, params) +\n      ')';\n  });\n\n  return transformString;\n};\n\n/**\n * @type {(transform: TransformItem, params: TransformParams) => TransformItem}\n */\nconst roundTransform = (transform, params) => {\n  switch (transform.name) {\n    case 'translate':\n      transform.data = floatRound(transform.data, params);\n      break;\n    case 'rotate':\n      transform.data = [\n        ...degRound(transform.data.slice(0, 1), params),\n        ...floatRound(transform.data.slice(1), params),\n      ];\n      break;\n    case 'skewX':\n    case 'skewY':\n      transform.data = degRound(transform.data, params);\n      break;\n    case 'scale':\n      transform.data = transformRound(transform.data, params);\n      break;\n    case 'matrix':\n      transform.data = [\n        ...transformRound(transform.data.slice(0, 4), params),\n        ...floatRound(transform.data.slice(4), params),\n      ];\n      break;\n  }\n  return transform;\n};\n\n/**\n * Rounds numbers in array.\n *\n * @type {(data: Array<number>) => Array<number>}\n */\nconst round = (data) => {\n  return data.map(Math.round);\n};\n\n/**\n * Decrease accuracy of floating-point numbers\n * in transforms keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @type {(precision: number, data: Array<number>) => Array<number>}\n */\nconst smartRound = (precision, data) => {\n  for (\n    var i = data.length,\n      tolerance = +Math.pow(0.1, precision).toFixed(precision);\n    i--;\n\n  ) {\n    if (Number(data[i].toFixed(precision)) !== data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] =\n        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance\n          ? +data[i].toFixed(precision)\n          : rounded;\n    }\n  }\n  return data;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}