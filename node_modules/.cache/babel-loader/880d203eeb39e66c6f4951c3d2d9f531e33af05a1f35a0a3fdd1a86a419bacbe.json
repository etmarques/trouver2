{"ast":null,"code":"'use strict';\n\nconst regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;\nconst regTransformSplit = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nconst regNumericValues = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Convert transform string to JS representation.\n *\n * @type {(transformString: string) => Array<TransformItem>}\n */\nexports.transform2js = transformString => {\n  // JS representation of the transform data\n  /**\n   * @type {Array<TransformItem>}\n   */\n  const transforms = [];\n  // current transform context\n  /**\n   * @type {null | TransformItem}\n   */\n  let current = null;\n  // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n  for (const item of transformString.split(regTransformSplit)) {\n    var num;\n    if (item) {\n      // if item is a translate function\n      if (regTransformTypes.test(item)) {\n        // then collect it and change current context\n        current = {\n          name: item,\n          data: []\n        };\n        transforms.push(current);\n        // else if item is data\n      } else {\n        // then split it into [10, 50] and collect as context.data\n        // eslint-disable-next-line no-cond-assign\n        while (num = regNumericValues.exec(item)) {\n          num = Number(num);\n          if (current != null) {\n            current.data.push(num);\n          }\n        }\n      }\n    }\n  }\n  // return empty array if broken transform (no data)\n  return current == null || current.data.length == 0 ? [] : transforms;\n};\n\n/**\n * Multiply transforms into one.\n *\n * @type {(transforms: Array<TransformItem>) => TransformItem}\n */\nexports.transformsMultiply = transforms => {\n  // convert transforms objects to the matrices\n  const matrixData = transforms.map(transform => {\n    if (transform.name === 'matrix') {\n      return transform.data;\n    }\n    return transformToMatrix(transform);\n  });\n  // multiply all matrices into one\n  const matrixTransform = {\n    name: 'matrix',\n    data: matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : []\n  };\n  return matrixTransform;\n};\n\n/**\n * math utilities in radians.\n */\nconst mth = {\n  /**\n   * @type {(deg: number) => number}\n   */\n  rad: deg => {\n    return deg * Math.PI / 180;\n  },\n  /**\n   * @type {(rad: number) => number}\n   */\n  deg: rad => {\n    return rad * 180 / Math.PI;\n  },\n  /**\n   * @type {(deg: number) => number}\n   */\n  cos: deg => {\n    return Math.cos(mth.rad(deg));\n  },\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  acos: (val, floatPrecision) => {\n    return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision));\n  },\n  /**\n   * @type {(deg: number) => number}\n   */\n  sin: deg => {\n    return Math.sin(mth.rad(deg));\n  },\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  asin: (val, floatPrecision) => {\n    return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision));\n  },\n  /**\n   * @type {(deg: number) => number}\n   */\n  tan: deg => {\n    return Math.tan(mth.rad(deg));\n  },\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  atan: (val, floatPrecision) => {\n    return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision));\n  }\n};\n\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * Decompose matrix into simple transforms. See\n * https://frederic-wang.fr/decomposition-of-2d-transform-matrices.html\n *\n * @type {(transform: TransformItem, params: TransformParams) => Array<TransformItem>}\n */\nexports.matrixToTransform = (transform, params) => {\n  let floatPrecision = params.floatPrecision;\n  let data = transform.data;\n  let transforms = [];\n  let sx = Number(Math.hypot(data[0], data[1]).toFixed(params.transformPrecision));\n  let sy = Number(((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(params.transformPrecision));\n  let colsSum = data[0] * data[2] + data[1] * data[3];\n  let rowsSum = data[0] * data[1] + data[2] * data[3];\n  let scaleBefore = rowsSum != 0 || sx == sy;\n\n  // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n  if (data[4] || data[5]) {\n    transforms.push({\n      name: 'translate',\n      data: data.slice(4, data[5] ? 6 : 5)\n    });\n  }\n\n  // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n  if (!data[1] && data[2]) {\n    transforms.push({\n      name: 'skewX',\n      data: [mth.atan(data[2] / sy, floatPrecision)]\n    });\n\n    // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n  } else if (data[1] && !data[2]) {\n    transforms.push({\n      name: 'skewY',\n      data: [mth.atan(data[1] / data[0], floatPrecision)]\n    });\n    sx = data[0];\n    sy = data[3];\n\n    // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n  } else if (!colsSum || sx == 1 && sy == 1 || !scaleBefore) {\n    if (!scaleBefore) {\n      sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);\n      sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);\n      transforms.push({\n        name: 'scale',\n        data: [sx, sy]\n      });\n    }\n    var angle = Math.min(Math.max(-1, data[0] / sx), 1),\n      rotate = [mth.acos(angle, floatPrecision) * ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1)];\n    if (rotate[0]) transforms.push({\n      name: 'rotate',\n      data: rotate\n    });\n    if (rowsSum && colsSum) transforms.push({\n      name: 'skewX',\n      data: [mth.atan(colsSum / (sx * sx), floatPrecision)]\n    });\n\n    // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n    if (rotate[0] && (data[4] || data[5])) {\n      transforms.shift();\n      var cos = data[0] / sx,\n        sin = data[1] / (scaleBefore ? sx : sy),\n        x = data[4] * (scaleBefore ? 1 : sy),\n        y = data[5] * (scaleBefore ? 1 : sx),\n        denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore ? 1 : sx * sy);\n      rotate.push(((1 - cos) * x - sin * y) / denom);\n      rotate.push(((1 - cos) * y + sin * x) / denom);\n    }\n\n    // Too many transformations, return original matrix if it isn't just a scale/translate\n  } else if (data[1] || data[2]) {\n    return [transform];\n  }\n  if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) transforms.push({\n    name: 'scale',\n    data: sx == sy ? [sx] : [sx, sy]\n  });\n  return transforms;\n};\n\n/**\n * Convert transform to the matrix data.\n *\n * @type {(transform: TransformItem) => Array<number> }\n */\nconst transformToMatrix = transform => {\n  if (transform.name === 'matrix') {\n    return transform.data;\n  }\n  switch (transform.name) {\n    case 'translate':\n      // [1, 0, 0, 1, tx, ty]\n      return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n    case 'scale':\n      // [sx, 0, 0, sy, 0, 0]\n      return [transform.data[0], 0, 0, transform.data[1] || transform.data[0], 0, 0];\n    case 'rotate':\n      // [cos(a), sin(a), -sin(a), cos(a), x, y]\n      var cos = mth.cos(transform.data[0]),\n        sin = mth.sin(transform.data[0]),\n        cx = transform.data[1] || 0,\n        cy = transform.data[2] || 0;\n      return [cos, sin, -sin, cos, (1 - cos) * cx + sin * cy, (1 - cos) * cy - sin * cx];\n    case 'skewX':\n      // [1, 0, tan(a), 1, 0, 0]\n      return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n    case 'skewY':\n      // [1, tan(a), 0, 1, 0, 0]\n      return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n    default:\n      throw Error(`Unknown transform ${transform.name}`);\n  }\n};\n\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @type {(\n *   cursor: [x: number, y: number],\n *   arc: Array<number>,\n *   transform: Array<number>\n * ) => Array<number>}\n */\nexports.transformArc = (cursor, arc, transform) => {\n  const x = arc[5] - cursor[0];\n  const y = arc[6] - cursor[1];\n  let a = arc[0];\n  let b = arc[1];\n  const rot = arc[2] * Math.PI / 180;\n  const cos = Math.cos(rot);\n  const sin = Math.sin(rot);\n  // skip if radius is 0\n  if (a > 0 && b > 0) {\n    let h = Math.pow(x * cos + y * sin, 2) / (4 * a * a) + Math.pow(y * cos - x * sin, 2) / (4 * b * b);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      a *= h;\n      b *= h;\n    }\n  }\n  const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];\n  const m = multiplyTransformMatrices(transform, ellipse);\n  // Decompose the new ellipse matrix\n  const lastCol = m[2] * m[2] + m[3] * m[3];\n  const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;\n  const root = Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);\n  if (!root) {\n    // circle\n    arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n    arc[2] = 0;\n  } else {\n    const majorAxisSqr = (squareSum + root) / 2;\n    const minorAxisSqr = (squareSum - root) / 2;\n    const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;\n    const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;\n    const rowsSum = m[0] * m[2] + m[1] * m[3];\n    const term1 = m[0] * sub + m[2] * rowsSum;\n    const term2 = m[1] * sub + m[3] * rowsSum;\n    arc[0] = Math.sqrt(majorAxisSqr);\n    arc[1] = Math.sqrt(minorAxisSqr);\n    arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) * 180 / Math.PI;\n  }\n  if (transform[0] < 0 !== transform[3] < 0) {\n    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically\n    arc[4] = 1 - arc[4];\n  }\n  return arc;\n};\n\n/**\n * Multiply transformation matrices.\n *\n * @type {(a: Array<number>, b: Array<number>) => Array<number>}\n */\nconst multiplyTransformMatrices = (a, b) => {\n  return [a[0] * b[0] + a[2] * b[1], a[1] * b[0] + a[3] * b[1], a[0] * b[2] + a[2] * b[3], a[1] * b[2] + a[3] * b[3], a[0] * b[4] + a[2] * b[5] + a[4], a[1] * b[4] + a[3] * b[5] + a[5]];\n};","map":{"version":3,"names":["regTransformTypes","regTransformSplit","regNumericValues","exports","transform2js","transformString","transforms","current","item","split","num","test","name","data","push","exec","Number","length","transformsMultiply","matrixData","map","transform","transformToMatrix","matrixTransform","reduce","multiplyTransformMatrices","mth","rad","deg","Math","PI","cos","acos","val","floatPrecision","toFixed","sin","asin","tan","atan","matrixToTransform","params","sx","hypot","transformPrecision","sy","colsSum","rowsSum","scaleBefore","slice","angle","min","max","rotate","shift","x","y","denom","pow","cx","cy","Error","transformArc","cursor","arc","a","b","rot","h","sqrt","ellipse","m","lastCol","squareSum","root","majorAxisSqr","minorAxisSqr","major","abs","sub","term1","term2"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/_transforms.js"],"sourcesContent":["'use strict';\n\nconst regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;\nconst regTransformSplit =\n  /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nconst regNumericValues = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Convert transform string to JS representation.\n *\n * @type {(transformString: string) => Array<TransformItem>}\n */\nexports.transform2js = (transformString) => {\n  // JS representation of the transform data\n  /**\n   * @type {Array<TransformItem>}\n   */\n  const transforms = [];\n  // current transform context\n  /**\n   * @type {null | TransformItem}\n   */\n  let current = null;\n  // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n  for (const item of transformString.split(regTransformSplit)) {\n    var num;\n    if (item) {\n      // if item is a translate function\n      if (regTransformTypes.test(item)) {\n        // then collect it and change current context\n        current = { name: item, data: [] };\n        transforms.push(current);\n        // else if item is data\n      } else {\n        // then split it into [10, 50] and collect as context.data\n        // eslint-disable-next-line no-cond-assign\n        while ((num = regNumericValues.exec(item))) {\n          num = Number(num);\n          if (current != null) {\n            current.data.push(num);\n          }\n        }\n      }\n    }\n  }\n  // return empty array if broken transform (no data)\n  return current == null || current.data.length == 0 ? [] : transforms;\n};\n\n/**\n * Multiply transforms into one.\n *\n * @type {(transforms: Array<TransformItem>) => TransformItem}\n */\nexports.transformsMultiply = (transforms) => {\n  // convert transforms objects to the matrices\n  const matrixData = transforms.map((transform) => {\n    if (transform.name === 'matrix') {\n      return transform.data;\n    }\n    return transformToMatrix(transform);\n  });\n  // multiply all matrices into one\n  const matrixTransform = {\n    name: 'matrix',\n    data:\n      matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : [],\n  };\n  return matrixTransform;\n};\n\n/**\n * math utilities in radians.\n */\nconst mth = {\n  /**\n   * @type {(deg: number) => number}\n   */\n  rad: (deg) => {\n    return (deg * Math.PI) / 180;\n  },\n\n  /**\n   * @type {(rad: number) => number}\n   */\n  deg: (rad) => {\n    return (rad * 180) / Math.PI;\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  cos: (deg) => {\n    return Math.cos(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  acos: (val, floatPrecision) => {\n    return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision));\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  sin: (deg) => {\n    return Math.sin(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  asin: (val, floatPrecision) => {\n    return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision));\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  tan: (deg) => {\n    return Math.tan(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  atan: (val, floatPrecision) => {\n    return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision));\n  },\n};\n\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * Decompose matrix into simple transforms. See\n * https://frederic-wang.fr/decomposition-of-2d-transform-matrices.html\n *\n * @type {(transform: TransformItem, params: TransformParams) => Array<TransformItem>}\n */\nexports.matrixToTransform = (transform, params) => {\n  let floatPrecision = params.floatPrecision;\n  let data = transform.data;\n  let transforms = [];\n  let sx = Number(\n    Math.hypot(data[0], data[1]).toFixed(params.transformPrecision)\n  );\n  let sy = Number(\n    ((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(\n      params.transformPrecision\n    )\n  );\n  let colsSum = data[0] * data[2] + data[1] * data[3];\n  let rowsSum = data[0] * data[1] + data[2] * data[3];\n  let scaleBefore = rowsSum != 0 || sx == sy;\n\n  // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n  if (data[4] || data[5]) {\n    transforms.push({\n      name: 'translate',\n      data: data.slice(4, data[5] ? 6 : 5),\n    });\n  }\n\n  // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n  if (!data[1] && data[2]) {\n    transforms.push({\n      name: 'skewX',\n      data: [mth.atan(data[2] / sy, floatPrecision)],\n    });\n\n    // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n  } else if (data[1] && !data[2]) {\n    transforms.push({\n      name: 'skewY',\n      data: [mth.atan(data[1] / data[0], floatPrecision)],\n    });\n    sx = data[0];\n    sy = data[3];\n\n    // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n  } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {\n    if (!scaleBefore) {\n      sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);\n      sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);\n      transforms.push({ name: 'scale', data: [sx, sy] });\n    }\n    var angle = Math.min(Math.max(-1, data[0] / sx), 1),\n      rotate = [\n        mth.acos(angle, floatPrecision) *\n          ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1),\n      ];\n\n    if (rotate[0]) transforms.push({ name: 'rotate', data: rotate });\n\n    if (rowsSum && colsSum)\n      transforms.push({\n        name: 'skewX',\n        data: [mth.atan(colsSum / (sx * sx), floatPrecision)],\n      });\n\n    // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n    if (rotate[0] && (data[4] || data[5])) {\n      transforms.shift();\n      var cos = data[0] / sx,\n        sin = data[1] / (scaleBefore ? sx : sy),\n        x = data[4] * (scaleBefore ? 1 : sy),\n        y = data[5] * (scaleBefore ? 1 : sx),\n        denom =\n          (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) *\n          (scaleBefore ? 1 : sx * sy);\n      rotate.push(((1 - cos) * x - sin * y) / denom);\n      rotate.push(((1 - cos) * y + sin * x) / denom);\n    }\n\n    // Too many transformations, return original matrix if it isn't just a scale/translate\n  } else if (data[1] || data[2]) {\n    return [transform];\n  }\n\n  if ((scaleBefore && (sx != 1 || sy != 1)) || !transforms.length)\n    transforms.push({\n      name: 'scale',\n      data: sx == sy ? [sx] : [sx, sy],\n    });\n\n  return transforms;\n};\n\n/**\n * Convert transform to the matrix data.\n *\n * @type {(transform: TransformItem) => Array<number> }\n */\nconst transformToMatrix = (transform) => {\n  if (transform.name === 'matrix') {\n    return transform.data;\n  }\n  switch (transform.name) {\n    case 'translate':\n      // [1, 0, 0, 1, tx, ty]\n      return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n    case 'scale':\n      // [sx, 0, 0, sy, 0, 0]\n      return [\n        transform.data[0],\n        0,\n        0,\n        transform.data[1] || transform.data[0],\n        0,\n        0,\n      ];\n    case 'rotate':\n      // [cos(a), sin(a), -sin(a), cos(a), x, y]\n      var cos = mth.cos(transform.data[0]),\n        sin = mth.sin(transform.data[0]),\n        cx = transform.data[1] || 0,\n        cy = transform.data[2] || 0;\n      return [\n        cos,\n        sin,\n        -sin,\n        cos,\n        (1 - cos) * cx + sin * cy,\n        (1 - cos) * cy - sin * cx,\n      ];\n    case 'skewX':\n      // [1, 0, tan(a), 1, 0, 0]\n      return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n    case 'skewY':\n      // [1, tan(a), 0, 1, 0, 0]\n      return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n    default:\n      throw Error(`Unknown transform ${transform.name}`);\n  }\n};\n\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @type {(\n *   cursor: [x: number, y: number],\n *   arc: Array<number>,\n *   transform: Array<number>\n * ) => Array<number>}\n */\nexports.transformArc = (cursor, arc, transform) => {\n  const x = arc[5] - cursor[0];\n  const y = arc[6] - cursor[1];\n  let a = arc[0];\n  let b = arc[1];\n  const rot = (arc[2] * Math.PI) / 180;\n  const cos = Math.cos(rot);\n  const sin = Math.sin(rot);\n  // skip if radius is 0\n  if (a > 0 && b > 0) {\n    let h =\n      Math.pow(x * cos + y * sin, 2) / (4 * a * a) +\n      Math.pow(y * cos - x * sin, 2) / (4 * b * b);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      a *= h;\n      b *= h;\n    }\n  }\n  const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];\n  const m = multiplyTransformMatrices(transform, ellipse);\n  // Decompose the new ellipse matrix\n  const lastCol = m[2] * m[2] + m[3] * m[3];\n  const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;\n  const root =\n    Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);\n\n  if (!root) {\n    // circle\n    arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n    arc[2] = 0;\n  } else {\n    const majorAxisSqr = (squareSum + root) / 2;\n    const minorAxisSqr = (squareSum - root) / 2;\n    const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;\n    const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;\n    const rowsSum = m[0] * m[2] + m[1] * m[3];\n    const term1 = m[0] * sub + m[2] * rowsSum;\n    const term2 = m[1] * sub + m[3] * rowsSum;\n    arc[0] = Math.sqrt(majorAxisSqr);\n    arc[1] = Math.sqrt(minorAxisSqr);\n    arc[2] =\n      (((major ? term2 < 0 : term1 > 0) ? -1 : 1) *\n        Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) *\n        180) /\n      Math.PI;\n  }\n\n  if (transform[0] < 0 !== transform[3] < 0) {\n    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically\n    arc[4] = 1 - arc[4];\n  }\n\n  return arc;\n};\n\n/**\n * Multiply transformation matrices.\n *\n * @type {(a: Array<number>, b: Array<number>) => Array<number>}\n */\nconst multiplyTransformMatrices = (a, b) => {\n  return [\n    a[0] * b[0] + a[2] * b[1],\n    a[1] * b[0] + a[3] * b[1],\n    a[0] * b[2] + a[2] * b[3],\n    a[1] * b[2] + a[3] * b[3],\n    a[0] * b[4] + a[2] * b[5] + a[4],\n    a[1] * b[4] + a[3] * b[5] + a[5],\n  ];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}