{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _pluginSyntaxNullishCoalescingOperator = require(\"@babel/plugin-syntax-nullish-coalescing-operator\");\nvar _core = require(\"@babel/core\");\nvar _default = (0, _helperPluginUtils.declare)((api, _ref) => {\n  let {\n    loose = false\n  } = _ref;\n  var _api$assumption;\n  api.assertVersion(7);\n  const noDocumentAll = (_api$assumption = api.assumption(\"noDocumentAll\")) != null ? _api$assumption : loose;\n  return {\n    name: \"transform-nullish-coalescing-operator\",\n    inherits: _pluginSyntaxNullishCoalescingOperator.default,\n    visitor: {\n      LogicalExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        if (node.operator !== \"??\") {\n          return;\n        }\n        let ref;\n        let assignment;\n        if (scope.isStatic(node.left)) {\n          ref = node.left;\n          assignment = _core.types.cloneNode(node.left);\n        } else if (scope.path.isPattern()) {\n          path.replaceWith(_core.template.statement.ast`(() => ${path.node})()`);\n          return;\n        } else {\n          ref = scope.generateUidIdentifierBasedOnNode(node.left);\n          scope.push({\n            id: _core.types.cloneNode(ref)\n          });\n          assignment = _core.types.assignmentExpression(\"=\", ref, node.left);\n        }\n        path.replaceWith(_core.types.conditionalExpression(noDocumentAll ? _core.types.binaryExpression(\"!=\", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression(\"&&\", _core.types.binaryExpression(\"!==\", assignment, _core.types.nullLiteral()), _core.types.binaryExpression(\"!==\", _core.types.cloneNode(ref), scope.buildUndefinedNode())), _core.types.cloneNode(ref), node.right));\n      }\n    }\n  };\n});\nexports.default = _default;","map":{"version":3,"names":["_helperPluginUtils","require","_pluginSyntaxNullishCoalescingOperator","_core","_default","declare","api","_ref","loose","_api$assumption","assertVersion","noDocumentAll","assumption","name","inherits","default","visitor","LogicalExpression","path","node","scope","operator","ref","assignment","isStatic","left","types","cloneNode","isPattern","replaceWith","template","statement","ast","generateUidIdentifierBasedOnNode","push","id","assignmentExpression","conditionalExpression","binaryExpression","nullLiteral","logicalExpression","buildUndefinedNode","right","exports"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@babel\\plugin-transform-nullish-coalescing-operator\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxNullishCoalescingOperator from \"@babel/plugin-syntax-nullish-coalescing-operator\";\nimport { types as t, template } from \"@babel/core\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, { loose = false }: Options) => {\n  api.assertVersion(7);\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? loose;\n\n  return {\n    name: \"transform-nullish-coalescing-operator\",\n    inherits: syntaxNullishCoalescingOperator.default,\n\n    visitor: {\n      LogicalExpression(path) {\n        const { node, scope } = path;\n        if (node.operator !== \"??\") {\n          return;\n        }\n\n        let ref;\n        let assignment;\n        // skip creating extra reference when `left` is static\n        if (scope.isStatic(node.left)) {\n          ref = node.left;\n          assignment = t.cloneNode(node.left);\n        } else if (scope.path.isPattern()) {\n          // Replace `function (a, x = a.b ?? c) {}` to `function (a, x = (() => a.b ?? c)() ){}`\n          // so the temporary variable can be injected in correct scope\n          path.replaceWith(template.statement.ast`(() => ${path.node})()`);\n          // The injected nullish expression will be queued and eventually transformed when visited\n          return;\n        } else {\n          ref = scope.generateUidIdentifierBasedOnNode(node.left);\n          scope.push({ id: t.cloneNode(ref) });\n          assignment = t.assignmentExpression(\"=\", ref, node.left);\n        }\n\n        path.replaceWith(\n          t.conditionalExpression(\n            // We cannot use `!= null` in spec mode because\n            // `document.all == null` and `document.all` is not \"nullish\".\n            noDocumentAll\n              ? t.binaryExpression(\"!=\", assignment, t.nullLiteral())\n              : t.logicalExpression(\n                  \"&&\",\n                  t.binaryExpression(\"!==\", assignment, t.nullLiteral()),\n                  t.binaryExpression(\n                    \"!==\",\n                    t.cloneNode(ref),\n                    scope.buildUndefinedNode(),\n                  ),\n                ),\n            t.cloneNode(ref),\n            node.right,\n          ),\n        );\n      },\n    },\n  };\n});\n"],"mappings":";;;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,sCAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAF,OAAA;AAAmD,IAAAG,QAAA,GAMpC,IAAAJ,kBAAA,CAAAK,OAAO,EAAC,CAACC,GAAG,EAAAC,IAAA,KAAiC;EAAA,IAA/B;IAAEC,KAAK,GAAG;EAAe,CAAC,GAAAD,IAAA;EAAK,IAAAE,eAAA;EAC1DH,GAAG,CAACI,aAAa,CAAC,CAAC,CAAC;EACpB,MAAMC,aAAa,IAAAF,eAAA,GAAGH,GAAG,CAACM,UAAU,CAAC,eAAe,CAAC,YAAAH,eAAA,GAAID,KAAK;EAE9D,OAAO;IACLK,IAAI,EAAE,uCAAuC;IAC7CC,QAAQ,EAAEZ,sCAA+B,CAACa,OAAO;IAEjDC,OAAO,EAAE;MACPC,iBAAiBA,CAACC,IAAI,EAAE;QACtB,MAAM;UAAEC,IAAI;UAAEC;QAAM,CAAC,GAAGF,IAAI;QAC5B,IAAIC,IAAI,CAACE,QAAQ,KAAK,IAAI,EAAE;UAC1B;QACF;QAEA,IAAIC,GAAG;QACP,IAAIC,UAAU;QAEd,IAAIH,KAAK,CAACI,QAAQ,CAACL,IAAI,CAACM,IAAI,CAAC,EAAE;UAC7BH,GAAG,GAAGH,IAAI,CAACM,IAAI;UACfF,UAAU,GAAGpB,KAAA,CAAAuB,KAAC,CAACC,SAAS,CAACR,IAAI,CAACM,IAAI,CAAC;QACrC,CAAC,MAAM,IAAIL,KAAK,CAACF,IAAI,CAACU,SAAS,CAAC,CAAC,EAAE;UAGjCV,IAAI,CAACW,WAAW,CAAC1B,KAAA,CAAA2B,QAAQ,CAACC,SAAS,CAACC,GAAI,UAASd,IAAI,CAACC,IAAK,KAAI,CAAC;UAEhE;QACF,CAAC,MAAM;UACLG,GAAG,GAAGF,KAAK,CAACa,gCAAgC,CAACd,IAAI,CAACM,IAAI,CAAC;UACvDL,KAAK,CAACc,IAAI,CAAC;YAAEC,EAAE,EAAEhC,KAAA,CAAAuB,KAAC,CAACC,SAAS,CAACL,GAAG;UAAE,CAAC,CAAC;UACpCC,UAAU,GAAGpB,KAAA,CAAAuB,KAAC,CAACU,oBAAoB,CAAC,GAAG,EAAEd,GAAG,EAAEH,IAAI,CAACM,IAAI,CAAC;QAC1D;QAEAP,IAAI,CAACW,WAAW,CACd1B,KAAA,CAAAuB,KAAC,CAACW,qBAAqB,CAGrB1B,aAAa,GACTR,KAAA,CAAAuB,KAAC,CAACY,gBAAgB,CAAC,IAAI,EAAEf,UAAU,EAAEpB,KAAA,CAAAuB,KAAC,CAACa,WAAW,CAAC,CAAC,CAAC,GACrDpC,KAAA,CAAAuB,KAAC,CAACc,iBAAiB,CACjB,IAAI,EACJrC,KAAA,CAAAuB,KAAC,CAACY,gBAAgB,CAAC,KAAK,EAAEf,UAAU,EAAEpB,KAAA,CAAAuB,KAAC,CAACa,WAAW,CAAC,CAAC,CAAC,EACtDpC,KAAA,CAAAuB,KAAC,CAACY,gBAAgB,CAChB,KAAK,EACLnC,KAAA,CAAAuB,KAAC,CAACC,SAAS,CAACL,GAAG,CAAC,EAChBF,KAAK,CAACqB,kBAAkB,CAAC,CAC3B,CACF,CAAC,EACLtC,KAAA,CAAAuB,KAAC,CAACC,SAAS,CAACL,GAAG,CAAC,EAChBH,IAAI,CAACuB,KACP,CACF,CAAC;MACH;IACF;EACF,CAAC;AACH,CAAC,CAAC;AAAAC,OAAA,CAAA5B,OAAA,GAAAX,QAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}