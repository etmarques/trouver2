{"ast":null,"code":"'use strict';\n\nvar core = require('@babel/core');\nconst positionMethod = {\n  start: \"unshiftContainer\",\n  end: \"pushContainer\"\n};\nconst addJSXAttribute = (_, opts) => {\n  function getAttributeValue(_ref) {\n    let {\n      literal,\n      value\n    } = _ref;\n    if (typeof value === \"boolean\") {\n      return core.types.jsxExpressionContainer(core.types.booleanLiteral(value));\n    }\n    if (typeof value === \"number\") {\n      return core.types.jsxExpressionContainer(core.types.numericLiteral(value));\n    }\n    if (typeof value === \"string\" && literal) {\n      return core.types.jsxExpressionContainer(core.template.ast(value).expression);\n    }\n    if (typeof value === \"string\") {\n      return core.types.stringLiteral(value);\n    }\n    return null;\n  }\n  function getAttribute(_ref2) {\n    let {\n      spread,\n      name,\n      value,\n      literal\n    } = _ref2;\n    if (spread) {\n      return core.types.jsxSpreadAttribute(core.types.identifier(name));\n    }\n    return core.types.jsxAttribute(core.types.jsxIdentifier(name), getAttributeValue({\n      value,\n      literal\n    }));\n  }\n  return {\n    visitor: {\n      JSXOpeningElement(path) {\n        if (!core.types.isJSXIdentifier(path.node.name)) return;\n        if (!opts.elements.includes(path.node.name.name)) return;\n        opts.attributes.forEach(_ref3 => {\n          let {\n            name,\n            value = null,\n            spread = false,\n            literal = false,\n            position = \"end\"\n          } = _ref3;\n          const method = positionMethod[position];\n          const newAttribute = getAttribute({\n            spread,\n            name,\n            value,\n            literal\n          });\n          const attributes = path.get(\"attributes\");\n          const isEqualAttribute = attribute => {\n            if (spread) return attribute.isJSXSpreadAttribute() && attribute.get(\"argument\").isIdentifier({\n              name\n            });\n            return attribute.isJSXAttribute() && attribute.get(\"name\").isJSXIdentifier({\n              name\n            });\n          };\n          const replaced = attributes.some(attribute => {\n            if (!isEqualAttribute(attribute)) return false;\n            attribute.replaceWith(newAttribute);\n            return true;\n          });\n          if (!replaced) {\n            path[method](\"attributes\", newAttribute);\n          }\n        });\n      }\n    }\n  };\n};\nmodule.exports = addJSXAttribute;","map":{"version":3,"names":["positionMethod","start","end","addJSXAttribute","_","opts","getAttributeValue","_ref","literal","value","core","types","jsxExpressionContainer","booleanLiteral","numericLiteral","template","ast","expression","stringLiteral","getAttribute","_ref2","spread","name","jsxSpreadAttribute","identifier","jsxAttribute","jsxIdentifier","visitor","JSXOpeningElement","path","isJSXIdentifier","node","elements","includes","attributes","forEach","_ref3","position","method","newAttribute","get","isEqualAttribute","attribute","isJSXSpreadAttribute","isIdentifier","isJSXAttribute","replaced","some","replaceWith"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@svgr\\babel-plugin-add-jsx-attribute\\src\\index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { ConfigAPI, types as t, NodePath, template } from '@babel/core'\n\nexport interface Attribute {\n  name: string\n  value?: boolean | number | string | null\n  spread?: boolean\n  literal?: boolean\n  position?: 'start' | 'end'\n}\n\nexport interface Options {\n  elements: string[]\n  attributes: Attribute[]\n}\n\nconst positionMethod = {\n  start: 'unshiftContainer',\n  end: 'pushContainer',\n} as const\n\nconst addJSXAttribute = (_: ConfigAPI, opts: Options) => {\n  function getAttributeValue({\n    literal,\n    value,\n  }: {\n    literal?: Attribute['literal']\n    value: Attribute['value']\n  }) {\n    if (typeof value === 'boolean') {\n      return t.jsxExpressionContainer(t.booleanLiteral(value))\n    }\n\n    if (typeof value === 'number') {\n      return t.jsxExpressionContainer(t.numericLiteral(value))\n    }\n\n    if (typeof value === 'string' && literal) {\n      return t.jsxExpressionContainer(\n        (template.ast(value) as t.ExpressionStatement).expression,\n      )\n    }\n\n    if (typeof value === 'string') {\n      return t.stringLiteral(value)\n    }\n\n    return null\n  }\n\n  function getAttribute({ spread, name, value, literal }: Attribute) {\n    if (spread) {\n      return t.jsxSpreadAttribute(t.identifier(name))\n    }\n\n    return t.jsxAttribute(\n      t.jsxIdentifier(name),\n      getAttributeValue({ value, literal }),\n    )\n  }\n\n  return {\n    visitor: {\n      JSXOpeningElement(path: NodePath<t.JSXOpeningElement>) {\n        if (!t.isJSXIdentifier(path.node.name)) return\n        if (!opts.elements.includes(path.node.name.name)) return\n\n        opts.attributes.forEach(\n          ({\n            name,\n            value = null,\n            spread = false,\n            literal = false,\n            position = 'end',\n          }) => {\n            const method = positionMethod[position]\n            const newAttribute = getAttribute({ spread, name, value, literal })\n            const attributes = path.get('attributes')\n\n            const isEqualAttribute = (\n              attribute: NodePath<t.JSXSpreadAttribute | t.JSXAttribute>,\n            ) => {\n              if (spread)\n                return (\n                  attribute.isJSXSpreadAttribute() &&\n                  attribute.get('argument').isIdentifier({ name })\n                )\n              return (\n                attribute.isJSXAttribute() &&\n                attribute.get('name').isJSXIdentifier({ name })\n              )\n            }\n\n            const replaced = attributes.some((attribute) => {\n              if (!isEqualAttribute(attribute)) return false\n              attribute.replaceWith(newAttribute)\n              return true\n            })\n\n            if (!replaced) {\n              path[method]('attributes', newAttribute)\n            }\n          },\n        )\n      },\n    },\n  }\n}\n\nexport default addJSXAttribute\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}