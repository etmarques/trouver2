{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('css-tree').Rule} CsstreeRule\n * @typedef {import('./types').Specificity} Specificity\n * @typedef {import('./types').Stylesheet} Stylesheet\n * @typedef {import('./types').StylesheetRule} StylesheetRule\n * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration\n * @typedef {import('./types').ComputedStyles} ComputedStyles\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\nconst csstree = require('css-tree');\nconst {\n  // @ts-ignore not defined in @types/csso\n  syntax: {\n    specificity\n  }\n} = require('csso');\nconst {\n  visit,\n  matches\n} = require('./xast.js');\nconst {\n  attrsGroups,\n  inheritableAttrs,\n  presentationNonInheritableGroupAttrs\n} = require('../plugins/_collections.js');\n\n// @ts-ignore not defined in @types/csstree\nconst csstreeWalkSkip = csstree.walk.skip;\n\n/**\n * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule[]}\n */\nconst parseRule = (ruleNode, dynamic) => {\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  // collect declarations\n  ruleNode.block.children.forEach(cssNode => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true\n      });\n    }\n  });\n\n  /**\n   * @type {StylesheetRule[]}\n   */\n  const rules = [];\n  csstree.walk(ruleNode.prelude, node => {\n    if (node.type === 'Selector') {\n      const newNode = csstree.clone(node);\n      let hasPseudoClasses = false;\n      csstree.walk(newNode, (pseudoClassNode, item, list) => {\n        if (pseudoClassNode.type === 'PseudoClassSelector') {\n          hasPseudoClasses = true;\n          list.remove(item);\n        }\n      });\n      rules.push({\n        specificity: specificity(node),\n        dynamic: hasPseudoClasses || dynamic,\n        // compute specificity from original node to consider pseudo classes\n        selector: csstree.generate(newNode),\n        declarations\n      });\n    }\n  });\n  return rules;\n};\n\n/**\n * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>}\n */\nconst parseStylesheet = (css, dynamic) => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  const ast = csstree.parse(css, {\n    parseValue: false,\n    parseAtrulePrelude: false\n  });\n  csstree.walk(ast, cssNode => {\n    if (cssNode.type === 'Rule') {\n      rules.push(...parseRule(cssNode, dynamic || false));\n      return csstreeWalkSkip;\n    }\n    if (cssNode.type === 'Atrule') {\n      if (cssNode.name === 'keyframes') {\n        return csstreeWalkSkip;\n      }\n      csstree.walk(cssNode, ruleNode => {\n        if (ruleNode.type === 'Rule') {\n          rules.push(...parseRule(ruleNode, dynamic || true));\n          return csstreeWalkSkip;\n        }\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  return rules;\n};\n\n/**\n * @type {(css: string) => Array<StylesheetDeclaration>}\n */\nconst parseStyleDeclarations = css => {\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  const ast = csstree.parse(css, {\n    context: 'declarationList',\n    parseValue: false\n  });\n  csstree.walk(ast, cssNode => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true\n      });\n    }\n  });\n  return declarations;\n};\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeOwnStyle = (stylesheet, node) => {\n  /**\n   * @type {ComputedStyles}\n   */\n  const computedStyle = {};\n  const importantStyles = new Map();\n\n  // collect attributes\n  for (const [name, value] of Object.entries(node.attributes)) {\n    if (attrsGroups.presentation.includes(name)) {\n      computedStyle[name] = {\n        type: 'static',\n        inherited: false,\n        value\n      };\n      importantStyles.set(name, false);\n    }\n  }\n\n  // collect matching rules\n  for (const {\n    selector,\n    declarations,\n    dynamic\n  } of stylesheet.rules) {\n    if (matches(node, selector)) {\n      for (const {\n        name,\n        value,\n        important\n      } of declarations) {\n        const computed = computedStyle[name];\n        if (computed && computed.type === 'dynamic') {\n          continue;\n        }\n        if (dynamic) {\n          computedStyle[name] = {\n            type: 'dynamic',\n            inherited: false\n          };\n          continue;\n        }\n        if (computed == null || important === true || importantStyles.get(name) === false) {\n          computedStyle[name] = {\n            type: 'static',\n            inherited: false,\n            value\n          };\n          importantStyles.set(name, important);\n        }\n      }\n    }\n  }\n\n  // collect inline styles\n  const styleDeclarations = node.attributes.style == null ? [] : parseStyleDeclarations(node.attributes.style);\n  for (const {\n    name,\n    value,\n    important\n  } of styleDeclarations) {\n    const computed = computedStyle[name];\n    if (computed && computed.type === 'dynamic') {\n      continue;\n    }\n    if (computed == null || important === true || importantStyles.get(name) === false) {\n      computedStyle[name] = {\n        type: 'static',\n        inherited: false,\n        value\n      };\n      importantStyles.set(name, important);\n    }\n  }\n  return computedStyle;\n};\n\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/main/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\nconst compareSpecificity = (a, b) => {\n  for (let i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n  return 0;\n};\n\n/**\n * @type {(root: XastRoot) => Stylesheet}\n */\nconst collectStylesheet = root => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n  const parents = new Map();\n  visit(root, {\n    element: {\n      enter: (node, parentNode) => {\n        // store parents\n        parents.set(node, parentNode);\n        // find and parse all styles\n        if (node.name === 'style') {\n          const dynamic = node.attributes.media != null && node.attributes.media !== 'all';\n          if (node.attributes.type == null || node.attributes.type === '' || node.attributes.type === 'text/css') {\n            const children = node.children;\n            for (const child of children) {\n              if (child.type === 'text' || child.type === 'cdata') {\n                rules.push(...parseStylesheet(child.value, dynamic));\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n  // sort by selectors specificity\n  rules.sort((a, b) => compareSpecificity(a.specificity, b.specificity));\n  return {\n    rules,\n    parents\n  };\n};\nexports.collectStylesheet = collectStylesheet;\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeStyle = (stylesheet, node) => {\n  const {\n    parents\n  } = stylesheet;\n  // collect inherited styles\n  const computedStyles = computeOwnStyle(stylesheet, node);\n  let parent = parents.get(node);\n  while (parent != null && parent.type !== 'root') {\n    const inheritedStyles = computeOwnStyle(stylesheet, parent);\n    for (const [name, computed] of Object.entries(inheritedStyles)) {\n      if (computedStyles[name] == null &&\n      // ignore not inheritable styles\n      inheritableAttrs.includes(name) === true && presentationNonInheritableGroupAttrs.includes(name) === false) {\n        computedStyles[name] = {\n          ...computed,\n          inherited: true\n        };\n      }\n    }\n    parent = parents.get(parent);\n  }\n  return computedStyles;\n};\nexports.computeStyle = computeStyle;","map":{"version":3,"names":["csstree","require","syntax","specificity","visit","matches","attrsGroups","inheritableAttrs","presentationNonInheritableGroupAttrs","csstreeWalkSkip","walk","skip","parseRule","ruleNode","dynamic","declarations","block","children","forEach","cssNode","type","push","name","property","value","generate","important","rules","prelude","node","newNode","clone","hasPseudoClasses","pseudoClassNode","item","list","remove","selector","parseStylesheet","css","ast","parse","parseValue","parseAtrulePrelude","parseStyleDeclarations","context","computeOwnStyle","stylesheet","computedStyle","importantStyles","Map","Object","entries","attributes","presentation","includes","inherited","set","computed","get","styleDeclarations","style","compareSpecificity","a","b","i","collectStylesheet","root","parents","element","enter","parentNode","media","child","sort","exports","computeStyle","computedStyles","parent","inheritedStyles"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/lib/style.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('css-tree').Rule} CsstreeRule\n * @typedef {import('./types').Specificity} Specificity\n * @typedef {import('./types').Stylesheet} Stylesheet\n * @typedef {import('./types').StylesheetRule} StylesheetRule\n * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration\n * @typedef {import('./types').ComputedStyles} ComputedStyles\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\nconst csstree = require('css-tree');\nconst {\n  // @ts-ignore not defined in @types/csso\n  syntax: { specificity },\n} = require('csso');\nconst { visit, matches } = require('./xast.js');\nconst {\n  attrsGroups,\n  inheritableAttrs,\n  presentationNonInheritableGroupAttrs,\n} = require('../plugins/_collections.js');\n\n// @ts-ignore not defined in @types/csstree\nconst csstreeWalkSkip = csstree.walk.skip;\n\n/**\n * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule[]}\n */\nconst parseRule = (ruleNode, dynamic) => {\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  // collect declarations\n  ruleNode.block.children.forEach((cssNode) => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true,\n      });\n    }\n  });\n\n  /**\n   * @type {StylesheetRule[]}\n   */\n  const rules = [];\n  csstree.walk(ruleNode.prelude, (node) => {\n    if (node.type === 'Selector') {\n      const newNode = csstree.clone(node);\n      let hasPseudoClasses = false;\n      csstree.walk(newNode, (pseudoClassNode, item, list) => {\n        if (pseudoClassNode.type === 'PseudoClassSelector') {\n          hasPseudoClasses = true;\n          list.remove(item);\n        }\n      });\n      rules.push({\n        specificity: specificity(node),\n        dynamic: hasPseudoClasses || dynamic,\n        // compute specificity from original node to consider pseudo classes\n        selector: csstree.generate(newNode),\n        declarations,\n      });\n    }\n  });\n\n  return rules;\n};\n\n/**\n * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>}\n */\nconst parseStylesheet = (css, dynamic) => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  const ast = csstree.parse(css, {\n    parseValue: false,\n    parseAtrulePrelude: false,\n  });\n  csstree.walk(ast, (cssNode) => {\n    if (cssNode.type === 'Rule') {\n      rules.push(...parseRule(cssNode, dynamic || false));\n      return csstreeWalkSkip;\n    }\n    if (cssNode.type === 'Atrule') {\n      if (cssNode.name === 'keyframes') {\n        return csstreeWalkSkip;\n      }\n      csstree.walk(cssNode, (ruleNode) => {\n        if (ruleNode.type === 'Rule') {\n          rules.push(...parseRule(ruleNode, dynamic || true));\n          return csstreeWalkSkip;\n        }\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  return rules;\n};\n\n/**\n * @type {(css: string) => Array<StylesheetDeclaration>}\n */\nconst parseStyleDeclarations = (css) => {\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  const ast = csstree.parse(css, {\n    context: 'declarationList',\n    parseValue: false,\n  });\n  csstree.walk(ast, (cssNode) => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true,\n      });\n    }\n  });\n  return declarations;\n};\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeOwnStyle = (stylesheet, node) => {\n  /**\n   * @type {ComputedStyles}\n   */\n  const computedStyle = {};\n  const importantStyles = new Map();\n\n  // collect attributes\n  for (const [name, value] of Object.entries(node.attributes)) {\n    if (attrsGroups.presentation.includes(name)) {\n      computedStyle[name] = { type: 'static', inherited: false, value };\n      importantStyles.set(name, false);\n    }\n  }\n\n  // collect matching rules\n  for (const { selector, declarations, dynamic } of stylesheet.rules) {\n    if (matches(node, selector)) {\n      for (const { name, value, important } of declarations) {\n        const computed = computedStyle[name];\n        if (computed && computed.type === 'dynamic') {\n          continue;\n        }\n        if (dynamic) {\n          computedStyle[name] = { type: 'dynamic', inherited: false };\n          continue;\n        }\n        if (\n          computed == null ||\n          important === true ||\n          importantStyles.get(name) === false\n        ) {\n          computedStyle[name] = { type: 'static', inherited: false, value };\n          importantStyles.set(name, important);\n        }\n      }\n    }\n  }\n\n  // collect inline styles\n  const styleDeclarations =\n    node.attributes.style == null\n      ? []\n      : parseStyleDeclarations(node.attributes.style);\n  for (const { name, value, important } of styleDeclarations) {\n    const computed = computedStyle[name];\n    if (computed && computed.type === 'dynamic') {\n      continue;\n    }\n    if (\n      computed == null ||\n      important === true ||\n      importantStyles.get(name) === false\n    ) {\n      computedStyle[name] = { type: 'static', inherited: false, value };\n      importantStyles.set(name, important);\n    }\n  }\n\n  return computedStyle;\n};\n\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/main/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\nconst compareSpecificity = (a, b) => {\n  for (let i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n\n/**\n * @type {(root: XastRoot) => Stylesheet}\n */\nconst collectStylesheet = (root) => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n  const parents = new Map();\n  visit(root, {\n    element: {\n      enter: (node, parentNode) => {\n        // store parents\n        parents.set(node, parentNode);\n        // find and parse all styles\n        if (node.name === 'style') {\n          const dynamic =\n            node.attributes.media != null && node.attributes.media !== 'all';\n          if (\n            node.attributes.type == null ||\n            node.attributes.type === '' ||\n            node.attributes.type === 'text/css'\n          ) {\n            const children = node.children;\n            for (const child of children) {\n              if (child.type === 'text' || child.type === 'cdata') {\n                rules.push(...parseStylesheet(child.value, dynamic));\n              }\n            }\n          }\n        }\n      },\n    },\n  });\n  // sort by selectors specificity\n  rules.sort((a, b) => compareSpecificity(a.specificity, b.specificity));\n  return { rules, parents };\n};\nexports.collectStylesheet = collectStylesheet;\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeStyle = (stylesheet, node) => {\n  const { parents } = stylesheet;\n  // collect inherited styles\n  const computedStyles = computeOwnStyle(stylesheet, node);\n  let parent = parents.get(node);\n  while (parent != null && parent.type !== 'root') {\n    const inheritedStyles = computeOwnStyle(stylesheet, parent);\n    for (const [name, computed] of Object.entries(inheritedStyles)) {\n      if (\n        computedStyles[name] == null &&\n        // ignore not inheritable styles\n        inheritableAttrs.includes(name) === true &&\n        presentationNonInheritableGroupAttrs.includes(name) === false\n      ) {\n        computedStyles[name] = { ...computed, inherited: true };\n      }\n    }\n    parent = parents.get(parent);\n  }\n  return computedStyles;\n};\nexports.computeStyle = computeStyle;\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAU,CAAC;AACnC,MAAM;EACJ;EACAC,MAAM,EAAE;IAAEC;EAAY;AACxB,CAAC,GAAGF,OAAO,CAAC,MAAM,CAAC;AACnB,MAAM;EAAEG,KAAK;EAAEC;AAAQ,CAAC,GAAGJ,OAAO,CAAC,WAAW,CAAC;AAC/C,MAAM;EACJK,WAAW;EACXC,gBAAgB;EAChBC;AACF,CAAC,GAAGP,OAAO,CAAC,4BAA4B,CAAC;;AAEzC;AACA,MAAMQ,eAAe,GAAGT,OAAO,CAACU,IAAI,CAACC,IAAI;;AAEzC;AACA;AACA;AACA,MAAMC,SAAS,GAAGA,CAACC,QAAQ,EAAEC,OAAO,KAAK;EACvC;AACF;AACA;EACE,MAAMC,YAAY,GAAG,EAAE;EACvB;EACAF,QAAQ,CAACG,KAAK,CAACC,QAAQ,CAACC,OAAO,CAAEC,OAAO,IAAK;IAC3C,IAAIA,OAAO,CAACC,IAAI,KAAK,aAAa,EAAE;MAClCL,YAAY,CAACM,IAAI,CAAC;QAChBC,IAAI,EAAEH,OAAO,CAACI,QAAQ;QACtBC,KAAK,EAAExB,OAAO,CAACyB,QAAQ,CAACN,OAAO,CAACK,KAAK,CAAC;QACtCE,SAAS,EAAEP,OAAO,CAACO,SAAS,KAAK;MACnC,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;;EAEF;AACF;AACA;EACE,MAAMC,KAAK,GAAG,EAAE;EAChB3B,OAAO,CAACU,IAAI,CAACG,QAAQ,CAACe,OAAO,EAAGC,IAAI,IAAK;IACvC,IAAIA,IAAI,CAACT,IAAI,KAAK,UAAU,EAAE;MAC5B,MAAMU,OAAO,GAAG9B,OAAO,CAAC+B,KAAK,CAACF,IAAI,CAAC;MACnC,IAAIG,gBAAgB,GAAG,KAAK;MAC5BhC,OAAO,CAACU,IAAI,CAACoB,OAAO,EAAE,CAACG,eAAe,EAAEC,IAAI,EAAEC,IAAI,KAAK;QACrD,IAAIF,eAAe,CAACb,IAAI,KAAK,qBAAqB,EAAE;UAClDY,gBAAgB,GAAG,IAAI;UACvBG,IAAI,CAACC,MAAM,CAACF,IAAI,CAAC;QACnB;MACF,CAAC,CAAC;MACFP,KAAK,CAACN,IAAI,CAAC;QACTlB,WAAW,EAAEA,WAAW,CAAC0B,IAAI,CAAC;QAC9Bf,OAAO,EAAEkB,gBAAgB,IAAIlB,OAAO;QACpC;QACAuB,QAAQ,EAAErC,OAAO,CAACyB,QAAQ,CAACK,OAAO,CAAC;QACnCf;MACF,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EAEF,OAAOY,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA,MAAMW,eAAe,GAAGA,CAACC,GAAG,EAAEzB,OAAO,KAAK;EACxC;AACF;AACA;EACE,MAAMa,KAAK,GAAG,EAAE;EAChB,MAAMa,GAAG,GAAGxC,OAAO,CAACyC,KAAK,CAACF,GAAG,EAAE;IAC7BG,UAAU,EAAE,KAAK;IACjBC,kBAAkB,EAAE;EACtB,CAAC,CAAC;EACF3C,OAAO,CAACU,IAAI,CAAC8B,GAAG,EAAGrB,OAAO,IAAK;IAC7B,IAAIA,OAAO,CAACC,IAAI,KAAK,MAAM,EAAE;MAC3BO,KAAK,CAACN,IAAI,CAAC,GAAGT,SAAS,CAACO,OAAO,EAAEL,OAAO,IAAI,KAAK,CAAC,CAAC;MACnD,OAAOL,eAAe;IACxB;IACA,IAAIU,OAAO,CAACC,IAAI,KAAK,QAAQ,EAAE;MAC7B,IAAID,OAAO,CAACG,IAAI,KAAK,WAAW,EAAE;QAChC,OAAOb,eAAe;MACxB;MACAT,OAAO,CAACU,IAAI,CAACS,OAAO,EAAGN,QAAQ,IAAK;QAClC,IAAIA,QAAQ,CAACO,IAAI,KAAK,MAAM,EAAE;UAC5BO,KAAK,CAACN,IAAI,CAAC,GAAGT,SAAS,CAACC,QAAQ,EAAEC,OAAO,IAAI,IAAI,CAAC,CAAC;UACnD,OAAOL,eAAe;QACxB;MACF,CAAC,CAAC;MACF,OAAOA,eAAe;IACxB;EACF,CAAC,CAAC;EACF,OAAOkB,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA,MAAMiB,sBAAsB,GAAIL,GAAG,IAAK;EACtC;AACF;AACA;EACE,MAAMxB,YAAY,GAAG,EAAE;EACvB,MAAMyB,GAAG,GAAGxC,OAAO,CAACyC,KAAK,CAACF,GAAG,EAAE;IAC7BM,OAAO,EAAE,iBAAiB;IAC1BH,UAAU,EAAE;EACd,CAAC,CAAC;EACF1C,OAAO,CAACU,IAAI,CAAC8B,GAAG,EAAGrB,OAAO,IAAK;IAC7B,IAAIA,OAAO,CAACC,IAAI,KAAK,aAAa,EAAE;MAClCL,YAAY,CAACM,IAAI,CAAC;QAChBC,IAAI,EAAEH,OAAO,CAACI,QAAQ;QACtBC,KAAK,EAAExB,OAAO,CAACyB,QAAQ,CAACN,OAAO,CAACK,KAAK,CAAC;QACtCE,SAAS,EAAEP,OAAO,CAACO,SAAS,KAAK;MACnC,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EACF,OAAOX,YAAY;AACrB,CAAC;;AAED;AACA;AACA;AACA,MAAM+B,eAAe,GAAGA,CAACC,UAAU,EAAElB,IAAI,KAAK;EAC5C;AACF;AACA;EACE,MAAMmB,aAAa,GAAG,CAAC,CAAC;EACxB,MAAMC,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;;EAEjC;EACA,KAAK,MAAM,CAAC5B,IAAI,EAAEE,KAAK,CAAC,IAAI2B,MAAM,CAACC,OAAO,CAACvB,IAAI,CAACwB,UAAU,CAAC,EAAE;IAC3D,IAAI/C,WAAW,CAACgD,YAAY,CAACC,QAAQ,CAACjC,IAAI,CAAC,EAAE;MAC3C0B,aAAa,CAAC1B,IAAI,CAAC,GAAG;QAAEF,IAAI,EAAE,QAAQ;QAAEoC,SAAS,EAAE,KAAK;QAAEhC;MAAM,CAAC;MACjEyB,eAAe,CAACQ,GAAG,CAACnC,IAAI,EAAE,KAAK,CAAC;IAClC;EACF;;EAEA;EACA,KAAK,MAAM;IAAEe,QAAQ;IAAEtB,YAAY;IAAED;EAAQ,CAAC,IAAIiC,UAAU,CAACpB,KAAK,EAAE;IAClE,IAAItB,OAAO,CAACwB,IAAI,EAAEQ,QAAQ,CAAC,EAAE;MAC3B,KAAK,MAAM;QAAEf,IAAI;QAAEE,KAAK;QAAEE;MAAU,CAAC,IAAIX,YAAY,EAAE;QACrD,MAAM2C,QAAQ,GAAGV,aAAa,CAAC1B,IAAI,CAAC;QACpC,IAAIoC,QAAQ,IAAIA,QAAQ,CAACtC,IAAI,KAAK,SAAS,EAAE;UAC3C;QACF;QACA,IAAIN,OAAO,EAAE;UACXkC,aAAa,CAAC1B,IAAI,CAAC,GAAG;YAAEF,IAAI,EAAE,SAAS;YAAEoC,SAAS,EAAE;UAAM,CAAC;UAC3D;QACF;QACA,IACEE,QAAQ,IAAI,IAAI,IAChBhC,SAAS,KAAK,IAAI,IAClBuB,eAAe,CAACU,GAAG,CAACrC,IAAI,CAAC,KAAK,KAAK,EACnC;UACA0B,aAAa,CAAC1B,IAAI,CAAC,GAAG;YAAEF,IAAI,EAAE,QAAQ;YAAEoC,SAAS,EAAE,KAAK;YAAEhC;UAAM,CAAC;UACjEyB,eAAe,CAACQ,GAAG,CAACnC,IAAI,EAAEI,SAAS,CAAC;QACtC;MACF;IACF;EACF;;EAEA;EACA,MAAMkC,iBAAiB,GACrB/B,IAAI,CAACwB,UAAU,CAACQ,KAAK,IAAI,IAAI,GACzB,EAAE,GACFjB,sBAAsB,CAACf,IAAI,CAACwB,UAAU,CAACQ,KAAK,CAAC;EACnD,KAAK,MAAM;IAAEvC,IAAI;IAAEE,KAAK;IAAEE;EAAU,CAAC,IAAIkC,iBAAiB,EAAE;IAC1D,MAAMF,QAAQ,GAAGV,aAAa,CAAC1B,IAAI,CAAC;IACpC,IAAIoC,QAAQ,IAAIA,QAAQ,CAACtC,IAAI,KAAK,SAAS,EAAE;MAC3C;IACF;IACA,IACEsC,QAAQ,IAAI,IAAI,IAChBhC,SAAS,KAAK,IAAI,IAClBuB,eAAe,CAACU,GAAG,CAACrC,IAAI,CAAC,KAAK,KAAK,EACnC;MACA0B,aAAa,CAAC1B,IAAI,CAAC,GAAG;QAAEF,IAAI,EAAE,QAAQ;QAAEoC,SAAS,EAAE,KAAK;QAAEhC;MAAM,CAAC;MACjEyB,eAAe,CAACQ,GAAG,CAACnC,IAAI,EAAEI,SAAS,CAAC;IACtC;EACF;EAEA,OAAOsB,aAAa;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMc,kBAAkB,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;EACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC7B,IAAIF,CAAC,CAACE,CAAC,CAAC,GAAGD,CAAC,CAACC,CAAC,CAAC,EAAE;MACf,OAAO,CAAC,CAAC;IACX,CAAC,MAAM,IAAIF,CAAC,CAACE,CAAC,CAAC,GAAGD,CAAC,CAACC,CAAC,CAAC,EAAE;MACtB,OAAO,CAAC;IACV;EACF;EAEA,OAAO,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA,MAAMC,iBAAiB,GAAIC,IAAI,IAAK;EAClC;AACF;AACA;EACE,MAAMxC,KAAK,GAAG,EAAE;EAChB;AACF;AACA;EACE,MAAMyC,OAAO,GAAG,IAAIlB,GAAG,CAAC,CAAC;EACzB9C,KAAK,CAAC+D,IAAI,EAAE;IACVE,OAAO,EAAE;MACPC,KAAK,EAAEA,CAACzC,IAAI,EAAE0C,UAAU,KAAK;QAC3B;QACAH,OAAO,CAACX,GAAG,CAAC5B,IAAI,EAAE0C,UAAU,CAAC;QAC7B;QACA,IAAI1C,IAAI,CAACP,IAAI,KAAK,OAAO,EAAE;UACzB,MAAMR,OAAO,GACXe,IAAI,CAACwB,UAAU,CAACmB,KAAK,IAAI,IAAI,IAAI3C,IAAI,CAACwB,UAAU,CAACmB,KAAK,KAAK,KAAK;UAClE,IACE3C,IAAI,CAACwB,UAAU,CAACjC,IAAI,IAAI,IAAI,IAC5BS,IAAI,CAACwB,UAAU,CAACjC,IAAI,KAAK,EAAE,IAC3BS,IAAI,CAACwB,UAAU,CAACjC,IAAI,KAAK,UAAU,EACnC;YACA,MAAMH,QAAQ,GAAGY,IAAI,CAACZ,QAAQ;YAC9B,KAAK,MAAMwD,KAAK,IAAIxD,QAAQ,EAAE;cAC5B,IAAIwD,KAAK,CAACrD,IAAI,KAAK,MAAM,IAAIqD,KAAK,CAACrD,IAAI,KAAK,OAAO,EAAE;gBACnDO,KAAK,CAACN,IAAI,CAAC,GAAGiB,eAAe,CAACmC,KAAK,CAACjD,KAAK,EAAEV,OAAO,CAAC,CAAC;cACtD;YACF;UACF;QACF;MACF;IACF;EACF,CAAC,CAAC;EACF;EACAa,KAAK,CAAC+C,IAAI,CAAC,CAACX,CAAC,EAAEC,CAAC,KAAKF,kBAAkB,CAACC,CAAC,CAAC5D,WAAW,EAAE6D,CAAC,CAAC7D,WAAW,CAAC,CAAC;EACtE,OAAO;IAAEwB,KAAK;IAAEyC;EAAQ,CAAC;AAC3B,CAAC;AACDO,OAAO,CAACT,iBAAiB,GAAGA,iBAAiB;;AAE7C;AACA;AACA;AACA,MAAMU,YAAY,GAAGA,CAAC7B,UAAU,EAAElB,IAAI,KAAK;EACzC,MAAM;IAAEuC;EAAQ,CAAC,GAAGrB,UAAU;EAC9B;EACA,MAAM8B,cAAc,GAAG/B,eAAe,CAACC,UAAU,EAAElB,IAAI,CAAC;EACxD,IAAIiD,MAAM,GAAGV,OAAO,CAACT,GAAG,CAAC9B,IAAI,CAAC;EAC9B,OAAOiD,MAAM,IAAI,IAAI,IAAIA,MAAM,CAAC1D,IAAI,KAAK,MAAM,EAAE;IAC/C,MAAM2D,eAAe,GAAGjC,eAAe,CAACC,UAAU,EAAE+B,MAAM,CAAC;IAC3D,KAAK,MAAM,CAACxD,IAAI,EAAEoC,QAAQ,CAAC,IAAIP,MAAM,CAACC,OAAO,CAAC2B,eAAe,CAAC,EAAE;MAC9D,IACEF,cAAc,CAACvD,IAAI,CAAC,IAAI,IAAI;MAC5B;MACAf,gBAAgB,CAACgD,QAAQ,CAACjC,IAAI,CAAC,KAAK,IAAI,IACxCd,oCAAoC,CAAC+C,QAAQ,CAACjC,IAAI,CAAC,KAAK,KAAK,EAC7D;QACAuD,cAAc,CAACvD,IAAI,CAAC,GAAG;UAAE,GAAGoC,QAAQ;UAAEF,SAAS,EAAE;QAAK,CAAC;MACzD;IACF;IACAsB,MAAM,GAAGV,OAAO,CAACT,GAAG,CAACmB,MAAM,CAAC;EAC9B;EACA,OAAOD,cAAc;AACvB,CAAC;AACDF,OAAO,CAACC,YAAY,GAAGA,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}