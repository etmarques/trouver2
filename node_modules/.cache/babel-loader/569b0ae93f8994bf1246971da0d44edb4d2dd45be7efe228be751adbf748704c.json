{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib//types').PathDataItem} PathDataItem\n */\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\nconst {\n  visit\n} = require('../lib/xast.js');\nconst {\n  pathElems\n} = require('./_collections.js');\nconst {\n  path2js,\n  js2path\n} = require('./_path.js');\nconst {\n  applyTransforms\n} = require('./applyTransforms.js');\nconst {\n  cleanupOutData\n} = require('../lib/svgo/tools');\nexports.name = 'convertPathData';\nexports.description = 'optimizes path data: writes in shorter form, applies transformations';\n\n/**\n * @type {(data: number[]) => number[]}\n */\nlet roundData;\n/**\n * @type {number | false}\n */\nlet precision;\n/**\n * @type {number}\n */\nlet error;\n/**\n * @type {number}\n */\nlet arcThreshold;\n/**\n * @type {number}\n */\nlet arcTolerance;\n\n/**\n * @typedef {{\n *   applyTransforms: boolean,\n *   applyTransformsStroked: boolean,\n *   makeArcs: {\n *     threshold: number,\n *     tolerance: number,\n *   },\n *   straightCurves: boolean,\n *   lineShorthands: boolean,\n *   curveSmoothShorthands: boolean,\n *   floatPrecision: number | false,\n *   transformPrecision: number,\n *   removeUseless: boolean,\n *   collapseRepeated: boolean,\n *   utilizeAbsolute: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n *   noSpaceAfterFlags: boolean,\n *   forceAbsolutePath: boolean,\n * }} InternalParams\n */\n\n/**\n * @typedef {[number, number]} Point\n */\n\n/**\n * @typedef {{\n *   center: Point,\n *   radius: number\n * }} Circle\n */\n\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see https://www.w3.org/TR/SVG11/paths.html#PathData\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'convertPathData'>}\n */\nexports.fn = (root, params) => {\n  const {\n    // TODO convert to separate plugin in v3\n    applyTransforms: _applyTransforms = true,\n    applyTransformsStroked = true,\n    makeArcs = {\n      threshold: 2.5,\n      // coefficient of rounding error\n      tolerance: 0.5 // percentage of radius\n    },\n\n    straightCurves = true,\n    lineShorthands = true,\n    curveSmoothShorthands = true,\n    floatPrecision = 3,\n    transformPrecision = 5,\n    removeUseless = true,\n    collapseRepeated = true,\n    utilizeAbsolute = true,\n    leadingZero = true,\n    negativeExtraSpace = true,\n    noSpaceAfterFlags = false,\n    // a20 60 45 0 1 30 20 → a20 60 45 0130 20\n    forceAbsolutePath = false\n  } = params;\n\n  /**\n   * @type {InternalParams}\n   */\n  const newParams = {\n    applyTransforms: _applyTransforms,\n    applyTransformsStroked,\n    makeArcs,\n    straightCurves,\n    lineShorthands,\n    curveSmoothShorthands,\n    floatPrecision,\n    transformPrecision,\n    removeUseless,\n    collapseRepeated,\n    utilizeAbsolute,\n    leadingZero,\n    negativeExtraSpace,\n    noSpaceAfterFlags,\n    forceAbsolutePath\n  };\n\n  // invoke applyTransforms plugin\n  if (_applyTransforms) {\n    visit(root,\n    // @ts-ignore\n    applyTransforms(root, {\n      transformPrecision,\n      applyTransformsStroked\n    }));\n  }\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: node => {\n        if (pathElems.includes(node.name) && node.attributes.d != null) {\n          const computedStyle = computeStyle(stylesheet, node);\n          precision = floatPrecision;\n          error = precision !== false ? +Math.pow(0.1, precision).toFixed(precision) : 1e-2;\n          roundData = precision > 0 && precision < 20 ? strongRound : round;\n          if (makeArcs) {\n            arcThreshold = makeArcs.threshold;\n            arcTolerance = makeArcs.tolerance;\n          }\n          const hasMarkerMid = computedStyle['marker-mid'] != null;\n          const maybeHasStroke = computedStyle.stroke && (computedStyle.stroke.type === 'dynamic' || computedStyle.stroke.value !== 'none');\n          const maybeHasLinecap = computedStyle['stroke-linecap'] && (computedStyle['stroke-linecap'].type === 'dynamic' || computedStyle['stroke-linecap'].value !== 'butt');\n          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;\n          var data = path2js(node);\n\n          // TODO: get rid of functions returns\n          if (data.length) {\n            convertToRelative(data);\n            data = filters(data, newParams, {\n              maybeHasStrokeAndLinecap,\n              hasMarkerMid\n            });\n            if (utilizeAbsolute) {\n              data = convertToMixed(data, newParams);\n            }\n\n            // @ts-ignore\n            js2path(node, data, newParams);\n          }\n        }\n      }\n    }\n  };\n};\n\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @type {(pathData: PathDataItem[]) => PathDataItem[]}\n */\nconst convertToRelative = pathData => {\n  let start = [0, 0];\n  let cursor = [0, 0];\n  let prevCoords = [0, 0];\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathItem = pathData[i];\n    let {\n      command,\n      args\n    } = pathItem;\n\n    // moveto (x y)\n    if (command === 'm') {\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n    if (command === 'M') {\n      // M → m\n      // skip first moveto\n      if (i !== 0) {\n        command = 'm';\n      }\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    // lineto (x y)\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n    if (command === 'L') {\n      // L → l\n      command = 'l';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    // horizontal lineto (x)\n    if (command === 'h') {\n      cursor[0] += args[0];\n    }\n    if (command === 'H') {\n      // H → h\n      command = 'h';\n      args[0] -= cursor[0];\n      cursor[0] += args[0];\n    }\n\n    // vertical lineto (y)\n    if (command === 'v') {\n      cursor[1] += args[0];\n    }\n    if (command === 'V') {\n      // V → v\n      command = 'v';\n      args[0] -= cursor[1];\n      cursor[1] += args[0];\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n    if (command === 'C') {\n      // C → c\n      command = 'c';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      args[4] -= cursor[0];\n      args[5] -= cursor[1];\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n    if (command === 'S') {\n      // S → s\n      command = 's';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n    if (command === 'Q') {\n      // Q → q\n      command = 'q';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n    if (command === 'T') {\n      // T → t\n      command = 't';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'a') {\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n    if (command === 'A') {\n      // A → a\n      command = 'a';\n      args[5] -= cursor[0];\n      args[6] -= cursor[1];\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n\n    // closepath\n    if (command === 'Z' || command === 'z') {\n      // reset cursor\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n    pathItem.command = command;\n    pathItem.args = args;\n    // store absolute coordinates for later use\n    // base should preserve reference from other element\n    // @ts-ignore\n    pathItem.base = prevCoords;\n    // @ts-ignore\n    pathItem.coords = [cursor[0], cursor[1]];\n    // @ts-ignore\n    prevCoords = pathItem.coords;\n  }\n  return pathData;\n};\n\n/**\n * Main filters loop.\n *\n * @type {(\n *   path: PathDataItem[],\n *   params: InternalParams,\n *   aux: { maybeHasStrokeAndLinecap: boolean, hasMarkerMid: boolean }\n * ) => PathDataItem[]}\n */\nfunction filters(path, params, _ref) {\n  let {\n    maybeHasStrokeAndLinecap,\n    hasMarkerMid\n  } = _ref;\n  var stringify = data2Path.bind(null, params),\n    relSubpoint = [0, 0],\n    pathBase = [0, 0],\n    prev = {};\n  path = path.filter(function (item, index, path) {\n    let command = item.command;\n    let data = item.args;\n    let next = path[index + 1];\n    if (command !== 'Z' && command !== 'z') {\n      var sdata = data,\n        circle;\n      if (command === 's') {\n        sdata = [0, 0].concat(data);\n\n        // @ts-ignore\n        var pdata = prev.args,\n          n = pdata.length;\n\n        // (-x, -y) of the prev tangent point relative to the current point\n        sdata[0] = pdata[n - 2] - pdata[n - 4];\n        sdata[1] = pdata[n - 1] - pdata[n - 3];\n      }\n\n      // convert curves to arcs if possible\n      if (params.makeArcs && (command == 'c' || command == 's') && isConvex(sdata) && (circle = findCircle(sdata))) {\n        var r = roundData([circle.radius])[0],\n          angle = findArcAngle(sdata, circle),\n          sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,\n          /**\n           * @type {PathDataItem}\n           */\n          arc = {\n            command: 'a',\n            args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],\n            // @ts-ignore\n            coords: item.coords.slice(),\n            // @ts-ignore\n            base: item.base\n          },\n          /**\n           * @type {PathDataItem[]}\n           */\n          output = [arc],\n          // relative coordinates to adjust the found circle\n          /**\n           * @type {Point}\n           */\n          relCenter = [circle.center[0] - sdata[4], circle.center[1] - sdata[5]],\n          relCircle = {\n            center: relCenter,\n            radius: circle.radius\n          },\n          arcCurves = [item],\n          hasPrev = 0,\n          suffix = '',\n          nextLonghand;\n        if (\n        // @ts-ignore\n        prev.command == 'c' &&\n        // @ts-ignore\n        isConvex(prev.args) &&\n        // @ts-ignore\n        isArcPrev(prev.args, circle) ||\n        // @ts-ignore\n        prev.command == 'a' && prev.sdata && isArcPrev(prev.sdata, circle)) {\n          // @ts-ignore\n          arcCurves.unshift(prev);\n          // @ts-ignore\n          arc.base = prev.base;\n          // @ts-ignore\n          arc.args[5] = arc.coords[0] - arc.base[0];\n          // @ts-ignore\n          arc.args[6] = arc.coords[1] - arc.base[1];\n          // @ts-ignore\n          var prevData = prev.command == 'a' ? prev.sdata : prev.args;\n          var prevAngle = findArcAngle(prevData, {\n            center: [prevData[4] + circle.center[0], prevData[5] + circle.center[1]],\n            radius: circle.radius\n          });\n          angle += prevAngle;\n          if (angle > Math.PI) arc.args[3] = 1;\n          hasPrev = 1;\n        }\n\n        // check if next curves are fitting the arc\n        for (var j = index; (next = path[++j]) && ~'cs'.indexOf(next.command);) {\n          var nextData = next.args;\n          if (next.command == 's') {\n            nextLonghand = makeLonghand({\n              command: 's',\n              args: next.args.slice()\n            }, path[j - 1].args);\n            nextData = nextLonghand.args;\n            nextLonghand.args = nextData.slice(0, 2);\n            suffix = stringify([nextLonghand]);\n          }\n          if (isConvex(nextData) && isArc(nextData, relCircle)) {\n            angle += findArcAngle(nextData, relCircle);\n            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°\n            if (angle > Math.PI) arc.args[3] = 1;\n            arcCurves.push(next);\n            if (2 * Math.PI - angle > 1e-3) {\n              // less than 360°\n              // @ts-ignore\n              arc.coords = next.coords;\n              // @ts-ignore\n              arc.args[5] = arc.coords[0] - arc.base[0];\n              // @ts-ignore\n              arc.args[6] = arc.coords[1] - arc.base[1];\n            } else {\n              // full circle, make a half-circle arc and add a second one\n              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);\n              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);\n              // @ts-ignore\n              arc.coords = [\n              // @ts-ignore\n              arc.base[0] + arc.args[5],\n              // @ts-ignore\n              arc.base[1] + arc.args[6]];\n              arc = {\n                command: 'a',\n                args: [r, r, 0, 0, sweep,\n                // @ts-ignore\n                next.coords[0] - arc.coords[0],\n                // @ts-ignore\n                next.coords[1] - arc.coords[1]],\n                // @ts-ignore\n                coords: next.coords,\n                // @ts-ignore\n                base: arc.coords\n              };\n              output.push(arc);\n              j++;\n              break;\n            }\n            relCenter[0] -= nextData[4];\n            relCenter[1] -= nextData[5];\n          } else break;\n        }\n        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {\n          if (path[j] && path[j].command == 's') {\n            makeLonghand(path[j], path[j - 1].args);\n          }\n          if (hasPrev) {\n            var prevArc = output.shift();\n            // @ts-ignore\n            roundData(prevArc.args);\n            // @ts-ignore\n            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];\n            // @ts-ignore\n            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];\n            // @ts-ignore\n            prev.command = 'a';\n            // @ts-ignore\n            prev.args = prevArc.args;\n            // @ts-ignore\n            item.base = prev.coords = prevArc.coords;\n          }\n          // @ts-ignore\n          arc = output.shift();\n          if (arcCurves.length == 1) {\n            // @ts-ignore\n            item.sdata = sdata.slice(); // preserve curve data for future checks\n          } else if (arcCurves.length - 1 - hasPrev > 0) {\n            // filter out consumed next items\n            path.splice.apply(path,\n            // @ts-ignore\n            [index + 1, arcCurves.length - 1 - hasPrev].concat(output));\n          }\n          if (!arc) return false;\n          command = 'a';\n          data = arc.args;\n          // @ts-ignore\n          item.coords = arc.coords;\n        }\n      }\n\n      // Rounding relative coordinates, taking in account accummulating error\n      // to get closer to absolute coordinates. Sum of rounded value remains same:\n      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n      if (precision !== false) {\n        if (command === 'm' || command === 'l' || command === 't' || command === 'q' || command === 's' || command === 'c') {\n          for (var i = data.length; i--;) {\n            // @ts-ignore\n            data[i] += item.base[i % 2] - relSubpoint[i % 2];\n          }\n        } else if (command == 'h') {\n          // @ts-ignore\n          data[0] += item.base[0] - relSubpoint[0];\n        } else if (command == 'v') {\n          // @ts-ignore\n          data[0] += item.base[1] - relSubpoint[1];\n        } else if (command == 'a') {\n          // @ts-ignore\n          data[5] += item.base[0] - relSubpoint[0];\n          // @ts-ignore\n          data[6] += item.base[1] - relSubpoint[1];\n        }\n        roundData(data);\n        if (command == 'h') relSubpoint[0] += data[0];else if (command == 'v') relSubpoint[1] += data[0];else {\n          relSubpoint[0] += data[data.length - 2];\n          relSubpoint[1] += data[data.length - 1];\n        }\n        roundData(relSubpoint);\n        if (command === 'M' || command === 'm') {\n          pathBase[0] = relSubpoint[0];\n          pathBase[1] = relSubpoint[1];\n        }\n      }\n\n      // convert straight curves into lines segments\n      if (params.straightCurves) {\n        if (command === 'c' && isCurveStraightLine(data) || command === 's' && isCurveStraightLine(sdata)) {\n          if (next && next.command == 's') makeLonghand(next, data); // fix up next curve\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'q' && isCurveStraightLine(data)) {\n          if (next && next.command == 't') makeLonghand(next, data); // fix up next curve\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 't' &&\n        // @ts-ignore\n        prev.command !== 'q' &&\n        // @ts-ignore\n        prev.command !== 't') {\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'a' && (data[0] === 0 || data[1] === 0)) {\n          command = 'l';\n          data = data.slice(-2);\n        }\n      }\n\n      // horizontal and vertical line shorthands\n      // l 50 0 → h 50\n      // l 0 50 → v 50\n      if (params.lineShorthands && command === 'l') {\n        if (data[1] === 0) {\n          command = 'h';\n          data.pop();\n        } else if (data[0] === 0) {\n          command = 'v';\n          data.shift();\n        }\n      }\n\n      // collapse repeated commands\n      // h 20 h 30 -> h 50\n      if (params.collapseRepeated && hasMarkerMid === false && (command === 'm' || command === 'h' || command === 'v') &&\n      // @ts-ignore\n      prev.command &&\n      // @ts-ignore\n      command == prev.command.toLowerCase() && (command != 'h' && command != 'v' ||\n      // @ts-ignore\n      prev.args[0] >= 0 == data[0] >= 0)) {\n        // @ts-ignore\n        prev.args[0] += data[0];\n        if (command != 'h' && command != 'v') {\n          // @ts-ignore\n          prev.args[1] += data[1];\n        }\n        // @ts-ignore\n        prev.coords = item.coords;\n        // @ts-ignore\n        path[index] = prev;\n        return false;\n      }\n\n      // convert curves into smooth shorthands\n      // @ts-ignore\n      if (params.curveSmoothShorthands && prev.command) {\n        // curveto\n        if (command === 'c') {\n          // c + c → c + s\n          if (\n          // @ts-ignore\n          prev.command === 'c' &&\n          // @ts-ignore\n          data[0] === -(prev.args[2] - prev.args[4]) &&\n          // @ts-ignore\n          data[1] === -(prev.args[3] - prev.args[5])) {\n            command = 's';\n            data = data.slice(2);\n          }\n\n          // s + c → s + s\n          else if (\n          // @ts-ignore\n          prev.command === 's' &&\n          // @ts-ignore\n          data[0] === -(prev.args[0] - prev.args[2]) &&\n          // @ts-ignore\n          data[1] === -(prev.args[1] - prev.args[3])) {\n            command = 's';\n            data = data.slice(2);\n          }\n\n          // [^cs] + c → [^cs] + s\n          else if (\n          // @ts-ignore\n          prev.command !== 'c' &&\n          // @ts-ignore\n          prev.command !== 's' && data[0] === 0 && data[1] === 0) {\n            command = 's';\n            data = data.slice(2);\n          }\n        }\n\n        // quadratic Bézier curveto\n        else if (command === 'q') {\n          // q + q → q + t\n          if (\n          // @ts-ignore\n          prev.command === 'q' &&\n          // @ts-ignore\n          data[0] === prev.args[2] - prev.args[0] &&\n          // @ts-ignore\n          data[1] === prev.args[3] - prev.args[1]) {\n            command = 't';\n            data = data.slice(2);\n          }\n\n          // t + q → t + t\n          else if (\n          // @ts-ignore\n          prev.command === 't' &&\n          // @ts-ignore\n          data[2] === prev.args[0] &&\n          // @ts-ignore\n          data[3] === prev.args[1]) {\n            command = 't';\n            data = data.slice(2);\n          }\n        }\n      }\n\n      // remove useless non-first path segments\n      if (params.removeUseless && !maybeHasStrokeAndLinecap) {\n        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n        if ((command === 'l' || command === 'h' || command === 'v' || command === 'q' || command === 't' || command === 'c' || command === 's') && data.every(function (i) {\n          return i === 0;\n        })) {\n          // @ts-ignore\n          path[index] = prev;\n          return false;\n        }\n\n        // a 25,25 -30 0,1 0,0\n        if (command === 'a' && data[5] === 0 && data[6] === 0) {\n          // @ts-ignore\n          path[index] = prev;\n          return false;\n        }\n      }\n      item.command = command;\n      item.args = data;\n      prev = item;\n    } else {\n      // z resets coordinates\n      relSubpoint[0] = pathBase[0];\n      relSubpoint[1] = pathBase[1];\n      // @ts-ignore\n      if (prev.command === 'Z' || prev.command === 'z') return false;\n      prev = item;\n    }\n    return true;\n  });\n  return path;\n}\n\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @type {(path: PathDataItem[], params: InternalParams) => PathDataItem[]}\n */\nfunction convertToMixed(path, params) {\n  var prev = path[0];\n  path = path.filter(function (item, index) {\n    if (index == 0) return true;\n    if (item.command === 'Z' || item.command === 'z') {\n      prev = item;\n      return true;\n    }\n    var command = item.command,\n      data = item.args,\n      adata = data.slice();\n    if (command === 'm' || command === 'l' || command === 't' || command === 'q' || command === 's' || command === 'c') {\n      for (var i = adata.length; i--;) {\n        // @ts-ignore\n        adata[i] += item.base[i % 2];\n      }\n    } else if (command == 'h') {\n      // @ts-ignore\n      adata[0] += item.base[0];\n    } else if (command == 'v') {\n      // @ts-ignore\n      adata[0] += item.base[1];\n    } else if (command == 'a') {\n      // @ts-ignore\n      adata[5] += item.base[0];\n      // @ts-ignore\n      adata[6] += item.base[1];\n    }\n    roundData(adata);\n    var absoluteDataStr = cleanupOutData(adata, params),\n      relativeDataStr = cleanupOutData(data, params);\n\n    // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.\n    // v-20 -> V0\n    // Don't convert if it fits following previous command.\n    // l20 30-10-50 instead of l20 30L20 30\n    if (params.forceAbsolutePath || absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && command == prev.command && prev.command.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 ||\n    // @ts-ignore\n    /^0\\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))) {\n      // @ts-ignore\n      item.command = command.toUpperCase();\n      item.args = adata;\n    }\n    prev = item;\n    return true;\n  });\n  return path;\n}\n\n/**\n * Checks if curve is convex. Control points of such a curve must form\n * a convex quadrilateral with diagonals crosspoint inside of it.\n *\n * @type {(data: number[]) => boolean}\n */\nfunction isConvex(data) {\n  var center = getIntersection([0, 0, data[2], data[3], data[0], data[1], data[4], data[5]]);\n  return center != null && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];\n}\n\n/**\n * Computes lines equations by two points and returns their intersection point.\n *\n * @type {(coords: number[]) => undefined | Point}\n */\nfunction getIntersection(coords) {\n  // Prev line equation parameters.\n  var a1 = coords[1] - coords[3],\n    // y1 - y2\n    b1 = coords[2] - coords[0],\n    // x2 - x1\n    c1 = coords[0] * coords[3] - coords[2] * coords[1],\n    // x1 * y2 - x2 * y1\n    // Next line equation parameters\n    a2 = coords[5] - coords[7],\n    // y1 - y2\n    b2 = coords[6] - coords[4],\n    // x2 - x1\n    c2 = coords[4] * coords[7] - coords[5] * coords[6],\n    // x1 * y2 - x2 * y1\n    denom = a1 * b2 - a2 * b1;\n  if (!denom) return; // parallel lines havn't an intersection\n\n  /**\n   * @type {Point}\n   */\n  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];\n  if (!isNaN(cross[0]) && !isNaN(cross[1]) && isFinite(cross[0]) && isFinite(cross[1])) {\n    return cross;\n  }\n}\n\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.3491 to 2.35 instead of 2.349.\n * Doesn't apply \"smartness\" if the number precision fits already.\n *\n * @type {(data: number[]) => number[]}\n */\nfunction strongRound(data) {\n  for (var i = data.length; i-- > 0;) {\n    // @ts-ignore\n    if (data[i].toFixed(precision) != data[i]) {\n      // @ts-ignore\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] =\n      // @ts-ignore\n      +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error ?\n      // @ts-ignore\n      +data[i].toFixed(precision) : rounded;\n    }\n  }\n  return data;\n}\n\n/**\n * Simple rounding function if precision is 0.\n *\n * @type {(data: number[]) => number[]}\n */\nfunction round(data) {\n  for (var i = data.length; i-- > 0;) {\n    data[i] = Math.round(data[i]);\n  }\n  return data;\n}\n\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @type {(data: number[]) => boolean}\n */\n\nfunction isCurveStraightLine(data) {\n  // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.\n  var i = data.length - 2,\n    a = -data[i + 1],\n    // y1 − y2 (y1 = 0)\n    b = data[i],\n    // x2 − x1 (x1 = 0)\n    d = 1 / (a * a + b * b); // same part for all points\n\n  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case\n\n  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n  while ((i -= 2) >= 0) {\n    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error) return false;\n  }\n  return true;\n}\n\n/**\n * Converts next curve from shorthand to full form using the current curve data.\n *\n * @type {(item: PathDataItem, data: number[]) => PathDataItem}\n */\n\nfunction makeLonghand(item, data) {\n  switch (item.command) {\n    case 's':\n      item.command = 'c';\n      break;\n    case 't':\n      item.command = 'q';\n      break;\n  }\n  item.args.unshift(data[data.length - 2] - data[data.length - 4], data[data.length - 1] - data[data.length - 3]);\n  return item;\n}\n\n/**\n * Returns distance between two points\n *\n * @type {(point1: Point, point2: Point) => number}\n */\n\nfunction getDistance(point1, point2) {\n  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);\n}\n\n/**\n * Returns coordinates of the curve point corresponding to the certain t\n * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,\n * where pN are control points and p1 is zero due to relative coordinates.\n *\n * @type {(curve: number[], t: number) => Point}\n */\n\nfunction getCubicBezierPoint(curve, t) {\n  var sqrT = t * t,\n    cubT = sqrT * t,\n    mt = 1 - t,\n    sqrMt = mt * mt;\n  return [3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4], 3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]];\n}\n\n/**\n * Finds circle by 3 points of the curve and checks if the curve fits the found circle.\n *\n * @type {(curve: number[]) => undefined | Circle}\n */\n\nfunction findCircle(curve) {\n  var midPoint = getCubicBezierPoint(curve, 1 / 2),\n    m1 = [midPoint[0] / 2, midPoint[1] / 2],\n    m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],\n    center = getIntersection([m1[0], m1[1], m1[0] + m1[1], m1[1] - m1[0], m2[0], m2[1], m2[0] + (m2[1] - midPoint[1]), m2[1] - (m2[0] - midPoint[0])]),\n    radius = center && getDistance([0, 0], center),\n    // @ts-ignore\n    tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);\n  if (center &&\n  // @ts-ignore\n  radius < 1e15 && [1 / 4, 3 / 4].every(function (point) {\n    return Math.abs(\n    // @ts-ignore\n    getDistance(getCubicBezierPoint(curve, point), center) - radius) <= tolerance;\n  }))\n    // @ts-ignore\n    return {\n      center: center,\n      radius: radius\n    };\n}\n\n/**\n * Checks if a curve fits the given circle.\n *\n * @type {(curve: number[], circle: Circle) => boolean}\n */\n\nfunction isArc(curve, circle) {\n  var tolerance = Math.min(arcThreshold * error, arcTolerance * circle.radius / 100);\n  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {\n    return Math.abs(getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius) <= tolerance;\n  });\n}\n\n/**\n * Checks if a previous curve fits the given circle.\n *\n * @type {(curve: number[], circle: Circle) => boolean}\n */\n\nfunction isArcPrev(curve, circle) {\n  return isArc(curve, {\n    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],\n    radius: circle.radius\n  });\n}\n\n/**\n * Finds angle of a curve fitting the given arc.\n\n * @type {(curve: number[], relCircle: Circle) => number}\n */\n\nfunction findArcAngle(curve, relCircle) {\n  var x1 = -relCircle.center[0],\n    y1 = -relCircle.center[1],\n    x2 = curve[4] - relCircle.center[0],\n    y2 = curve[5] - relCircle.center[1];\n  return Math.acos((x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)));\n}\n\n/**\n * Converts given path data to string.\n *\n * @type {(params: InternalParams, pathData: PathDataItem[]) => string}\n */\n\nfunction data2Path(params, pathData) {\n  return pathData.reduce(function (pathString, item) {\n    var strData = '';\n    if (item.args) {\n      strData = cleanupOutData(roundData(item.args.slice()), params);\n    }\n    return pathString + item.command + strData;\n  }, '');\n}","map":{"version":3,"names":["collectStylesheet","computeStyle","require","visit","pathElems","path2js","js2path","applyTransforms","cleanupOutData","exports","name","description","roundData","precision","error","arcThreshold","arcTolerance","fn","root","params","_applyTransforms","applyTransformsStroked","makeArcs","threshold","tolerance","straightCurves","lineShorthands","curveSmoothShorthands","floatPrecision","transformPrecision","removeUseless","collapseRepeated","utilizeAbsolute","leadingZero","negativeExtraSpace","noSpaceAfterFlags","forceAbsolutePath","newParams","stylesheet","element","enter","node","includes","attributes","d","computedStyle","Math","pow","toFixed","strongRound","round","hasMarkerMid","maybeHasStroke","stroke","type","value","maybeHasLinecap","maybeHasStrokeAndLinecap","data","length","convertToRelative","filters","convertToMixed","pathData","start","cursor","prevCoords","i","pathItem","command","args","base","coords","path","_ref","stringify","data2Path","bind","relSubpoint","pathBase","prev","filter","item","index","next","sdata","circle","concat","pdata","n","isConvex","findCircle","r","radius","angle","findArcAngle","sweep","arc","slice","output","relCenter","center","relCircle","arcCurves","hasPrev","suffix","nextLonghand","isArcPrev","unshift","prevData","prevAngle","PI","j","indexOf","nextData","makeLonghand","isArc","push","prevArc","shift","splice","apply","isCurveStraightLine","pop","toLowerCase","every","adata","absoluteDataStr","relativeDataStr","charCodeAt","test","toUpperCase","getIntersection","a1","b1","c1","a2","b2","c2","denom","cross","isNaN","isFinite","rounded","abs","a","b","sqrt","getDistance","point1","point2","hypot","getCubicBezierPoint","curve","t","sqrT","cubT","mt","sqrMt","midPoint","m1","m2","min","point","x1","y1","x2","y2","acos","reduce","pathString","strData"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/convertPathData.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib//types').PathDataItem} PathDataItem\n */\n\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst { visit } = require('../lib/xast.js');\nconst { pathElems } = require('./_collections.js');\nconst { path2js, js2path } = require('./_path.js');\nconst { applyTransforms } = require('./applyTransforms.js');\nconst { cleanupOutData } = require('../lib/svgo/tools');\n\nexports.name = 'convertPathData';\nexports.description =\n  'optimizes path data: writes in shorter form, applies transformations';\n\n/**\n * @type {(data: number[]) => number[]}\n */\nlet roundData;\n/**\n * @type {number | false}\n */\nlet precision;\n/**\n * @type {number}\n */\nlet error;\n/**\n * @type {number}\n */\nlet arcThreshold;\n/**\n * @type {number}\n */\nlet arcTolerance;\n\n/**\n * @typedef {{\n *   applyTransforms: boolean,\n *   applyTransformsStroked: boolean,\n *   makeArcs: {\n *     threshold: number,\n *     tolerance: number,\n *   },\n *   straightCurves: boolean,\n *   lineShorthands: boolean,\n *   curveSmoothShorthands: boolean,\n *   floatPrecision: number | false,\n *   transformPrecision: number,\n *   removeUseless: boolean,\n *   collapseRepeated: boolean,\n *   utilizeAbsolute: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n *   noSpaceAfterFlags: boolean,\n *   forceAbsolutePath: boolean,\n * }} InternalParams\n */\n\n/**\n * @typedef {[number, number]} Point\n */\n\n/**\n * @typedef {{\n *   center: Point,\n *   radius: number\n * }} Circle\n */\n\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see https://www.w3.org/TR/SVG11/paths.html#PathData\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'convertPathData'>}\n */\nexports.fn = (root, params) => {\n  const {\n    // TODO convert to separate plugin in v3\n    applyTransforms: _applyTransforms = true,\n    applyTransformsStroked = true,\n    makeArcs = {\n      threshold: 2.5, // coefficient of rounding error\n      tolerance: 0.5, // percentage of radius\n    },\n    straightCurves = true,\n    lineShorthands = true,\n    curveSmoothShorthands = true,\n    floatPrecision = 3,\n    transformPrecision = 5,\n    removeUseless = true,\n    collapseRepeated = true,\n    utilizeAbsolute = true,\n    leadingZero = true,\n    negativeExtraSpace = true,\n    noSpaceAfterFlags = false, // a20 60 45 0 1 30 20 → a20 60 45 0130 20\n    forceAbsolutePath = false,\n  } = params;\n\n  /**\n   * @type {InternalParams}\n   */\n  const newParams = {\n    applyTransforms: _applyTransforms,\n    applyTransformsStroked,\n    makeArcs,\n    straightCurves,\n    lineShorthands,\n    curveSmoothShorthands,\n    floatPrecision,\n    transformPrecision,\n    removeUseless,\n    collapseRepeated,\n    utilizeAbsolute,\n    leadingZero,\n    negativeExtraSpace,\n    noSpaceAfterFlags,\n    forceAbsolutePath,\n  };\n\n  // invoke applyTransforms plugin\n  if (_applyTransforms) {\n    visit(\n      root,\n      // @ts-ignore\n      applyTransforms(root, {\n        transformPrecision,\n        applyTransformsStroked,\n      })\n    );\n  }\n\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: (node) => {\n        if (pathElems.includes(node.name) && node.attributes.d != null) {\n          const computedStyle = computeStyle(stylesheet, node);\n          precision = floatPrecision;\n          error =\n            precision !== false\n              ? +Math.pow(0.1, precision).toFixed(precision)\n              : 1e-2;\n          roundData = precision > 0 && precision < 20 ? strongRound : round;\n          if (makeArcs) {\n            arcThreshold = makeArcs.threshold;\n            arcTolerance = makeArcs.tolerance;\n          }\n          const hasMarkerMid = computedStyle['marker-mid'] != null;\n\n          const maybeHasStroke =\n            computedStyle.stroke &&\n            (computedStyle.stroke.type === 'dynamic' ||\n              computedStyle.stroke.value !== 'none');\n          const maybeHasLinecap =\n            computedStyle['stroke-linecap'] &&\n            (computedStyle['stroke-linecap'].type === 'dynamic' ||\n              computedStyle['stroke-linecap'].value !== 'butt');\n          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;\n\n          var data = path2js(node);\n\n          // TODO: get rid of functions returns\n          if (data.length) {\n            convertToRelative(data);\n\n            data = filters(data, newParams, {\n              maybeHasStrokeAndLinecap,\n              hasMarkerMid,\n            });\n\n            if (utilizeAbsolute) {\n              data = convertToMixed(data, newParams);\n            }\n\n            // @ts-ignore\n            js2path(node, data, newParams);\n          }\n        }\n      },\n    },\n  };\n};\n\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @type {(pathData: PathDataItem[]) => PathDataItem[]}\n */\nconst convertToRelative = (pathData) => {\n  let start = [0, 0];\n  let cursor = [0, 0];\n  let prevCoords = [0, 0];\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathItem = pathData[i];\n    let { command, args } = pathItem;\n\n    // moveto (x y)\n    if (command === 'm') {\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n    if (command === 'M') {\n      // M → m\n      // skip first moveto\n      if (i !== 0) {\n        command = 'm';\n      }\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    // lineto (x y)\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n    if (command === 'L') {\n      // L → l\n      command = 'l';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    // horizontal lineto (x)\n    if (command === 'h') {\n      cursor[0] += args[0];\n    }\n    if (command === 'H') {\n      // H → h\n      command = 'h';\n      args[0] -= cursor[0];\n      cursor[0] += args[0];\n    }\n\n    // vertical lineto (y)\n    if (command === 'v') {\n      cursor[1] += args[0];\n    }\n    if (command === 'V') {\n      // V → v\n      command = 'v';\n      args[0] -= cursor[1];\n      cursor[1] += args[0];\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n    if (command === 'C') {\n      // C → c\n      command = 'c';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      args[4] -= cursor[0];\n      args[5] -= cursor[1];\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n    if (command === 'S') {\n      // S → s\n      command = 's';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n    if (command === 'Q') {\n      // Q → q\n      command = 'q';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n    if (command === 'T') {\n      // T → t\n      command = 't';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'a') {\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n    if (command === 'A') {\n      // A → a\n      command = 'a';\n      args[5] -= cursor[0];\n      args[6] -= cursor[1];\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n\n    // closepath\n    if (command === 'Z' || command === 'z') {\n      // reset cursor\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n\n    pathItem.command = command;\n    pathItem.args = args;\n    // store absolute coordinates for later use\n    // base should preserve reference from other element\n    // @ts-ignore\n    pathItem.base = prevCoords;\n    // @ts-ignore\n    pathItem.coords = [cursor[0], cursor[1]];\n    // @ts-ignore\n    prevCoords = pathItem.coords;\n  }\n\n  return pathData;\n};\n\n/**\n * Main filters loop.\n *\n * @type {(\n *   path: PathDataItem[],\n *   params: InternalParams,\n *   aux: { maybeHasStrokeAndLinecap: boolean, hasMarkerMid: boolean }\n * ) => PathDataItem[]}\n */\nfunction filters(path, params, { maybeHasStrokeAndLinecap, hasMarkerMid }) {\n  var stringify = data2Path.bind(null, params),\n    relSubpoint = [0, 0],\n    pathBase = [0, 0],\n    prev = {};\n\n  path = path.filter(function (item, index, path) {\n    let command = item.command;\n    let data = item.args;\n    let next = path[index + 1];\n\n    if (command !== 'Z' && command !== 'z') {\n      var sdata = data,\n        circle;\n\n      if (command === 's') {\n        sdata = [0, 0].concat(data);\n\n        // @ts-ignore\n        var pdata = prev.args,\n          n = pdata.length;\n\n        // (-x, -y) of the prev tangent point relative to the current point\n        sdata[0] = pdata[n - 2] - pdata[n - 4];\n        sdata[1] = pdata[n - 1] - pdata[n - 3];\n      }\n\n      // convert curves to arcs if possible\n      if (\n        params.makeArcs &&\n        (command == 'c' || command == 's') &&\n        isConvex(sdata) &&\n        (circle = findCircle(sdata))\n      ) {\n        var r = roundData([circle.radius])[0],\n          angle = findArcAngle(sdata, circle),\n          sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,\n          /**\n           * @type {PathDataItem}\n           */\n          arc = {\n            command: 'a',\n            args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],\n            // @ts-ignore\n            coords: item.coords.slice(),\n            // @ts-ignore\n            base: item.base,\n          },\n          /**\n           * @type {PathDataItem[]}\n           */\n          output = [arc],\n          // relative coordinates to adjust the found circle\n          /**\n           * @type {Point}\n           */\n          relCenter = [\n            circle.center[0] - sdata[4],\n            circle.center[1] - sdata[5],\n          ],\n          relCircle = { center: relCenter, radius: circle.radius },\n          arcCurves = [item],\n          hasPrev = 0,\n          suffix = '',\n          nextLonghand;\n\n        if (\n          // @ts-ignore\n          (prev.command == 'c' &&\n            // @ts-ignore\n            isConvex(prev.args) &&\n            // @ts-ignore\n            isArcPrev(prev.args, circle)) ||\n          // @ts-ignore\n          (prev.command == 'a' && prev.sdata && isArcPrev(prev.sdata, circle))\n        ) {\n          // @ts-ignore\n          arcCurves.unshift(prev);\n          // @ts-ignore\n          arc.base = prev.base;\n          // @ts-ignore\n          arc.args[5] = arc.coords[0] - arc.base[0];\n          // @ts-ignore\n          arc.args[6] = arc.coords[1] - arc.base[1];\n          // @ts-ignore\n          var prevData = prev.command == 'a' ? prev.sdata : prev.args;\n          var prevAngle = findArcAngle(prevData, {\n            center: [\n              prevData[4] + circle.center[0],\n              prevData[5] + circle.center[1],\n            ],\n            radius: circle.radius,\n          });\n          angle += prevAngle;\n          if (angle > Math.PI) arc.args[3] = 1;\n          hasPrev = 1;\n        }\n\n        // check if next curves are fitting the arc\n        for (\n          var j = index;\n          (next = path[++j]) && ~'cs'.indexOf(next.command);\n\n        ) {\n          var nextData = next.args;\n          if (next.command == 's') {\n            nextLonghand = makeLonghand(\n              { command: 's', args: next.args.slice() },\n              path[j - 1].args\n            );\n            nextData = nextLonghand.args;\n            nextLonghand.args = nextData.slice(0, 2);\n            suffix = stringify([nextLonghand]);\n          }\n          if (isConvex(nextData) && isArc(nextData, relCircle)) {\n            angle += findArcAngle(nextData, relCircle);\n            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°\n            if (angle > Math.PI) arc.args[3] = 1;\n            arcCurves.push(next);\n            if (2 * Math.PI - angle > 1e-3) {\n              // less than 360°\n              // @ts-ignore\n              arc.coords = next.coords;\n              // @ts-ignore\n              arc.args[5] = arc.coords[0] - arc.base[0];\n              // @ts-ignore\n              arc.args[6] = arc.coords[1] - arc.base[1];\n            } else {\n              // full circle, make a half-circle arc and add a second one\n              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);\n              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);\n              // @ts-ignore\n              arc.coords = [\n                // @ts-ignore\n                arc.base[0] + arc.args[5],\n                // @ts-ignore\n                arc.base[1] + arc.args[6],\n              ];\n              arc = {\n                command: 'a',\n                args: [\n                  r,\n                  r,\n                  0,\n                  0,\n                  sweep,\n                  // @ts-ignore\n                  next.coords[0] - arc.coords[0],\n                  // @ts-ignore\n                  next.coords[1] - arc.coords[1],\n                ],\n                // @ts-ignore\n                coords: next.coords,\n                // @ts-ignore\n                base: arc.coords,\n              };\n              output.push(arc);\n              j++;\n              break;\n            }\n            relCenter[0] -= nextData[4];\n            relCenter[1] -= nextData[5];\n          } else break;\n        }\n\n        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {\n          if (path[j] && path[j].command == 's') {\n            makeLonghand(path[j], path[j - 1].args);\n          }\n          if (hasPrev) {\n            var prevArc = output.shift();\n            // @ts-ignore\n            roundData(prevArc.args);\n            // @ts-ignore\n            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];\n            // @ts-ignore\n            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];\n            // @ts-ignore\n            prev.command = 'a';\n            // @ts-ignore\n            prev.args = prevArc.args;\n            // @ts-ignore\n            item.base = prev.coords = prevArc.coords;\n          }\n          // @ts-ignore\n          arc = output.shift();\n          if (arcCurves.length == 1) {\n            // @ts-ignore\n            item.sdata = sdata.slice(); // preserve curve data for future checks\n          } else if (arcCurves.length - 1 - hasPrev > 0) {\n            // filter out consumed next items\n            path.splice.apply(\n              path,\n              // @ts-ignore\n              [index + 1, arcCurves.length - 1 - hasPrev].concat(output)\n            );\n          }\n          if (!arc) return false;\n          command = 'a';\n          data = arc.args;\n          // @ts-ignore\n          item.coords = arc.coords;\n        }\n      }\n\n      // Rounding relative coordinates, taking in account accummulating error\n      // to get closer to absolute coordinates. Sum of rounded value remains same:\n      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n      if (precision !== false) {\n        if (\n          command === 'm' ||\n          command === 'l' ||\n          command === 't' ||\n          command === 'q' ||\n          command === 's' ||\n          command === 'c'\n        ) {\n          for (var i = data.length; i--; ) {\n            // @ts-ignore\n            data[i] += item.base[i % 2] - relSubpoint[i % 2];\n          }\n        } else if (command == 'h') {\n          // @ts-ignore\n          data[0] += item.base[0] - relSubpoint[0];\n        } else if (command == 'v') {\n          // @ts-ignore\n          data[0] += item.base[1] - relSubpoint[1];\n        } else if (command == 'a') {\n          // @ts-ignore\n          data[5] += item.base[0] - relSubpoint[0];\n          // @ts-ignore\n          data[6] += item.base[1] - relSubpoint[1];\n        }\n        roundData(data);\n\n        if (command == 'h') relSubpoint[0] += data[0];\n        else if (command == 'v') relSubpoint[1] += data[0];\n        else {\n          relSubpoint[0] += data[data.length - 2];\n          relSubpoint[1] += data[data.length - 1];\n        }\n        roundData(relSubpoint);\n\n        if (command === 'M' || command === 'm') {\n          pathBase[0] = relSubpoint[0];\n          pathBase[1] = relSubpoint[1];\n        }\n      }\n\n      // convert straight curves into lines segments\n      if (params.straightCurves) {\n        if (\n          (command === 'c' && isCurveStraightLine(data)) ||\n          (command === 's' && isCurveStraightLine(sdata))\n        ) {\n          if (next && next.command == 's') makeLonghand(next, data); // fix up next curve\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'q' && isCurveStraightLine(data)) {\n          if (next && next.command == 't') makeLonghand(next, data); // fix up next curve\n          command = 'l';\n          data = data.slice(-2);\n        } else if (\n          command === 't' &&\n          // @ts-ignore\n          prev.command !== 'q' &&\n          // @ts-ignore\n          prev.command !== 't'\n        ) {\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'a' && (data[0] === 0 || data[1] === 0)) {\n          command = 'l';\n          data = data.slice(-2);\n        }\n      }\n\n      // horizontal and vertical line shorthands\n      // l 50 0 → h 50\n      // l 0 50 → v 50\n      if (params.lineShorthands && command === 'l') {\n        if (data[1] === 0) {\n          command = 'h';\n          data.pop();\n        } else if (data[0] === 0) {\n          command = 'v';\n          data.shift();\n        }\n      }\n\n      // collapse repeated commands\n      // h 20 h 30 -> h 50\n      if (\n        params.collapseRepeated &&\n        hasMarkerMid === false &&\n        (command === 'm' || command === 'h' || command === 'v') &&\n        // @ts-ignore\n        prev.command &&\n        // @ts-ignore\n        command == prev.command.toLowerCase() &&\n        ((command != 'h' && command != 'v') ||\n          // @ts-ignore\n          prev.args[0] >= 0 == data[0] >= 0)\n      ) {\n        // @ts-ignore\n        prev.args[0] += data[0];\n        if (command != 'h' && command != 'v') {\n          // @ts-ignore\n          prev.args[1] += data[1];\n        }\n        // @ts-ignore\n        prev.coords = item.coords;\n        // @ts-ignore\n        path[index] = prev;\n        return false;\n      }\n\n      // convert curves into smooth shorthands\n      // @ts-ignore\n      if (params.curveSmoothShorthands && prev.command) {\n        // curveto\n        if (command === 'c') {\n          // c + c → c + s\n          if (\n            // @ts-ignore\n            prev.command === 'c' &&\n            // @ts-ignore\n            data[0] === -(prev.args[2] - prev.args[4]) &&\n            // @ts-ignore\n            data[1] === -(prev.args[3] - prev.args[5])\n          ) {\n            command = 's';\n            data = data.slice(2);\n          }\n\n          // s + c → s + s\n          else if (\n            // @ts-ignore\n            prev.command === 's' &&\n            // @ts-ignore\n            data[0] === -(prev.args[0] - prev.args[2]) &&\n            // @ts-ignore\n            data[1] === -(prev.args[1] - prev.args[3])\n          ) {\n            command = 's';\n            data = data.slice(2);\n          }\n\n          // [^cs] + c → [^cs] + s\n          else if (\n            // @ts-ignore\n            prev.command !== 'c' &&\n            // @ts-ignore\n            prev.command !== 's' &&\n            data[0] === 0 &&\n            data[1] === 0\n          ) {\n            command = 's';\n            data = data.slice(2);\n          }\n        }\n\n        // quadratic Bézier curveto\n        else if (command === 'q') {\n          // q + q → q + t\n          if (\n            // @ts-ignore\n            prev.command === 'q' &&\n            // @ts-ignore\n            data[0] === prev.args[2] - prev.args[0] &&\n            // @ts-ignore\n            data[1] === prev.args[3] - prev.args[1]\n          ) {\n            command = 't';\n            data = data.slice(2);\n          }\n\n          // t + q → t + t\n          else if (\n            // @ts-ignore\n            prev.command === 't' &&\n            // @ts-ignore\n            data[2] === prev.args[0] &&\n            // @ts-ignore\n            data[3] === prev.args[1]\n          ) {\n            command = 't';\n            data = data.slice(2);\n          }\n        }\n      }\n\n      // remove useless non-first path segments\n      if (params.removeUseless && !maybeHasStrokeAndLinecap) {\n        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n        if (\n          (command === 'l' ||\n            command === 'h' ||\n            command === 'v' ||\n            command === 'q' ||\n            command === 't' ||\n            command === 'c' ||\n            command === 's') &&\n          data.every(function (i) {\n            return i === 0;\n          })\n        ) {\n          // @ts-ignore\n          path[index] = prev;\n          return false;\n        }\n\n        // a 25,25 -30 0,1 0,0\n        if (command === 'a' && data[5] === 0 && data[6] === 0) {\n          // @ts-ignore\n          path[index] = prev;\n          return false;\n        }\n      }\n\n      item.command = command;\n      item.args = data;\n\n      prev = item;\n    } else {\n      // z resets coordinates\n      relSubpoint[0] = pathBase[0];\n      relSubpoint[1] = pathBase[1];\n      // @ts-ignore\n      if (prev.command === 'Z' || prev.command === 'z') return false;\n      prev = item;\n    }\n\n    return true;\n  });\n\n  return path;\n}\n\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @type {(path: PathDataItem[], params: InternalParams) => PathDataItem[]}\n */\nfunction convertToMixed(path, params) {\n  var prev = path[0];\n\n  path = path.filter(function (item, index) {\n    if (index == 0) return true;\n    if (item.command === 'Z' || item.command === 'z') {\n      prev = item;\n      return true;\n    }\n\n    var command = item.command,\n      data = item.args,\n      adata = data.slice();\n\n    if (\n      command === 'm' ||\n      command === 'l' ||\n      command === 't' ||\n      command === 'q' ||\n      command === 's' ||\n      command === 'c'\n    ) {\n      for (var i = adata.length; i--; ) {\n        // @ts-ignore\n        adata[i] += item.base[i % 2];\n      }\n    } else if (command == 'h') {\n      // @ts-ignore\n      adata[0] += item.base[0];\n    } else if (command == 'v') {\n      // @ts-ignore\n      adata[0] += item.base[1];\n    } else if (command == 'a') {\n      // @ts-ignore\n      adata[5] += item.base[0];\n      // @ts-ignore\n      adata[6] += item.base[1];\n    }\n\n    roundData(adata);\n\n    var absoluteDataStr = cleanupOutData(adata, params),\n      relativeDataStr = cleanupOutData(data, params);\n\n    // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.\n    // v-20 -> V0\n    // Don't convert if it fits following previous command.\n    // l20 30-10-50 instead of l20 30L20 30\n    if (\n      params.forceAbsolutePath ||\n      (absoluteDataStr.length < relativeDataStr.length &&\n        !(\n          params.negativeExtraSpace &&\n          command == prev.command &&\n          prev.command.charCodeAt(0) > 96 &&\n          absoluteDataStr.length == relativeDataStr.length - 1 &&\n          (data[0] < 0 ||\n            // @ts-ignore\n            (/^0\\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))\n        ))\n    ) {\n      // @ts-ignore\n      item.command = command.toUpperCase();\n      item.args = adata;\n    }\n\n    prev = item;\n\n    return true;\n  });\n\n  return path;\n}\n\n/**\n * Checks if curve is convex. Control points of such a curve must form\n * a convex quadrilateral with diagonals crosspoint inside of it.\n *\n * @type {(data: number[]) => boolean}\n */\nfunction isConvex(data) {\n  var center = getIntersection([\n    0,\n    0,\n    data[2],\n    data[3],\n    data[0],\n    data[1],\n    data[4],\n    data[5],\n  ]);\n\n  return (\n    center != null &&\n    data[2] < center[0] == center[0] < 0 &&\n    data[3] < center[1] == center[1] < 0 &&\n    data[4] < center[0] == center[0] < data[0] &&\n    data[5] < center[1] == center[1] < data[1]\n  );\n}\n\n/**\n * Computes lines equations by two points and returns their intersection point.\n *\n * @type {(coords: number[]) => undefined | Point}\n */\nfunction getIntersection(coords) {\n  // Prev line equation parameters.\n  var a1 = coords[1] - coords[3], // y1 - y2\n    b1 = coords[2] - coords[0], // x2 - x1\n    c1 = coords[0] * coords[3] - coords[2] * coords[1], // x1 * y2 - x2 * y1\n    // Next line equation parameters\n    a2 = coords[5] - coords[7], // y1 - y2\n    b2 = coords[6] - coords[4], // x2 - x1\n    c2 = coords[4] * coords[7] - coords[5] * coords[6], // x1 * y2 - x2 * y1\n    denom = a1 * b2 - a2 * b1;\n\n  if (!denom) return; // parallel lines havn't an intersection\n\n  /**\n   * @type {Point}\n   */\n  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];\n  if (\n    !isNaN(cross[0]) &&\n    !isNaN(cross[1]) &&\n    isFinite(cross[0]) &&\n    isFinite(cross[1])\n  ) {\n    return cross;\n  }\n}\n\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.3491 to 2.35 instead of 2.349.\n * Doesn't apply \"smartness\" if the number precision fits already.\n *\n * @type {(data: number[]) => number[]}\n */\nfunction strongRound(data) {\n  for (var i = data.length; i-- > 0; ) {\n    // @ts-ignore\n    if (data[i].toFixed(precision) != data[i]) {\n      // @ts-ignore\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] =\n        // @ts-ignore\n        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error\n          ? // @ts-ignore\n            +data[i].toFixed(precision)\n          : rounded;\n    }\n  }\n  return data;\n}\n\n/**\n * Simple rounding function if precision is 0.\n *\n * @type {(data: number[]) => number[]}\n */\nfunction round(data) {\n  for (var i = data.length; i-- > 0; ) {\n    data[i] = Math.round(data[i]);\n  }\n  return data;\n}\n\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @type {(data: number[]) => boolean}\n */\n\nfunction isCurveStraightLine(data) {\n  // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.\n  var i = data.length - 2,\n    a = -data[i + 1], // y1 − y2 (y1 = 0)\n    b = data[i], // x2 − x1 (x1 = 0)\n    d = 1 / (a * a + b * b); // same part for all points\n\n  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case\n\n  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n  while ((i -= 2) >= 0) {\n    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)\n      return false;\n  }\n\n  return true;\n}\n\n/**\n * Converts next curve from shorthand to full form using the current curve data.\n *\n * @type {(item: PathDataItem, data: number[]) => PathDataItem}\n */\n\nfunction makeLonghand(item, data) {\n  switch (item.command) {\n    case 's':\n      item.command = 'c';\n      break;\n    case 't':\n      item.command = 'q';\n      break;\n  }\n  item.args.unshift(\n    data[data.length - 2] - data[data.length - 4],\n    data[data.length - 1] - data[data.length - 3]\n  );\n  return item;\n}\n\n/**\n * Returns distance between two points\n *\n * @type {(point1: Point, point2: Point) => number}\n */\n\nfunction getDistance(point1, point2) {\n  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);\n}\n\n/**\n * Returns coordinates of the curve point corresponding to the certain t\n * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,\n * where pN are control points and p1 is zero due to relative coordinates.\n *\n * @type {(curve: number[], t: number) => Point}\n */\n\nfunction getCubicBezierPoint(curve, t) {\n  var sqrT = t * t,\n    cubT = sqrT * t,\n    mt = 1 - t,\n    sqrMt = mt * mt;\n\n  return [\n    3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],\n    3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5],\n  ];\n}\n\n/**\n * Finds circle by 3 points of the curve and checks if the curve fits the found circle.\n *\n * @type {(curve: number[]) => undefined | Circle}\n */\n\nfunction findCircle(curve) {\n  var midPoint = getCubicBezierPoint(curve, 1 / 2),\n    m1 = [midPoint[0] / 2, midPoint[1] / 2],\n    m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],\n    center = getIntersection([\n      m1[0],\n      m1[1],\n      m1[0] + m1[1],\n      m1[1] - m1[0],\n      m2[0],\n      m2[1],\n      m2[0] + (m2[1] - midPoint[1]),\n      m2[1] - (m2[0] - midPoint[0]),\n    ]),\n    radius = center && getDistance([0, 0], center),\n    // @ts-ignore\n    tolerance = Math.min(arcThreshold * error, (arcTolerance * radius) / 100);\n\n  if (\n    center &&\n    // @ts-ignore\n    radius < 1e15 &&\n    [1 / 4, 3 / 4].every(function (point) {\n      return (\n        Math.abs(\n          // @ts-ignore\n          getDistance(getCubicBezierPoint(curve, point), center) - radius\n        ) <= tolerance\n      );\n    })\n  )\n    // @ts-ignore\n    return { center: center, radius: radius };\n}\n\n/**\n * Checks if a curve fits the given circle.\n *\n * @type {(curve: number[], circle: Circle) => boolean}\n */\n\nfunction isArc(curve, circle) {\n  var tolerance = Math.min(\n    arcThreshold * error,\n    (arcTolerance * circle.radius) / 100\n  );\n\n  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {\n    return (\n      Math.abs(\n        getDistance(getCubicBezierPoint(curve, point), circle.center) -\n          circle.radius\n      ) <= tolerance\n    );\n  });\n}\n\n/**\n * Checks if a previous curve fits the given circle.\n *\n * @type {(curve: number[], circle: Circle) => boolean}\n */\n\nfunction isArcPrev(curve, circle) {\n  return isArc(curve, {\n    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],\n    radius: circle.radius,\n  });\n}\n\n/**\n * Finds angle of a curve fitting the given arc.\n\n * @type {(curve: number[], relCircle: Circle) => number}\n */\n\nfunction findArcAngle(curve, relCircle) {\n  var x1 = -relCircle.center[0],\n    y1 = -relCircle.center[1],\n    x2 = curve[4] - relCircle.center[0],\n    y2 = curve[5] - relCircle.center[1];\n\n  return Math.acos(\n    (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n  );\n}\n\n/**\n * Converts given path data to string.\n *\n * @type {(params: InternalParams, pathData: PathDataItem[]) => string}\n */\n\nfunction data2Path(params, pathData) {\n  return pathData.reduce(function (pathString, item) {\n    var strData = '';\n    if (item.args) {\n      strData = cleanupOutData(roundData(item.args.slice()), params);\n    }\n    return pathString + item.command + strData;\n  }, '');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}