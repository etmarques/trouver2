{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\nconst {\n  stringifyPathData\n} = require('../lib/path.js');\nconst {\n  detachNodeFromParent\n} = require('../lib/xast.js');\nexports.name = 'convertShapeToPath';\nexports.description = 'converts basic shapes to more compact path form';\nconst regNumber = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Converts basic shape to more compact path.\n * It also allows further optimizations like\n * combining paths with similar attributes.\n *\n * @see https://www.w3.org/TR/SVG11/shapes.html\n *\n * @author Lev Solntsev\n *\n * @type {import('./plugins-types').Plugin<'convertShapeToPath'>}\n */\nexports.fn = (root, params) => {\n  const {\n    convertArcs = false,\n    floatPrecision: precision\n  } = params;\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // convert rect to path\n        if (node.name === 'rect' && node.attributes.width != null && node.attributes.height != null && node.attributes.rx == null && node.attributes.ry == null) {\n          const x = Number(node.attributes.x || '0');\n          const y = Number(node.attributes.y || '0');\n          const width = Number(node.attributes.width);\n          const height = Number(node.attributes.height);\n          // Values like '100%' compute to NaN, thus running after\n          // cleanupNumericValues when 'px' units has already been removed.\n          // TODO: Calculate sizes from % and non-px units if possible.\n          if (Number.isNaN(x - y + width - height)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [{\n            command: 'M',\n            args: [x, y]\n          }, {\n            command: 'H',\n            args: [x + width]\n          }, {\n            command: 'V',\n            args: [y + height]\n          }, {\n            command: 'H',\n            args: [x]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.x;\n          delete node.attributes.y;\n          delete node.attributes.width;\n          delete node.attributes.height;\n        }\n\n        // convert line to path\n        if (node.name === 'line') {\n          const x1 = Number(node.attributes.x1 || '0');\n          const y1 = Number(node.attributes.y1 || '0');\n          const x2 = Number(node.attributes.x2 || '0');\n          const y2 = Number(node.attributes.y2 || '0');\n          if (Number.isNaN(x1 - y1 + x2 - y2)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [{\n            command: 'M',\n            args: [x1, y1]\n          }, {\n            command: 'L',\n            args: [x2, y2]\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.x1;\n          delete node.attributes.y1;\n          delete node.attributes.x2;\n          delete node.attributes.y2;\n        }\n\n        // convert polyline and polygon to path\n        if ((node.name === 'polyline' || node.name === 'polygon') && node.attributes.points != null) {\n          const coords = (node.attributes.points.match(regNumber) || []).map(Number);\n          if (coords.length < 4) {\n            detachNodeFromParent(node, parentNode);\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [];\n          for (let i = 0; i < coords.length; i += 2) {\n            pathData.push({\n              command: i === 0 ? 'M' : 'L',\n              args: coords.slice(i, i + 2)\n            });\n          }\n          if (node.name === 'polygon') {\n            pathData.push({\n              command: 'z',\n              args: []\n            });\n          }\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.points;\n        }\n\n        //  optionally convert circle\n        if (node.name === 'circle' && convertArcs) {\n          const cx = Number(node.attributes.cx || '0');\n          const cy = Number(node.attributes.cy || '0');\n          const r = Number(node.attributes.r || '0');\n          if (Number.isNaN(cx - cy + r)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [{\n            command: 'M',\n            args: [cx, cy - r]\n          }, {\n            command: 'A',\n            args: [r, r, 0, 1, 0, cx, cy + r]\n          }, {\n            command: 'A',\n            args: [r, r, 0, 1, 0, cx, cy - r]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.r;\n        }\n\n        // optionally covert ellipse\n        if (node.name === 'ellipse' && convertArcs) {\n          const ecx = Number(node.attributes.cx || '0');\n          const ecy = Number(node.attributes.cy || '0');\n          const rx = Number(node.attributes.rx || '0');\n          const ry = Number(node.attributes.ry || '0');\n          if (Number.isNaN(ecx - ecy + rx - ry)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [{\n            command: 'M',\n            args: [ecx, ecy - ry]\n          }, {\n            command: 'A',\n            args: [rx, ry, 0, 1, 0, ecx, ecy + ry]\n          }, {\n            command: 'A',\n            args: [rx, ry, 0, 1, 0, ecx, ecy - ry]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.rx;\n          delete node.attributes.ry;\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["stringifyPathData","require","detachNodeFromParent","exports","name","description","regNumber","fn","root","params","convertArcs","floatPrecision","precision","element","enter","node","parentNode","attributes","width","height","rx","ry","x","Number","y","isNaN","pathData","command","args","d","x1","y1","x2","y2","points","coords","match","map","length","i","push","slice","cx","cy","r","ecx","ecy"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/convertShapeToPath.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { stringifyPathData } = require('../lib/path.js');\nconst { detachNodeFromParent } = require('../lib/xast.js');\n\nexports.name = 'convertShapeToPath';\nexports.description = 'converts basic shapes to more compact path form';\n\nconst regNumber = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Converts basic shape to more compact path.\n * It also allows further optimizations like\n * combining paths with similar attributes.\n *\n * @see https://www.w3.org/TR/SVG11/shapes.html\n *\n * @author Lev Solntsev\n *\n * @type {import('./plugins-types').Plugin<'convertShapeToPath'>}\n */\nexports.fn = (root, params) => {\n  const { convertArcs = false, floatPrecision: precision } = params;\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // convert rect to path\n        if (\n          node.name === 'rect' &&\n          node.attributes.width != null &&\n          node.attributes.height != null &&\n          node.attributes.rx == null &&\n          node.attributes.ry == null\n        ) {\n          const x = Number(node.attributes.x || '0');\n          const y = Number(node.attributes.y || '0');\n          const width = Number(node.attributes.width);\n          const height = Number(node.attributes.height);\n          // Values like '100%' compute to NaN, thus running after\n          // cleanupNumericValues when 'px' units has already been removed.\n          // TODO: Calculate sizes from % and non-px units if possible.\n          if (Number.isNaN(x - y + width - height)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [x, y] },\n            { command: 'H', args: [x + width] },\n            { command: 'V', args: [y + height] },\n            { command: 'H', args: [x] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.x;\n          delete node.attributes.y;\n          delete node.attributes.width;\n          delete node.attributes.height;\n        }\n\n        // convert line to path\n        if (node.name === 'line') {\n          const x1 = Number(node.attributes.x1 || '0');\n          const y1 = Number(node.attributes.y1 || '0');\n          const x2 = Number(node.attributes.x2 || '0');\n          const y2 = Number(node.attributes.y2 || '0');\n          if (Number.isNaN(x1 - y1 + x2 - y2)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [x1, y1] },\n            { command: 'L', args: [x2, y2] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.x1;\n          delete node.attributes.y1;\n          delete node.attributes.x2;\n          delete node.attributes.y2;\n        }\n\n        // convert polyline and polygon to path\n        if (\n          (node.name === 'polyline' || node.name === 'polygon') &&\n          node.attributes.points != null\n        ) {\n          const coords = (node.attributes.points.match(regNumber) || []).map(\n            Number\n          );\n          if (coords.length < 4) {\n            detachNodeFromParent(node, parentNode);\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [];\n          for (let i = 0; i < coords.length; i += 2) {\n            pathData.push({\n              command: i === 0 ? 'M' : 'L',\n              args: coords.slice(i, i + 2),\n            });\n          }\n          if (node.name === 'polygon') {\n            pathData.push({ command: 'z', args: [] });\n          }\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.points;\n        }\n\n        //  optionally convert circle\n        if (node.name === 'circle' && convertArcs) {\n          const cx = Number(node.attributes.cx || '0');\n          const cy = Number(node.attributes.cy || '0');\n          const r = Number(node.attributes.r || '0');\n          if (Number.isNaN(cx - cy + r)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [cx, cy - r] },\n            { command: 'A', args: [r, r, 0, 1, 0, cx, cy + r] },\n            { command: 'A', args: [r, r, 0, 1, 0, cx, cy - r] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.r;\n        }\n\n        // optionally covert ellipse\n        if (node.name === 'ellipse' && convertArcs) {\n          const ecx = Number(node.attributes.cx || '0');\n          const ecy = Number(node.attributes.cy || '0');\n          const rx = Number(node.attributes.rx || '0');\n          const ry = Number(node.attributes.ry || '0');\n          if (Number.isNaN(ecx - ecy + rx - ry)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [ecx, ecy - ry] },\n            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },\n            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.rx;\n          delete node.attributes.ry;\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}