{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _utils = require(\"../utils\");\nvar _default = callProvider => {\n  function property(object, key, placement, path) {\n    return callProvider({\n      kind: \"property\",\n      object,\n      key,\n      placement\n    }, path);\n  }\n  return {\n    // Symbol(), new Promise\n    ReferencedIdentifier(path) {\n      const {\n        node: {\n          name\n        },\n        scope\n      } = path;\n      if (scope.getBindingIdentifier(name)) return;\n      callProvider({\n        kind: \"global\",\n        name\n      }, path);\n    },\n    MemberExpression(path) {\n      const key = (0, _utils.resolveKey)(path.get(\"property\"), path.node.computed);\n      if (!key || key === \"prototype\") return;\n      const object = path.get(\"object\");\n      if (object.isIdentifier()) {\n        const binding = object.scope.getBinding(object.node.name);\n        if (binding && binding.path.isImportNamespaceSpecifier()) return;\n      }\n      const source = (0, _utils.resolveSource)(object);\n      return property(source.id, key, source.placement, path);\n    },\n    ObjectPattern(path) {\n      const {\n        parentPath,\n        parent\n      } = path;\n      let obj; // const { keys, values } = Object\n\n      if (parentPath.isVariableDeclarator()) {\n        obj = parentPath.get(\"init\"); // ({ keys, values } = Object)\n      } else if (parentPath.isAssignmentExpression()) {\n        obj = parentPath.get(\"right\"); // !function ({ keys, values }) {...} (Object)\n        // resolution does not work after properties transform :-(\n      } else if (parentPath.isFunction()) {\n        const grand = parentPath.parentPath;\n        if (grand.isCallExpression() || grand.isNewExpression()) {\n          if (grand.node.callee === parent) {\n            obj = grand.get(\"arguments\")[path.key];\n          }\n        }\n      }\n      let id = null;\n      let placement = null;\n      if (obj) ({\n        id,\n        placement\n      } = (0, _utils.resolveSource)(obj));\n      for (const prop of path.get(\"properties\")) {\n        if (prop.isObjectProperty()) {\n          const key = (0, _utils.resolveKey)(prop.get(\"key\"));\n          if (key) property(id, key, placement, prop);\n        }\n      }\n    },\n    BinaryExpression(path) {\n      if (path.node.operator !== \"in\") return;\n      const source = (0, _utils.resolveSource)(path.get(\"right\"));\n      const key = (0, _utils.resolveKey)(path.get(\"left\"), true);\n      if (!key) return;\n      callProvider({\n        kind: \"in\",\n        object: source.id,\n        key,\n        placement: source.placement\n      }, path);\n    }\n  };\n};\nexports.default = _default;","map":{"version":3,"names":["exports","__esModule","default","_utils","require","_default","callProvider","property","object","key","placement","path","kind","ReferencedIdentifier","node","name","scope","getBindingIdentifier","MemberExpression","resolveKey","get","computed","isIdentifier","binding","getBinding","isImportNamespaceSpecifier","source","resolveSource","id","ObjectPattern","parentPath","parent","obj","isVariableDeclarator","isAssignmentExpression","isFunction","grand","isCallExpression","isNewExpression","callee","prop","isObjectProperty","BinaryExpression","operator"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/@babel/helper-define-polyfill-provider/lib/visitors/usage.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _utils = require(\"../utils\");\n\nvar _default = callProvider => {\n  function property(object, key, placement, path) {\n    return callProvider({\n      kind: \"property\",\n      object,\n      key,\n      placement\n    }, path);\n  }\n\n  return {\n    // Symbol(), new Promise\n    ReferencedIdentifier(path) {\n      const {\n        node: {\n          name\n        },\n        scope\n      } = path;\n      if (scope.getBindingIdentifier(name)) return;\n      callProvider({\n        kind: \"global\",\n        name\n      }, path);\n    },\n\n    MemberExpression(path) {\n      const key = (0, _utils.resolveKey)(path.get(\"property\"), path.node.computed);\n      if (!key || key === \"prototype\") return;\n      const object = path.get(\"object\");\n\n      if (object.isIdentifier()) {\n        const binding = object.scope.getBinding(object.node.name);\n        if (binding && binding.path.isImportNamespaceSpecifier()) return;\n      }\n\n      const source = (0, _utils.resolveSource)(object);\n      return property(source.id, key, source.placement, path);\n    },\n\n    ObjectPattern(path) {\n      const {\n        parentPath,\n        parent\n      } = path;\n      let obj; // const { keys, values } = Object\n\n      if (parentPath.isVariableDeclarator()) {\n        obj = parentPath.get(\"init\"); // ({ keys, values } = Object)\n      } else if (parentPath.isAssignmentExpression()) {\n        obj = parentPath.get(\"right\"); // !function ({ keys, values }) {...} (Object)\n        // resolution does not work after properties transform :-(\n      } else if (parentPath.isFunction()) {\n        const grand = parentPath.parentPath;\n\n        if (grand.isCallExpression() || grand.isNewExpression()) {\n          if (grand.node.callee === parent) {\n            obj = grand.get(\"arguments\")[path.key];\n          }\n        }\n      }\n\n      let id = null;\n      let placement = null;\n      if (obj) ({\n        id,\n        placement\n      } = (0, _utils.resolveSource)(obj));\n\n      for (const prop of path.get(\"properties\")) {\n        if (prop.isObjectProperty()) {\n          const key = (0, _utils.resolveKey)(prop.get(\"key\"));\n          if (key) property(id, key, placement, prop);\n        }\n      }\n    },\n\n    BinaryExpression(path) {\n      if (path.node.operator !== \"in\") return;\n      const source = (0, _utils.resolveSource)(path.get(\"right\"));\n      const key = (0, _utils.resolveKey)(path.get(\"left\"), true);\n      if (!key) return;\n      callProvider({\n        kind: \"in\",\n        object: source.id,\n        key,\n        placement: source.placement\n      }, path);\n    }\n\n  };\n};\n\nexports.default = _default;"],"mappings":"AAAA,YAAY;;AAEZA,OAAO,CAACC,UAAU,GAAG,IAAI;AACzBD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AAExB,IAAIC,MAAM,GAAGC,OAAO,CAAC,UAAU,CAAC;AAEhC,IAAIC,QAAQ,GAAGC,YAAY,IAAI;EAC7B,SAASC,QAAQA,CAACC,MAAM,EAAEC,GAAG,EAAEC,SAAS,EAAEC,IAAI,EAAE;IAC9C,OAAOL,YAAY,CAAC;MAClBM,IAAI,EAAE,UAAU;MAChBJ,MAAM;MACNC,GAAG;MACHC;IACF,CAAC,EAAEC,IAAI,CAAC;EACV;EAEA,OAAO;IACL;IACAE,oBAAoBA,CAACF,IAAI,EAAE;MACzB,MAAM;QACJG,IAAI,EAAE;UACJC;QACF,CAAC;QACDC;MACF,CAAC,GAAGL,IAAI;MACR,IAAIK,KAAK,CAACC,oBAAoB,CAACF,IAAI,CAAC,EAAE;MACtCT,YAAY,CAAC;QACXM,IAAI,EAAE,QAAQ;QACdG;MACF,CAAC,EAAEJ,IAAI,CAAC;IACV,CAAC;IAEDO,gBAAgBA,CAACP,IAAI,EAAE;MACrB,MAAMF,GAAG,GAAG,CAAC,CAAC,EAAEN,MAAM,CAACgB,UAAU,EAAER,IAAI,CAACS,GAAG,CAAC,UAAU,CAAC,EAAET,IAAI,CAACG,IAAI,CAACO,QAAQ,CAAC;MAC5E,IAAI,CAACZ,GAAG,IAAIA,GAAG,KAAK,WAAW,EAAE;MACjC,MAAMD,MAAM,GAAGG,IAAI,CAACS,GAAG,CAAC,QAAQ,CAAC;MAEjC,IAAIZ,MAAM,CAACc,YAAY,CAAC,CAAC,EAAE;QACzB,MAAMC,OAAO,GAAGf,MAAM,CAACQ,KAAK,CAACQ,UAAU,CAAChB,MAAM,CAACM,IAAI,CAACC,IAAI,CAAC;QACzD,IAAIQ,OAAO,IAAIA,OAAO,CAACZ,IAAI,CAACc,0BAA0B,CAAC,CAAC,EAAE;MAC5D;MAEA,MAAMC,MAAM,GAAG,CAAC,CAAC,EAAEvB,MAAM,CAACwB,aAAa,EAAEnB,MAAM,CAAC;MAChD,OAAOD,QAAQ,CAACmB,MAAM,CAACE,EAAE,EAAEnB,GAAG,EAAEiB,MAAM,CAAChB,SAAS,EAAEC,IAAI,CAAC;IACzD,CAAC;IAEDkB,aAAaA,CAAClB,IAAI,EAAE;MAClB,MAAM;QACJmB,UAAU;QACVC;MACF,CAAC,GAAGpB,IAAI;MACR,IAAIqB,GAAG,CAAC,CAAC;;MAET,IAAIF,UAAU,CAACG,oBAAoB,CAAC,CAAC,EAAE;QACrCD,GAAG,GAAGF,UAAU,CAACV,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;MAChC,CAAC,MAAM,IAAIU,UAAU,CAACI,sBAAsB,CAAC,CAAC,EAAE;QAC9CF,GAAG,GAAGF,UAAU,CAACV,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;QAC/B;MACF,CAAC,MAAM,IAAIU,UAAU,CAACK,UAAU,CAAC,CAAC,EAAE;QAClC,MAAMC,KAAK,GAAGN,UAAU,CAACA,UAAU;QAEnC,IAAIM,KAAK,CAACC,gBAAgB,CAAC,CAAC,IAAID,KAAK,CAACE,eAAe,CAAC,CAAC,EAAE;UACvD,IAAIF,KAAK,CAACtB,IAAI,CAACyB,MAAM,KAAKR,MAAM,EAAE;YAChCC,GAAG,GAAGI,KAAK,CAAChB,GAAG,CAAC,WAAW,CAAC,CAACT,IAAI,CAACF,GAAG,CAAC;UACxC;QACF;MACF;MAEA,IAAImB,EAAE,GAAG,IAAI;MACb,IAAIlB,SAAS,GAAG,IAAI;MACpB,IAAIsB,GAAG,EAAE,CAAC;QACRJ,EAAE;QACFlB;MACF,CAAC,GAAG,CAAC,CAAC,EAAEP,MAAM,CAACwB,aAAa,EAAEK,GAAG,CAAC;MAElC,KAAK,MAAMQ,IAAI,IAAI7B,IAAI,CAACS,GAAG,CAAC,YAAY,CAAC,EAAE;QACzC,IAAIoB,IAAI,CAACC,gBAAgB,CAAC,CAAC,EAAE;UAC3B,MAAMhC,GAAG,GAAG,CAAC,CAAC,EAAEN,MAAM,CAACgB,UAAU,EAAEqB,IAAI,CAACpB,GAAG,CAAC,KAAK,CAAC,CAAC;UACnD,IAAIX,GAAG,EAAEF,QAAQ,CAACqB,EAAE,EAAEnB,GAAG,EAAEC,SAAS,EAAE8B,IAAI,CAAC;QAC7C;MACF;IACF,CAAC;IAEDE,gBAAgBA,CAAC/B,IAAI,EAAE;MACrB,IAAIA,IAAI,CAACG,IAAI,CAAC6B,QAAQ,KAAK,IAAI,EAAE;MACjC,MAAMjB,MAAM,GAAG,CAAC,CAAC,EAAEvB,MAAM,CAACwB,aAAa,EAAEhB,IAAI,CAACS,GAAG,CAAC,OAAO,CAAC,CAAC;MAC3D,MAAMX,GAAG,GAAG,CAAC,CAAC,EAAEN,MAAM,CAACgB,UAAU,EAAER,IAAI,CAACS,GAAG,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC;MAC1D,IAAI,CAACX,GAAG,EAAE;MACVH,YAAY,CAAC;QACXM,IAAI,EAAE,IAAI;QACVJ,MAAM,EAAEkB,MAAM,CAACE,EAAE;QACjBnB,GAAG;QACHC,SAAS,EAAEgB,MAAM,CAAChB;MACpB,CAAC,EAAEC,IAAI,CAAC;IACV;EAEF,CAAC;AACH,CAAC;AAEDX,OAAO,CAACE,OAAO,GAAGG,QAAQ"},"metadata":{},"sourceType":"script","externalDependencies":[]}