{"ast":null,"code":"'use strict';\n\nexports.name = 'sortAttrs';\nexports.description = 'Sort element attributes for better compression';\n\n/**\n * Sort element attributes for better compression\n *\n * @author Nikolay Frantsev\n *\n * @type {import('./plugins-types').Plugin<'sortAttrs'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    order = ['id', 'width', 'height', 'x', 'x1', 'x2', 'y', 'y1', 'y2', 'cx', 'cy', 'r', 'fill', 'stroke', 'marker', 'd', 'points'],\n    xmlnsOrder = 'front'\n  } = params;\n\n  /**\n   * @type {(name: string) => number}\n   */\n  const getNsPriority = name => {\n    if (xmlnsOrder === 'front') {\n      // put xmlns first\n      if (name === 'xmlns') {\n        return 3;\n      }\n      // xmlns:* attributes second\n      if (name.startsWith('xmlns:')) {\n        return 2;\n      }\n    }\n    // other namespaces after and sort them alphabetically\n    if (name.includes(':')) {\n      return 1;\n    }\n    // other attributes\n    return 0;\n  };\n\n  /**\n   * @type {(a: [string, string], b: [string, string]) => number}\n   */\n  const compareAttrs = (_ref, _ref2) => {\n    let [aName] = _ref;\n    let [bName] = _ref2;\n    // sort namespaces\n    const aPriority = getNsPriority(aName);\n    const bPriority = getNsPriority(bName);\n    const priorityNs = bPriority - aPriority;\n    if (priorityNs !== 0) {\n      return priorityNs;\n    }\n    // extract the first part from attributes\n    // for example \"fill\" from \"fill\" and \"fill-opacity\"\n    const [aPart] = aName.split('-');\n    const [bPart] = bName.split('-');\n    // rely on alphabetical sort when the first part is the same\n    if (aPart !== bPart) {\n      const aInOrderFlag = order.includes(aPart) ? 1 : 0;\n      const bInOrderFlag = order.includes(bPart) ? 1 : 0;\n      // sort by position in order param\n      if (aInOrderFlag === 1 && bInOrderFlag === 1) {\n        return order.indexOf(aPart) - order.indexOf(bPart);\n      }\n      // put attributes from order param before others\n      const priorityOrder = bInOrderFlag - aInOrderFlag;\n      if (priorityOrder !== 0) {\n        return priorityOrder;\n      }\n    }\n    // sort alphabetically\n    return aName < bName ? -1 : 1;\n  };\n  return {\n    element: {\n      enter: node => {\n        const attrs = Object.entries(node.attributes);\n        attrs.sort(compareAttrs);\n        /**\n         * @type {Record<string, string>}\n         */\n        const sortedAttributes = {};\n        for (const [name, value] of attrs) {\n          sortedAttributes[name] = value;\n        }\n        node.attributes = sortedAttributes;\n      }\n    }\n  };\n};","map":{"version":3,"names":["exports","name","description","fn","_root","params","order","xmlnsOrder","getNsPriority","startsWith","includes","compareAttrs","_ref","_ref2","aName","bName","aPriority","bPriority","priorityNs","aPart","split","bPart","aInOrderFlag","bInOrderFlag","indexOf","priorityOrder","element","enter","node","attrs","Object","entries","attributes","sort","sortedAttributes","value"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/sortAttrs.js"],"sourcesContent":["'use strict';\n\nexports.name = 'sortAttrs';\nexports.description = 'Sort element attributes for better compression';\n\n/**\n * Sort element attributes for better compression\n *\n * @author Nikolay Frantsev\n *\n * @type {import('./plugins-types').Plugin<'sortAttrs'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    order = [\n      'id',\n      'width',\n      'height',\n      'x',\n      'x1',\n      'x2',\n      'y',\n      'y1',\n      'y2',\n      'cx',\n      'cy',\n      'r',\n      'fill',\n      'stroke',\n      'marker',\n      'd',\n      'points',\n    ],\n    xmlnsOrder = 'front',\n  } = params;\n\n  /**\n   * @type {(name: string) => number}\n   */\n  const getNsPriority = (name) => {\n    if (xmlnsOrder === 'front') {\n      // put xmlns first\n      if (name === 'xmlns') {\n        return 3;\n      }\n      // xmlns:* attributes second\n      if (name.startsWith('xmlns:')) {\n        return 2;\n      }\n    }\n    // other namespaces after and sort them alphabetically\n    if (name.includes(':')) {\n      return 1;\n    }\n    // other attributes\n    return 0;\n  };\n\n  /**\n   * @type {(a: [string, string], b: [string, string]) => number}\n   */\n  const compareAttrs = ([aName], [bName]) => {\n    // sort namespaces\n    const aPriority = getNsPriority(aName);\n    const bPriority = getNsPriority(bName);\n    const priorityNs = bPriority - aPriority;\n    if (priorityNs !== 0) {\n      return priorityNs;\n    }\n    // extract the first part from attributes\n    // for example \"fill\" from \"fill\" and \"fill-opacity\"\n    const [aPart] = aName.split('-');\n    const [bPart] = bName.split('-');\n    // rely on alphabetical sort when the first part is the same\n    if (aPart !== bPart) {\n      const aInOrderFlag = order.includes(aPart) ? 1 : 0;\n      const bInOrderFlag = order.includes(bPart) ? 1 : 0;\n      // sort by position in order param\n      if (aInOrderFlag === 1 && bInOrderFlag === 1) {\n        return order.indexOf(aPart) - order.indexOf(bPart);\n      }\n      // put attributes from order param before others\n      const priorityOrder = bInOrderFlag - aInOrderFlag;\n      if (priorityOrder !== 0) {\n        return priorityOrder;\n      }\n    }\n    // sort alphabetically\n    return aName < bName ? -1 : 1;\n  };\n\n  return {\n    element: {\n      enter: (node) => {\n        const attrs = Object.entries(node.attributes);\n        attrs.sort(compareAttrs);\n        /**\n         * @type {Record<string, string>}\n         */\n        const sortedAttributes = {};\n        for (const [name, value] of attrs) {\n          sortedAttributes[name] = value;\n        }\n        node.attributes = sortedAttributes;\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}