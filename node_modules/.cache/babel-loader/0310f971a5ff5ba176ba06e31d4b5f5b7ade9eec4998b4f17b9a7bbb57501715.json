{"ast":null,"code":"'use strict';\n\nconst {\n  visit,\n  visitSkip,\n  detachNodeFromParent\n} = require('../lib/xast.js');\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\nconst {\n  elemsGroups\n} = require('./_collections.js');\nexports.name = 'removeUselessStrokeAndFill';\nexports.description = 'removes useless stroke and fill attributes';\n\n/**\n * Remove useless stroke and fill attrs.\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'removeUselessStrokeAndFill'>}\n */\nexports.fn = (root, params) => {\n  const {\n    stroke: removeStroke = true,\n    fill: removeFill = true,\n    removeNone = false\n  } = params;\n\n  // style and script elements deoptimise this plugin\n  let hasStyleOrScript = false;\n  visit(root, {\n    element: {\n      enter: node => {\n        if (node.name === 'style' || node.name === 'script') {\n          hasStyleOrScript = true;\n        }\n      }\n    }\n  });\n  if (hasStyleOrScript) {\n    return null;\n  }\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // id attribute deoptimise the whole subtree\n        if (node.attributes.id != null) {\n          return visitSkip;\n        }\n        if (elemsGroups.shape.includes(node.name) == false) {\n          return;\n        }\n        const computedStyle = computeStyle(stylesheet, node);\n        const stroke = computedStyle.stroke;\n        const strokeOpacity = computedStyle['stroke-opacity'];\n        const strokeWidth = computedStyle['stroke-width'];\n        const markerEnd = computedStyle['marker-end'];\n        const fill = computedStyle.fill;\n        const fillOpacity = computedStyle['fill-opacity'];\n        const computedParentStyle = parentNode.type === 'element' ? computeStyle(stylesheet, parentNode) : null;\n        const parentStroke = computedParentStyle == null ? null : computedParentStyle.stroke;\n\n        // remove stroke*\n        if (removeStroke) {\n          if (stroke == null || stroke.type === 'static' && stroke.value == 'none' || strokeOpacity != null && strokeOpacity.type === 'static' && strokeOpacity.value === '0' || strokeWidth != null && strokeWidth.type === 'static' && strokeWidth.value === '0') {\n            // stroke-width may affect the size of marker-end\n            // marker is not visible when stroke-width is 0\n            if (strokeWidth != null && strokeWidth.type === 'static' && strokeWidth.value === '0' || markerEnd == null) {\n              for (const name of Object.keys(node.attributes)) {\n                if (name.startsWith('stroke')) {\n                  delete node.attributes[name];\n                }\n              }\n              // set explicit none to not inherit from parent\n              if (parentStroke != null && parentStroke.type === 'static' && parentStroke.value !== 'none') {\n                node.attributes.stroke = 'none';\n              }\n            }\n          }\n        }\n\n        // remove fill*\n        if (removeFill) {\n          if (fill != null && fill.type === 'static' && fill.value === 'none' || fillOpacity != null && fillOpacity.type === 'static' && fillOpacity.value === '0') {\n            for (const name of Object.keys(node.attributes)) {\n              if (name.startsWith('fill-')) {\n                delete node.attributes[name];\n              }\n            }\n            if (fill == null || fill.type === 'static' && fill.value !== 'none') {\n              node.attributes.fill = 'none';\n            }\n          }\n        }\n        if (removeNone) {\n          if ((stroke == null || node.attributes.stroke === 'none') && (fill != null && fill.type === 'static' && fill.value === 'none' || node.attributes.fill === 'none')) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["visit","visitSkip","detachNodeFromParent","require","collectStylesheet","computeStyle","elemsGroups","exports","name","description","fn","root","params","stroke","removeStroke","fill","removeFill","removeNone","hasStyleOrScript","element","enter","node","stylesheet","parentNode","attributes","id","shape","includes","computedStyle","strokeOpacity","strokeWidth","markerEnd","fillOpacity","computedParentStyle","type","parentStroke","value","Object","keys","startsWith"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/removeUselessStrokeAndFill.js"],"sourcesContent":["'use strict';\n\nconst { visit, visitSkip, detachNodeFromParent } = require('../lib/xast.js');\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst { elemsGroups } = require('./_collections.js');\n\nexports.name = 'removeUselessStrokeAndFill';\nexports.description = 'removes useless stroke and fill attributes';\n\n/**\n * Remove useless stroke and fill attrs.\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'removeUselessStrokeAndFill'>}\n */\nexports.fn = (root, params) => {\n  const {\n    stroke: removeStroke = true,\n    fill: removeFill = true,\n    removeNone = false,\n  } = params;\n\n  // style and script elements deoptimise this plugin\n  let hasStyleOrScript = false;\n  visit(root, {\n    element: {\n      enter: (node) => {\n        if (node.name === 'style' || node.name === 'script') {\n          hasStyleOrScript = true;\n        }\n      },\n    },\n  });\n  if (hasStyleOrScript) {\n    return null;\n  }\n\n  const stylesheet = collectStylesheet(root);\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // id attribute deoptimise the whole subtree\n        if (node.attributes.id != null) {\n          return visitSkip;\n        }\n        if (elemsGroups.shape.includes(node.name) == false) {\n          return;\n        }\n        const computedStyle = computeStyle(stylesheet, node);\n        const stroke = computedStyle.stroke;\n        const strokeOpacity = computedStyle['stroke-opacity'];\n        const strokeWidth = computedStyle['stroke-width'];\n        const markerEnd = computedStyle['marker-end'];\n        const fill = computedStyle.fill;\n        const fillOpacity = computedStyle['fill-opacity'];\n        const computedParentStyle =\n          parentNode.type === 'element'\n            ? computeStyle(stylesheet, parentNode)\n            : null;\n        const parentStroke =\n          computedParentStyle == null ? null : computedParentStyle.stroke;\n\n        // remove stroke*\n        if (removeStroke) {\n          if (\n            stroke == null ||\n            (stroke.type === 'static' && stroke.value == 'none') ||\n            (strokeOpacity != null &&\n              strokeOpacity.type === 'static' &&\n              strokeOpacity.value === '0') ||\n            (strokeWidth != null &&\n              strokeWidth.type === 'static' &&\n              strokeWidth.value === '0')\n          ) {\n            // stroke-width may affect the size of marker-end\n            // marker is not visible when stroke-width is 0\n            if (\n              (strokeWidth != null &&\n                strokeWidth.type === 'static' &&\n                strokeWidth.value === '0') ||\n              markerEnd == null\n            ) {\n              for (const name of Object.keys(node.attributes)) {\n                if (name.startsWith('stroke')) {\n                  delete node.attributes[name];\n                }\n              }\n              // set explicit none to not inherit from parent\n              if (\n                parentStroke != null &&\n                parentStroke.type === 'static' &&\n                parentStroke.value !== 'none'\n              ) {\n                node.attributes.stroke = 'none';\n              }\n            }\n          }\n        }\n\n        // remove fill*\n        if (removeFill) {\n          if (\n            (fill != null && fill.type === 'static' && fill.value === 'none') ||\n            (fillOpacity != null &&\n              fillOpacity.type === 'static' &&\n              fillOpacity.value === '0')\n          ) {\n            for (const name of Object.keys(node.attributes)) {\n              if (name.startsWith('fill-')) {\n                delete node.attributes[name];\n              }\n            }\n            if (\n              fill == null ||\n              (fill.type === 'static' && fill.value !== 'none')\n            ) {\n              node.attributes.fill = 'none';\n            }\n          }\n        }\n\n        if (removeNone) {\n          if (\n            (stroke == null || node.attributes.stroke === 'none') &&\n            ((fill != null &&\n              fill.type === 'static' &&\n              fill.value === 'none') ||\n              node.attributes.fill === 'none')\n          ) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}