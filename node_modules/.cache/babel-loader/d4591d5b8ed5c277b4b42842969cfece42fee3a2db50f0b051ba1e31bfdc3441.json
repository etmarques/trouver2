{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileEnum;\nexports.translateEnumValues = translateEnumValues;\nvar _core = require(\"@babel/core\");\nvar _assert = require(\"assert\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nconst ENUMS = new WeakMap();\nconst buildEnumWrapper = _core.template.expression(`\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  `);\nfunction transpileEnum(path, t) {\n  const {\n    node,\n    parentPath\n  } = path;\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n  const name = node.id.name;\n  const {\n    fill,\n    data,\n    isPure\n  } = enumFill(path, t, node.id);\n  switch (parentPath.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\":\n      {\n        const isGlobal = t.isProgram(path.parent);\n        const isSeen = seen(parentPath);\n        let init = t.objectExpression([]);\n        if (isSeen || isGlobal) {\n          init = t.logicalExpression(\"||\", t.cloneNode(fill.ID), init);\n        }\n        const enumIIFE = buildEnumWrapper(Object.assign({}, fill, {\n          INIT: init\n        }));\n        if (isPure) (0, _helperAnnotateAsPure.default)(enumIIFE);\n        if (isSeen) {\n          const toReplace = parentPath.isExportDeclaration() ? parentPath : path;\n          toReplace.replaceWith(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(node.id), enumIIFE)));\n        } else {\n          path.scope.registerDeclaration(path.replaceWith(t.variableDeclaration(isGlobal ? \"var\" : \"let\", [t.variableDeclarator(node.id, enumIIFE)]))[0]);\n        }\n        ENUMS.set(path.scope.getBindingIdentifier(name), data);\n        break;\n      }\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n  function seen(parentPath) {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\nconst buildStringAssignment = (0, _core.template)(`\n  ENUM[\"NAME\"] = VALUE;\n`);\nconst buildNumericAssignment = (0, _core.template)(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\nconst buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);\nfunction enumFill(path, t, id) {\n  const {\n    enumValues: x,\n    data,\n    isPure\n  } = translateEnumValues(path, t);\n  const assignments = x.map(_ref => {\n    let [memberName, memberValue] = _ref;\n    return buildEnumMember(t.isStringLiteral(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue\n    });\n  });\n  return {\n    fill: {\n      ID: t.cloneNode(id),\n      ASSIGNMENTS: assignments\n    },\n    data,\n    isPure\n  };\n}\nfunction ReferencedIdentifier(expr, state) {\n  const {\n    seen,\n    path,\n    t\n  } = state;\n  const name = expr.node.name;\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)));\n    expr.skip();\n  }\n}\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier\n};\nfunction translateEnumValues(path, t) {\n  const seen = new Map();\n  let constValue = -1;\n  let lastName;\n  let isPure = true;\n  const enumValues = path.get(\"members\").map(memberPath => {\n    const member = memberPath.node;\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializerPath = memberPath.get(\"initializer\");\n    const initializer = member.initializer;\n    let value;\n    if (initializer) {\n      constValue = computeConstantValue(initializerPath, seen);\n      if (constValue !== undefined) {\n        seen.set(name, constValue);\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n        } else {\n          _assert(typeof constValue === \"string\");\n          value = t.stringLiteral(constValue);\n        }\n      } else {\n        isPure && (isPure = initializerPath.isPure());\n        if (initializerPath.isReferencedIdentifier()) {\n          ReferencedIdentifier(initializerPath, {\n            t,\n            seen,\n            path\n          });\n        } else {\n          initializerPath.traverse(enumSelfReferenceVisitor, {\n            t,\n            seen,\n            path\n          });\n        }\n        value = initializerPath.node;\n        seen.set(name, undefined);\n      }\n    } else if (typeof constValue === \"number\") {\n      constValue += 1;\n      value = t.numericLiteral(constValue);\n      seen.set(name, constValue);\n    } else if (typeof constValue === \"string\") {\n      throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n    } else {\n      const lastRef = t.memberExpression(t.cloneNode(path.node.id), t.stringLiteral(lastName), true);\n      value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n      seen.set(name, undefined);\n    }\n    lastName = name;\n    return [name, value];\n  });\n  return {\n    isPure,\n    data: seen,\n    enumValues\n  };\n}\nfunction computeConstantValue(path, prevMembers) {\n  let seen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  return evaluate(path);\n  function evaluate(path) {\n    const expr = path.node;\n    switch (expr.type) {\n      case \"MemberExpression\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"StringLiteral\":\n        return expr.value;\n      case \"UnaryExpression\":\n        return evalUnaryExpression(path);\n      case \"BinaryExpression\":\n        return evalBinaryExpression(path);\n      case \"NumericLiteral\":\n        return expr.value;\n      case \"ParenthesizedExpression\":\n        return evaluate(path.get(\"expression\"));\n      case \"Identifier\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"TemplateLiteral\":\n        {\n          if (expr.quasis.length === 1) {\n            return expr.quasis[0].value.cooked;\n          }\n          const paths = path.get(\"expressions\");\n          const quasis = expr.quasis;\n          let str = \"\";\n          for (let i = 0; i < quasis.length; i++) {\n            str += quasis[i].value.cooked;\n            if (i + 1 < quasis.length) {\n              const value = evaluateRef(paths[i], prevMembers, seen);\n              if (value === undefined) return undefined;\n              str += value;\n            }\n          }\n          return str;\n        }\n      default:\n        return undefined;\n    }\n  }\n  function evaluateRef(path, prevMembers, seen) {\n    if (path.isMemberExpression()) {\n      const expr = path.node;\n      const obj = expr.object;\n      const prop = expr.property;\n      if (!_core.types.isIdentifier(obj) || (expr.computed ? !_core.types.isStringLiteral(prop) : !_core.types.isIdentifier(prop))) {\n        return;\n      }\n      const bindingIdentifier = path.scope.getBindingIdentifier(obj.name);\n      const data = ENUMS.get(bindingIdentifier);\n      if (!data) return;\n      return data.get(prop.computed ? prop.value : prop.name);\n    } else if (path.isIdentifier()) {\n      const name = path.node.name;\n      let value = prevMembers == null ? void 0 : prevMembers.get(name);\n      if (value !== undefined) {\n        return value;\n      }\n      if (seen.has(path.node)) return;\n      const bindingInitPath = path.resolve();\n      if (bindingInitPath) {\n        seen.add(path.node);\n        value = computeConstantValue(bindingInitPath, undefined, seen);\n        prevMembers == null ? void 0 : prevMembers.set(name, value);\n        return value;\n      }\n    }\n  }\n  function evalUnaryExpression(path) {\n    const value = evaluate(path.get(\"argument\"));\n    if (value === undefined) {\n      return undefined;\n    }\n    switch (path.node.operator) {\n      case \"+\":\n        return value;\n      case \"-\":\n        return -value;\n      case \"~\":\n        return ~value;\n      default:\n        return undefined;\n    }\n  }\n  function evalBinaryExpression(path) {\n    const left = evaluate(path.get(\"left\"));\n    if (left === undefined) {\n      return undefined;\n    }\n    const right = evaluate(path.get(\"right\"));\n    if (right === undefined) {\n      return undefined;\n    }\n    switch (path.node.operator) {\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n      case \"<<\":\n        return left << right;\n      case \"^\":\n        return left ^ right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return Math.pow(left, right);\n      default:\n        return undefined;\n    }\n  }\n}","map":{"version":3,"names":["_core","require","_assert","_helperAnnotateAsPure","ENUMS","WeakMap","buildEnumWrapper","template","expression","transpileEnum","path","t","node","parentPath","declare","remove","name","id","fill","data","isPure","enumFill","type","isGlobal","isProgram","parent","isSeen","seen","init","objectExpression","logicalExpression","cloneNode","ID","enumIIFE","Object","assign","INIT","default","toReplace","isExportDeclaration","replaceWith","expressionStatement","assignmentExpression","scope","registerDeclaration","variableDeclaration","variableDeclarator","set","getBindingIdentifier","Error","getData","setData","buildStringAssignment","buildNumericAssignment","buildEnumMember","isString","options","enumValues","x","translateEnumValues","assignments","map","_ref","memberName","memberValue","isStringLiteral","ENUM","NAME","VALUE","ASSIGNMENTS","ReferencedIdentifier","expr","state","has","hasOwnBinding","memberExpression","skip","enumSelfReferenceVisitor","Map","constValue","lastName","get","memberPath","member","isIdentifier","value","initializerPath","initializer","computeConstantValue","undefined","numericLiteral","stringLiteral","isReferencedIdentifier","traverse","buildCodeFrameError","lastRef","binaryExpression","prevMembers","arguments","length","Set","evaluate","evaluateRef","evalUnaryExpression","evalBinaryExpression","quasis","cooked","paths","str","i","isMemberExpression","obj","object","prop","property","types","computed","bindingIdentifier","bindingInitPath","resolve","add","operator","left","right","Math","pow"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@babel\\plugin-transform-typescript\\src\\enum.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport assert from \"assert\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\ntype t = typeof t;\n\nconst ENUMS = new WeakMap<t.Identifier, PreviousEnumMembers>();\n\nconst buildEnumWrapper = template.expression(\n  `\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  `,\n);\n\nexport default function transpileEnum(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n) {\n  const { node, parentPath } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const { fill, data, isPure } = enumFill(path, t, node.id);\n\n  switch (parentPath.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\": {\n      // todo: Consider exclude program with import/export\n      // && !path.parent.body.some(n => t.isImportDeclaration(n) || t.isExportDeclaration(n));\n      const isGlobal = t.isProgram(path.parent);\n      const isSeen = seen(parentPath);\n\n      let init: t.Expression = t.objectExpression([]);\n      if (isSeen || isGlobal) {\n        init = t.logicalExpression(\"||\", t.cloneNode(fill.ID), init);\n      }\n      const enumIIFE = buildEnumWrapper({ ...fill, INIT: init });\n      if (isPure) annotateAsPure(enumIIFE);\n\n      if (isSeen) {\n        const toReplace = parentPath.isExportDeclaration() ? parentPath : path;\n        toReplace.replaceWith(\n          t.expressionStatement(\n            t.assignmentExpression(\"=\", t.cloneNode(node.id), enumIIFE),\n          ),\n        );\n      } else {\n        path.scope.registerDeclaration(\n          path.replaceWith(\n            t.variableDeclaration(isGlobal ? \"var\" : \"let\", [\n              t.variableDeclarator(node.id, enumIIFE),\n            ]),\n          )[0],\n        );\n      }\n      ENUMS.set(path.scope.getBindingIdentifier(name), data);\n      break;\n    }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath: NodePath<t.Node>): boolean {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nconst buildStringAssignment = template(`\n  ENUM[\"NAME\"] = VALUE;\n`);\n\nconst buildNumericAssignment = template(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString: boolean, options: Record<string, unknown>) =>\n  (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\n/**\n * Generates the statement that fills in the variable declared by the enum.\n * `(function (E) { ... assignments ... })(E || (E = {}));`\n */\nfunction enumFill(path: NodePath<t.TSEnumDeclaration>, t: t, id: t.Identifier) {\n  const { enumValues: x, data, isPure } = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) =>\n    buildEnumMember(t.isStringLiteral(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue,\n    }),\n  );\n\n  return {\n    fill: {\n      ID: t.cloneNode(id),\n      ASSIGNMENTS: assignments,\n    },\n    data,\n    isPure,\n  };\n}\n\n/**\n * Maps the name of an enum member to its value.\n * We keep track of the previous enum members so you can write code like:\n *   enum E {\n *     X = 1 << 0,\n *     Y = 1 << 1,\n *     Z = X | Y,\n *   }\n */\ntype PreviousEnumMembers = Map<string, number | string>;\n\ntype EnumSelfReferenceVisitorState = {\n  seen: PreviousEnumMembers;\n  path: NodePath<t.TSEnumDeclaration>;\n  t: t;\n};\n\nfunction ReferencedIdentifier(\n  expr: NodePath<t.Identifier>,\n  state: EnumSelfReferenceVisitorState,\n) {\n  const { seen, path, t } = state;\n  const name = expr.node.name;\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(\n      t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)),\n    );\n    expr.skip();\n  }\n}\n\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier,\n};\n\nexport function translateEnumValues(path: NodePath<t.TSEnumDeclaration>, t: t) {\n  const seen: PreviousEnumMembers = new Map();\n  // Start at -1 so the first enum member is its increment, 0.\n  let constValue: number | string | undefined = -1;\n  let lastName: string;\n  let isPure = true;\n\n  const enumValues: Array<[name: string, value: t.Expression]> = path\n    .get(\"members\")\n    .map(memberPath => {\n      const member = memberPath.node;\n      const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n      const initializerPath = memberPath.get(\"initializer\");\n      const initializer = member.initializer;\n      let value: t.Expression;\n      if (initializer) {\n        constValue = computeConstantValue(initializerPath, seen);\n        if (constValue !== undefined) {\n          seen.set(name, constValue);\n          if (typeof constValue === \"number\") {\n            value = t.numericLiteral(constValue);\n          } else {\n            assert(typeof constValue === \"string\");\n            value = t.stringLiteral(constValue);\n          }\n        } else {\n          isPure &&= initializerPath.isPure();\n\n          if (initializerPath.isReferencedIdentifier()) {\n            ReferencedIdentifier(initializerPath, {\n              t,\n              seen,\n              path,\n            });\n          } else {\n            initializerPath.traverse(enumSelfReferenceVisitor, {\n              t,\n              seen,\n              path,\n            });\n          }\n\n          value = initializerPath.node;\n          seen.set(name, undefined);\n        }\n      } else if (typeof constValue === \"number\") {\n        constValue += 1;\n        value = t.numericLiteral(constValue);\n        seen.set(name, constValue);\n      } else if (typeof constValue === \"string\") {\n        throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n      } else {\n        // create dynamic initializer: 1 + ENUM[\"PREVIOUS\"]\n        const lastRef = t.memberExpression(\n          t.cloneNode(path.node.id),\n          t.stringLiteral(lastName),\n          true,\n        );\n        value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n        seen.set(name, undefined);\n      }\n\n      lastName = name;\n      return [name, value];\n    });\n\n  return {\n    isPure,\n    data: seen,\n    enumValues,\n  };\n}\n\n// Based on the TypeScript repository's `computeConstantValue` in `checker.ts`.\nfunction computeConstantValue(\n  path: NodePath,\n  prevMembers?: PreviousEnumMembers,\n  seen: Set<t.Identifier> = new Set(),\n): number | string | undefined {\n  return evaluate(path);\n\n  function evaluate(path: NodePath): number | string | undefined {\n    const expr = path.node;\n    switch (expr.type) {\n      case \"MemberExpression\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"StringLiteral\":\n        return expr.value;\n      case \"UnaryExpression\":\n        return evalUnaryExpression(path as NodePath<t.UnaryExpression>);\n      case \"BinaryExpression\":\n        return evalBinaryExpression(path as NodePath<t.BinaryExpression>);\n      case \"NumericLiteral\":\n        return expr.value;\n      case \"ParenthesizedExpression\":\n        return evaluate(path.get(\"expression\"));\n      case \"Identifier\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"TemplateLiteral\": {\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n\n        const paths = (path as NodePath<t.TemplateLiteral>).get(\"expressions\");\n        const quasis = expr.quasis;\n        let str = \"\";\n\n        for (let i = 0; i < quasis.length; i++) {\n          str += quasis[i].value.cooked;\n\n          if (i + 1 < quasis.length) {\n            const value = evaluateRef(paths[i], prevMembers, seen);\n            if (value === undefined) return undefined;\n            str += value;\n          }\n        }\n        return str;\n      }\n      default:\n        return undefined;\n    }\n  }\n\n  function evaluateRef(\n    path: NodePath,\n    prevMembers: PreviousEnumMembers,\n    seen: Set<t.Identifier>,\n  ): number | string | undefined {\n    if (path.isMemberExpression()) {\n      const expr = path.node;\n\n      const obj = expr.object;\n      const prop = expr.property;\n      if (\n        !t.isIdentifier(obj) ||\n        (expr.computed ? !t.isStringLiteral(prop) : !t.isIdentifier(prop))\n      ) {\n        return;\n      }\n      const bindingIdentifier = path.scope.getBindingIdentifier(obj.name);\n      const data = ENUMS.get(bindingIdentifier);\n      if (!data) return;\n      // @ts-expect-error checked above\n      return data.get(prop.computed ? prop.value : prop.name);\n    } else if (path.isIdentifier()) {\n      const name = path.node.name;\n\n      let value = prevMembers?.get(name);\n      if (value !== undefined) {\n        return value;\n      }\n\n      if (seen.has(path.node)) return;\n\n      const bindingInitPath = path.resolve(); // It only resolves constant bindings\n      if (bindingInitPath) {\n        seen.add(path.node);\n\n        value = computeConstantValue(bindingInitPath, undefined, seen);\n        prevMembers?.set(name, value);\n        return value;\n      }\n    }\n  }\n\n  function evalUnaryExpression(\n    path: NodePath<t.UnaryExpression>,\n  ): number | string | undefined {\n    const value = evaluate(path.get(\"argument\"));\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (path.node.operator) {\n      case \"+\":\n        return value;\n      case \"-\":\n        return -value;\n      case \"~\":\n        return ~value;\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(\n    path: NodePath<t.BinaryExpression>,\n  ): number | string | undefined {\n    const left = evaluate(path.get(\"left\")) as any;\n    if (left === undefined) {\n      return undefined;\n    }\n    const right = evaluate(path.get(\"right\")) as any;\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (path.node.operator) {\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n      case \"<<\":\n        return left << right;\n      case \"^\":\n        return left ^ right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      default:\n        return undefined;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}