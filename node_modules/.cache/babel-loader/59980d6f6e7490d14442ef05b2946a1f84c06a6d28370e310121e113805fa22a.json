{"ast":null,"code":"'use strict';\n\nconst csstree = require('css-tree');\nconst {\n  referencesProps\n} = require('./_collections.js');\nexports.name = 'prefixIds';\nexports.description = 'prefix IDs';\n\n/**\n * extract basename from path\n * @type {(path: string) => string}\n */\nconst getBasename = path => {\n  // extract everything after latest slash or backslash\n  const matched = path.match(/[/\\\\]?([^/\\\\]+)$/);\n  if (matched) {\n    return matched[1];\n  }\n  return '';\n};\n\n/**\n * escapes a string for being used as ID\n * @type {(string: string) => string}\n */\nconst escapeIdentifierName = str => {\n  return str.replace(/[. ]/g, '_');\n};\n\n/**\n * @type {(string: string) => string}\n */\nconst unquote = string => {\n  if (string.startsWith('\"') && string.endsWith('\"') || string.startsWith(\"'\") && string.endsWith(\"'\")) {\n    return string.slice(1, -1);\n  }\n  return string;\n};\n\n/**\n * prefix an ID\n * @type {(prefix: string, name: string) => string}\n */\nconst prefixId = (prefix, value) => {\n  if (value.startsWith(prefix)) {\n    return value;\n  }\n  return prefix + value;\n};\n\n/**\n * prefix an #ID\n * @type {(prefix: string, name: string) => string | null}\n */\nconst prefixReference = (prefix, value) => {\n  if (value.startsWith('#')) {\n    return '#' + prefixId(prefix, value.slice(1));\n  }\n  return null;\n};\n\n/** @type {(value: any) => any} */\nconst toAny = value => value;\n\n/**\n * Prefixes identifiers\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('./plugins-types').Plugin<'prefixIds'>}\n */\nexports.fn = (_root, params, info) => {\n  const {\n    delim = '__',\n    prefixIds = true,\n    prefixClassNames = true\n  } = params;\n  return {\n    element: {\n      enter: node => {\n        /**\n         * prefix, from file name or option\n         * @type {string}\n         */\n        let prefix = 'prefix' + delim;\n        if (typeof params.prefix === 'function') {\n          prefix = params.prefix(node, info) + delim;\n        } else if (typeof params.prefix === 'string') {\n          prefix = params.prefix + delim;\n        } else if (params.prefix === false) {\n          prefix = '';\n        } else if (info.path != null && info.path.length > 0) {\n          prefix = escapeIdentifierName(getBasename(info.path)) + delim;\n        }\n\n        // prefix id/class selectors and url() references in styles\n        if (node.name === 'style') {\n          // skip empty <style/> elements\n          if (node.children.length === 0) {\n            return;\n          }\n\n          // parse styles\n          let cssText = '';\n          if (node.children[0].type === 'text' || node.children[0].type === 'cdata') {\n            cssText = node.children[0].value;\n          }\n          /**\n           * @type {null | csstree.CssNode}\n           */\n          let cssAst = null;\n          try {\n            cssAst = csstree.parse(cssText, {\n              parseValue: true,\n              parseCustomProperty: false\n            });\n          } catch {\n            return;\n          }\n          csstree.walk(cssAst, node => {\n            // #ID, .class selectors\n            if (prefixIds && node.type === 'IdSelector' || prefixClassNames && node.type === 'ClassSelector') {\n              node.name = prefixId(prefix, node.name);\n              return;\n            }\n            // url(...) references\n            // csstree v2 changed this type\n            if (node.type === 'Url' && toAny(node.value).length > 0) {\n              const prefixed = prefixReference(prefix, unquote(toAny(node.value)));\n              if (prefixed != null) {\n                toAny(node).value = prefixed;\n              }\n            }\n          });\n\n          // update styles\n          if (node.children[0].type === 'text' || node.children[0].type === 'cdata') {\n            node.children[0].value = csstree.generate(cssAst);\n          }\n          return;\n        }\n\n        // prefix an ID attribute value\n        if (prefixIds && node.attributes.id != null && node.attributes.id.length !== 0) {\n          node.attributes.id = prefixId(prefix, node.attributes.id);\n        }\n\n        // prefix a class attribute value\n        if (prefixClassNames && node.attributes.class != null && node.attributes.class.length !== 0) {\n          node.attributes.class = node.attributes.class.split(/\\s+/).map(name => prefixId(prefix, name)).join(' ');\n        }\n\n        // prefix a href attribute value\n        // xlink:href is deprecated, must be still supported\n        for (const name of ['href', 'xlink:href']) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            const prefixed = prefixReference(prefix, node.attributes[name]);\n            if (prefixed != null) {\n              node.attributes[name] = prefixed;\n            }\n          }\n        }\n\n        // prefix an URL attribute value\n        for (const name of referencesProps) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            node.attributes[name] = node.attributes[name].replace(/url\\((.*?)\\)/gi, (match, url) => {\n              const prefixed = prefixReference(prefix, url);\n              if (prefixed == null) {\n                return match;\n              }\n              return `url(${prefixed})`;\n            });\n          }\n        }\n\n        // prefix begin/end attribute value\n        for (const name of ['begin', 'end']) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            const parts = node.attributes[name].split(/\\s*;\\s+/).map(val => {\n              if (val.endsWith('.end') || val.endsWith('.start')) {\n                const [id, postfix] = val.split('.');\n                return `${prefixId(prefix, id)}.${postfix}`;\n              }\n              return val;\n            });\n            node.attributes[name] = parts.join('; ');\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["csstree","require","referencesProps","exports","name","description","getBasename","path","matched","match","escapeIdentifierName","str","replace","unquote","string","startsWith","endsWith","slice","prefixId","prefix","value","prefixReference","toAny","fn","_root","params","info","delim","prefixIds","prefixClassNames","element","enter","node","length","children","cssText","type","cssAst","parse","parseValue","parseCustomProperty","walk","prefixed","generate","attributes","id","class","split","map","join","url","parts","val","postfix"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/prefixIds.js"],"sourcesContent":["'use strict';\n\nconst csstree = require('css-tree');\nconst { referencesProps } = require('./_collections.js');\n\nexports.name = 'prefixIds';\nexports.description = 'prefix IDs';\n\n/**\n * extract basename from path\n * @type {(path: string) => string}\n */\nconst getBasename = (path) => {\n  // extract everything after latest slash or backslash\n  const matched = path.match(/[/\\\\]?([^/\\\\]+)$/);\n  if (matched) {\n    return matched[1];\n  }\n  return '';\n};\n\n/**\n * escapes a string for being used as ID\n * @type {(string: string) => string}\n */\nconst escapeIdentifierName = (str) => {\n  return str.replace(/[. ]/g, '_');\n};\n\n/**\n * @type {(string: string) => string}\n */\nconst unquote = (string) => {\n  if (\n    (string.startsWith('\"') && string.endsWith('\"')) ||\n    (string.startsWith(\"'\") && string.endsWith(\"'\"))\n  ) {\n    return string.slice(1, -1);\n  }\n  return string;\n};\n\n/**\n * prefix an ID\n * @type {(prefix: string, name: string) => string}\n */\nconst prefixId = (prefix, value) => {\n  if (value.startsWith(prefix)) {\n    return value;\n  }\n  return prefix + value;\n};\n\n/**\n * prefix an #ID\n * @type {(prefix: string, name: string) => string | null}\n */\nconst prefixReference = (prefix, value) => {\n  if (value.startsWith('#')) {\n    return '#' + prefixId(prefix, value.slice(1));\n  }\n  return null;\n};\n\n/** @type {(value: any) => any} */\nconst toAny = (value) => value;\n\n/**\n * Prefixes identifiers\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('./plugins-types').Plugin<'prefixIds'>}\n */\nexports.fn = (_root, params, info) => {\n  const { delim = '__', prefixIds = true, prefixClassNames = true } = params;\n\n  return {\n    element: {\n      enter: (node) => {\n        /**\n         * prefix, from file name or option\n         * @type {string}\n         */\n        let prefix = 'prefix' + delim;\n        if (typeof params.prefix === 'function') {\n          prefix = params.prefix(node, info) + delim;\n        } else if (typeof params.prefix === 'string') {\n          prefix = params.prefix + delim;\n        } else if (params.prefix === false) {\n          prefix = '';\n        } else if (info.path != null && info.path.length > 0) {\n          prefix = escapeIdentifierName(getBasename(info.path)) + delim;\n        }\n\n        // prefix id/class selectors and url() references in styles\n        if (node.name === 'style') {\n          // skip empty <style/> elements\n          if (node.children.length === 0) {\n            return;\n          }\n\n          // parse styles\n          let cssText = '';\n          if (\n            node.children[0].type === 'text' ||\n            node.children[0].type === 'cdata'\n          ) {\n            cssText = node.children[0].value;\n          }\n          /**\n           * @type {null | csstree.CssNode}\n           */\n          let cssAst = null;\n          try {\n            cssAst = csstree.parse(cssText, {\n              parseValue: true,\n              parseCustomProperty: false,\n            });\n          } catch {\n            return;\n          }\n\n          csstree.walk(cssAst, (node) => {\n            // #ID, .class selectors\n            if (\n              (prefixIds && node.type === 'IdSelector') ||\n              (prefixClassNames && node.type === 'ClassSelector')\n            ) {\n              node.name = prefixId(prefix, node.name);\n              return;\n            }\n            // url(...) references\n            // csstree v2 changed this type\n            if (node.type === 'Url' && toAny(node.value).length > 0) {\n              const prefixed = prefixReference(\n                prefix,\n                unquote(toAny(node.value))\n              );\n              if (prefixed != null) {\n                toAny(node).value = prefixed;\n              }\n            }\n          });\n\n          // update styles\n          if (\n            node.children[0].type === 'text' ||\n            node.children[0].type === 'cdata'\n          ) {\n            node.children[0].value = csstree.generate(cssAst);\n          }\n          return;\n        }\n\n        // prefix an ID attribute value\n        if (\n          prefixIds &&\n          node.attributes.id != null &&\n          node.attributes.id.length !== 0\n        ) {\n          node.attributes.id = prefixId(prefix, node.attributes.id);\n        }\n\n        // prefix a class attribute value\n        if (\n          prefixClassNames &&\n          node.attributes.class != null &&\n          node.attributes.class.length !== 0\n        ) {\n          node.attributes.class = node.attributes.class\n            .split(/\\s+/)\n            .map((name) => prefixId(prefix, name))\n            .join(' ');\n        }\n\n        // prefix a href attribute value\n        // xlink:href is deprecated, must be still supported\n        for (const name of ['href', 'xlink:href']) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            const prefixed = prefixReference(prefix, node.attributes[name]);\n            if (prefixed != null) {\n              node.attributes[name] = prefixed;\n            }\n          }\n        }\n\n        // prefix an URL attribute value\n        for (const name of referencesProps) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            node.attributes[name] = node.attributes[name].replace(\n              /url\\((.*?)\\)/gi,\n              (match, url) => {\n                const prefixed = prefixReference(prefix, url);\n                if (prefixed == null) {\n                  return match;\n                }\n                return `url(${prefixed})`;\n              }\n            );\n          }\n        }\n\n        // prefix begin/end attribute value\n        for (const name of ['begin', 'end']) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            const parts = node.attributes[name].split(/\\s*;\\s+/).map((val) => {\n              if (val.endsWith('.end') || val.endsWith('.start')) {\n                const [id, postfix] = val.split('.');\n                return `${prefixId(prefix, id)}.${postfix}`;\n              }\n              return val;\n            });\n            node.attributes[name] = parts.join('; ');\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}