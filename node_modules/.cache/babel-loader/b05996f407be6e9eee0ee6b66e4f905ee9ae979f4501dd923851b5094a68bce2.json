{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\nconst {\n  visitSkip\n} = require('../lib/xast.js');\nconst {\n  referencesProps\n} = require('./_collections.js');\nexports.name = 'cleanupIds';\nexports.description = 'removes unused IDs and minifies used';\nconst regReferencesUrl = /\\burl\\(([\"'])?#(.+?)\\1\\)/;\nconst regReferencesHref = /^#(.+?)$/;\nconst regReferencesBegin = /(\\D+)\\./;\nconst generateIdChars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\nconst maxIdIndex = generateIdChars.length - 1;\n\n/**\n * Check if an ID starts with any one of a list of strings.\n *\n * @type {(string: string, prefixes: Array<string>) => boolean}\n */\nconst hasStringPrefix = (string, prefixes) => {\n  for (const prefix of prefixes) {\n    if (string.startsWith(prefix)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Generate unique minimal ID.\n *\n * @type {(currentId: null | Array<number>) => Array<number>}\n */\nconst generateId = currentId => {\n  if (currentId == null) {\n    return [0];\n  }\n  currentId[currentId.length - 1] += 1;\n  for (let i = currentId.length - 1; i > 0; i--) {\n    if (currentId[i] > maxIdIndex) {\n      currentId[i] = 0;\n      if (currentId[i - 1] !== undefined) {\n        currentId[i - 1]++;\n      }\n    }\n  }\n  if (currentId[0] > maxIdIndex) {\n    currentId[0] = 0;\n    currentId.unshift(0);\n  }\n  return currentId;\n};\n\n/**\n * Get string from generated ID array.\n *\n * @type {(arr: Array<number>) => string}\n */\nconst getIdString = arr => {\n  return arr.map(i => generateIdChars[i]).join('');\n};\n\n/**\n * Remove unused and minify used IDs\n * (only if there are no any <style> or <script>).\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'cleanupIds'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    remove = true,\n    minify = true,\n    preserve = [],\n    preservePrefixes = [],\n    force = false\n  } = params;\n  const preserveIds = new Set(Array.isArray(preserve) ? preserve : preserve ? [preserve] : []);\n  const preserveIdPrefixes = Array.isArray(preservePrefixes) ? preservePrefixes : preservePrefixes ? [preservePrefixes] : [];\n  /**\n   * @type {Map<string, XastElement>}\n   */\n  const nodeById = new Map();\n  /**\n   * @type {Map<string, Array<{element: XastElement, name: string, value: string }>>}\n   */\n  const referencesById = new Map();\n  let deoptimized = false;\n  return {\n    element: {\n      enter: node => {\n        if (force == false) {\n          // deoptimize if style or script elements are present\n          if ((node.name === 'style' || node.name === 'script') && node.children.length !== 0) {\n            deoptimized = true;\n            return;\n          }\n\n          // avoid removing IDs if the whole SVG consists only of defs\n          if (node.name === 'svg') {\n            let hasDefsOnly = true;\n            for (const child of node.children) {\n              if (child.type !== 'element' || child.name !== 'defs') {\n                hasDefsOnly = false;\n                break;\n              }\n            }\n            if (hasDefsOnly) {\n              return visitSkip;\n            }\n          }\n        }\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (name === 'id') {\n            // collect all ids\n            const id = value;\n            if (nodeById.has(id)) {\n              delete node.attributes.id; // remove repeated id\n            } else {\n              nodeById.set(id, node);\n            }\n          } else {\n            // collect all references\n            /**\n             * @type {null | string}\n             */\n            let id = null;\n            if (referencesProps.includes(name)) {\n              const match = value.match(regReferencesUrl);\n              if (match != null) {\n                id = match[2]; // url() reference\n              }\n            }\n\n            if (name === 'href' || name.endsWith(':href')) {\n              const match = value.match(regReferencesHref);\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n\n            if (name === 'begin') {\n              const match = value.match(regReferencesBegin);\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n\n            if (id != null) {\n              let refs = referencesById.get(id);\n              if (refs == null) {\n                refs = [];\n                referencesById.set(id, refs);\n              }\n              refs.push({\n                element: node,\n                name,\n                value\n              });\n            }\n          }\n        }\n      }\n    },\n    root: {\n      exit: () => {\n        if (deoptimized) {\n          return;\n        }\n        /**\n         * @type {(id: string) => boolean}\n         **/\n        const isIdPreserved = id => preserveIds.has(id) || hasStringPrefix(id, preserveIdPrefixes);\n        /**\n         * @type {null | Array<number>}\n         */\n        let currentId = null;\n        for (const [id, refs] of referencesById) {\n          const node = nodeById.get(id);\n          if (node != null) {\n            // replace referenced IDs with the minified ones\n            if (minify && isIdPreserved(id) === false) {\n              /**\n               * @type {null | string}\n               */\n              let currentIdString = null;\n              do {\n                currentId = generateId(currentId);\n                currentIdString = getIdString(currentId);\n              } while (isIdPreserved(currentIdString));\n              node.attributes.id = currentIdString;\n              for (const {\n                element,\n                name,\n                value\n              } of refs) {\n                if (value.includes('#')) {\n                  // replace id in href and url()\n                  element.attributes[name] = value.replace(`#${id}`, `#${currentIdString}`);\n                } else {\n                  // replace id in begin attribute\n                  element.attributes[name] = value.replace(`${id}.`, `${currentIdString}.`);\n                }\n              }\n            }\n            // keep referenced node\n            nodeById.delete(id);\n          }\n        }\n        // remove non-referenced IDs attributes from elements\n        if (remove) {\n          for (const [id, node] of nodeById) {\n            if (isIdPreserved(id) === false) {\n              delete node.attributes.id;\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["visitSkip","require","referencesProps","exports","name","description","regReferencesUrl","regReferencesHref","regReferencesBegin","generateIdChars","maxIdIndex","length","hasStringPrefix","string","prefixes","prefix","startsWith","generateId","currentId","i","undefined","unshift","getIdString","arr","map","join","fn","_root","params","remove","minify","preserve","preservePrefixes","force","preserveIds","Set","Array","isArray","preserveIdPrefixes","nodeById","Map","referencesById","deoptimized","element","enter","node","children","hasDefsOnly","child","type","value","Object","entries","attributes","id","has","set","includes","match","endsWith","refs","get","push","root","exit","isIdPreserved","currentIdString","replace","delete"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/cleanupIds.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { visitSkip } = require('../lib/xast.js');\nconst { referencesProps } = require('./_collections.js');\n\nexports.name = 'cleanupIds';\nexports.description = 'removes unused IDs and minifies used';\n\nconst regReferencesUrl = /\\burl\\(([\"'])?#(.+?)\\1\\)/;\nconst regReferencesHref = /^#(.+?)$/;\nconst regReferencesBegin = /(\\D+)\\./;\nconst generateIdChars = [\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n];\nconst maxIdIndex = generateIdChars.length - 1;\n\n/**\n * Check if an ID starts with any one of a list of strings.\n *\n * @type {(string: string, prefixes: Array<string>) => boolean}\n */\nconst hasStringPrefix = (string, prefixes) => {\n  for (const prefix of prefixes) {\n    if (string.startsWith(prefix)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Generate unique minimal ID.\n *\n * @type {(currentId: null | Array<number>) => Array<number>}\n */\nconst generateId = (currentId) => {\n  if (currentId == null) {\n    return [0];\n  }\n  currentId[currentId.length - 1] += 1;\n  for (let i = currentId.length - 1; i > 0; i--) {\n    if (currentId[i] > maxIdIndex) {\n      currentId[i] = 0;\n      if (currentId[i - 1] !== undefined) {\n        currentId[i - 1]++;\n      }\n    }\n  }\n  if (currentId[0] > maxIdIndex) {\n    currentId[0] = 0;\n    currentId.unshift(0);\n  }\n  return currentId;\n};\n\n/**\n * Get string from generated ID array.\n *\n * @type {(arr: Array<number>) => string}\n */\nconst getIdString = (arr) => {\n  return arr.map((i) => generateIdChars[i]).join('');\n};\n\n/**\n * Remove unused and minify used IDs\n * (only if there are no any <style> or <script>).\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'cleanupIds'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    remove = true,\n    minify = true,\n    preserve = [],\n    preservePrefixes = [],\n    force = false,\n  } = params;\n  const preserveIds = new Set(\n    Array.isArray(preserve) ? preserve : preserve ? [preserve] : []\n  );\n  const preserveIdPrefixes = Array.isArray(preservePrefixes)\n    ? preservePrefixes\n    : preservePrefixes\n    ? [preservePrefixes]\n    : [];\n  /**\n   * @type {Map<string, XastElement>}\n   */\n  const nodeById = new Map();\n  /**\n   * @type {Map<string, Array<{element: XastElement, name: string, value: string }>>}\n   */\n  const referencesById = new Map();\n  let deoptimized = false;\n\n  return {\n    element: {\n      enter: (node) => {\n        if (force == false) {\n          // deoptimize if style or script elements are present\n          if (\n            (node.name === 'style' || node.name === 'script') &&\n            node.children.length !== 0\n          ) {\n            deoptimized = true;\n            return;\n          }\n\n          // avoid removing IDs if the whole SVG consists only of defs\n          if (node.name === 'svg') {\n            let hasDefsOnly = true;\n            for (const child of node.children) {\n              if (child.type !== 'element' || child.name !== 'defs') {\n                hasDefsOnly = false;\n                break;\n              }\n            }\n            if (hasDefsOnly) {\n              return visitSkip;\n            }\n          }\n        }\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (name === 'id') {\n            // collect all ids\n            const id = value;\n            if (nodeById.has(id)) {\n              delete node.attributes.id; // remove repeated id\n            } else {\n              nodeById.set(id, node);\n            }\n          } else {\n            // collect all references\n            /**\n             * @type {null | string}\n             */\n            let id = null;\n            if (referencesProps.includes(name)) {\n              const match = value.match(regReferencesUrl);\n              if (match != null) {\n                id = match[2]; // url() reference\n              }\n            }\n            if (name === 'href' || name.endsWith(':href')) {\n              const match = value.match(regReferencesHref);\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n            if (name === 'begin') {\n              const match = value.match(regReferencesBegin);\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n            if (id != null) {\n              let refs = referencesById.get(id);\n              if (refs == null) {\n                refs = [];\n                referencesById.set(id, refs);\n              }\n              refs.push({ element: node, name, value });\n            }\n          }\n        }\n      },\n    },\n\n    root: {\n      exit: () => {\n        if (deoptimized) {\n          return;\n        }\n        /**\n         * @type {(id: string) => boolean}\n         **/\n        const isIdPreserved = (id) =>\n          preserveIds.has(id) || hasStringPrefix(id, preserveIdPrefixes);\n        /**\n         * @type {null | Array<number>}\n         */\n        let currentId = null;\n        for (const [id, refs] of referencesById) {\n          const node = nodeById.get(id);\n          if (node != null) {\n            // replace referenced IDs with the minified ones\n            if (minify && isIdPreserved(id) === false) {\n              /**\n               * @type {null | string}\n               */\n              let currentIdString = null;\n              do {\n                currentId = generateId(currentId);\n                currentIdString = getIdString(currentId);\n              } while (isIdPreserved(currentIdString));\n              node.attributes.id = currentIdString;\n              for (const { element, name, value } of refs) {\n                if (value.includes('#')) {\n                  // replace id in href and url()\n                  element.attributes[name] = value.replace(\n                    `#${id}`,\n                    `#${currentIdString}`\n                  );\n                } else {\n                  // replace id in begin attribute\n                  element.attributes[name] = value.replace(\n                    `${id}.`,\n                    `${currentIdString}.`\n                  );\n                }\n              }\n            }\n            // keep referenced node\n            nodeById.delete(id);\n          }\n        }\n        // remove non-referenced IDs attributes from elements\n        if (remove) {\n          for (const [id, node] of nodeById) {\n            if (isIdPreserved(id) === false) {\n              delete node.attributes.id;\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}