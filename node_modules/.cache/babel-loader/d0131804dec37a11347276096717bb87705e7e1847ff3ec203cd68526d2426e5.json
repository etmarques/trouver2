{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n * @typedef {import('../lib/types').XastElement} XastElement\n */\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\nconst {\n  transformsMultiply,\n  transform2js,\n  transformArc\n} = require('./_transforms.js');\nconst {\n  path2js\n} = require('./_path.js');\nconst {\n  removeLeadingZero\n} = require('../lib/svgo/tools.js');\nconst {\n  referencesProps,\n  attrsGroupsDefaults\n} = require('./_collections.js');\n\n/**\n * @typedef {Array<PathDataItem>} PathData\n * @typedef {Array<number>} Matrix\n */\n\nconst regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Apply transformation(s) to the Path data.\n *\n * @type {import('../lib/types').Plugin<{\n *   transformPrecision: number,\n *   applyTransformsStroked: boolean,\n * }>}\n */\nconst applyTransforms = (root, params) => {\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: node => {\n        const computedStyle = computeStyle(stylesheet, node);\n\n        // used only for paths for now\n        if (node.attributes.d == null) {\n          return;\n        }\n\n        // stroke and stroke-width can be redefined with <use>\n        if (node.attributes.id != null) {\n          return;\n        }\n\n        // if there are no 'stroke' attr and references to other objects such as\n        // gradiends or clip-path which are also subjects to transform.\n        if (node.attributes.transform == null || node.attributes.transform === '' ||\n        // styles are not considered when applying transform\n        // can be fixed properly with new style engine\n        node.attributes.style != null || Object.entries(node.attributes).some(_ref => {\n          let [name, value] = _ref;\n          return referencesProps.includes(name) && value.includes('url(');\n        })) {\n          return;\n        }\n        const matrix = transformsMultiply(transform2js(node.attributes.transform));\n        const stroke = computedStyle.stroke != null && computedStyle.stroke.type === 'static' ? computedStyle.stroke.value : null;\n        const strokeWidth = computedStyle['stroke-width'] != null && computedStyle['stroke-width'].type === 'static' ? computedStyle['stroke-width'].value : null;\n        const transformPrecision = params.transformPrecision;\n        if (computedStyle.stroke != null && computedStyle.stroke.type === 'dynamic' || computedStyle.strokeWidth != null && computedStyle['stroke-width'].type === 'dynamic') {\n          return;\n        }\n        const scale = Number(Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision));\n        if (stroke && stroke != 'none') {\n          if (params.applyTransformsStroked === false) {\n            return;\n          }\n\n          // stroke cannot be transformed with different vertical and horizontal scale or skew\n          if ((matrix.data[0] !== matrix.data[3] || matrix.data[1] !== -matrix.data[2]) && (matrix.data[0] !== -matrix.data[3] || matrix.data[1] !== matrix.data[2])) {\n            return;\n          }\n\n          // apply transform to stroke-width, stroke-dashoffset and stroke-dasharray\n          if (scale !== 1) {\n            if (node.attributes['vector-effect'] !== 'non-scaling-stroke') {\n              node.attributes['stroke-width'] = (strokeWidth || attrsGroupsDefaults.presentation['stroke-width']).trim().replace(regNumericValues, num => removeLeadingZero(Number(num) * scale));\n              if (node.attributes['stroke-dashoffset'] != null) {\n                node.attributes['stroke-dashoffset'] = node.attributes['stroke-dashoffset'].trim().replace(regNumericValues, num => removeLeadingZero(Number(num) * scale));\n              }\n              if (node.attributes['stroke-dasharray'] != null) {\n                node.attributes['stroke-dasharray'] = node.attributes['stroke-dasharray'].trim().replace(regNumericValues, num => removeLeadingZero(Number(num) * scale));\n              }\n            }\n          }\n        }\n        const pathData = path2js(node);\n        applyMatrixToPathData(pathData, matrix.data);\n\n        // remove transform attr\n        delete node.attributes.transform;\n      }\n    }\n  };\n};\nexports.applyTransforms = applyTransforms;\n\n/**\n * @type {(matrix: Matrix, x: number, y: number) => [number, number]}\n */\nconst transformAbsolutePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y + matrix[4];\n  const newY = matrix[1] * x + matrix[3] * y + matrix[5];\n  return [newX, newY];\n};\n\n/**\n * @type {(matrix: Matrix, x: number, y: number) => [number, number]}\n */\nconst transformRelativePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y;\n  const newY = matrix[1] * x + matrix[3] * y;\n  return [newX, newY];\n};\n\n/**\n * @type {(pathData: PathData, matrix: Matrix) => void}\n */\nconst applyMatrixToPathData = (pathData, matrix) => {\n  /**\n   * @type {[number, number]}\n   */\n  const start = [0, 0];\n  /**\n   * @type {[number, number]}\n   */\n  const cursor = [0, 0];\n  for (const pathItem of pathData) {\n    let {\n      command,\n      args\n    } = pathItem;\n\n    // moveto (x y)\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 'm') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // horizontal lineto (x)\n    // convert to lineto to handle two-dimentional transforms\n    if (command === 'H') {\n      command = 'L';\n      args = [args[0], cursor[1]];\n    }\n    if (command === 'h') {\n      command = 'l';\n      args = [args[0], 0];\n    }\n\n    // vertical lineto (y)\n    // convert to lineto to handle two-dimentional transforms\n    if (command === 'V') {\n      command = 'L';\n      args = [cursor[0], args[0]];\n    }\n    if (command === 'v') {\n      command = 'l';\n      args = [0, args[0]];\n    }\n\n    // lineto (x y)\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);\n      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    }\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);\n      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    }\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    }\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'A') {\n      transformArc(cursor, args, matrix);\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n      // reduce number of digits in rotation angle\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    }\n    if (command === 'a') {\n      transformArc([0, 0], args, matrix);\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n      // reduce number of digits in rotation angle\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    }\n\n    // closepath\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n    pathItem.command = command;\n    pathItem.args = args;\n  }\n};","map":{"version":3,"names":["collectStylesheet","computeStyle","require","transformsMultiply","transform2js","transformArc","path2js","removeLeadingZero","referencesProps","attrsGroupsDefaults","regNumericValues","applyTransforms","root","params","stylesheet","element","enter","node","computedStyle","attributes","d","id","transform","style","Object","entries","some","_ref","name","value","includes","matrix","stroke","type","strokeWidth","transformPrecision","scale","Number","Math","sqrt","data","toFixed","applyTransformsStroked","presentation","trim","replace","num","pathData","applyMatrixToPathData","exports","transformAbsolutePoint","x","y","newX","newY","transformRelativePoint","start","cursor","pathItem","command","args","x1","y1","x2","y2","abs","a","rotation"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/applyTransforms.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst {\n  transformsMultiply,\n  transform2js,\n  transformArc,\n} = require('./_transforms.js');\nconst { path2js } = require('./_path.js');\nconst { removeLeadingZero } = require('../lib/svgo/tools.js');\nconst { referencesProps, attrsGroupsDefaults } = require('./_collections.js');\n\n/**\n * @typedef {Array<PathDataItem>} PathData\n * @typedef {Array<number>} Matrix\n */\n\nconst regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Apply transformation(s) to the Path data.\n *\n * @type {import('../lib/types').Plugin<{\n *   transformPrecision: number,\n *   applyTransformsStroked: boolean,\n * }>}\n */\nconst applyTransforms = (root, params) => {\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: (node) => {\n        const computedStyle = computeStyle(stylesheet, node);\n\n        // used only for paths for now\n        if (node.attributes.d == null) {\n          return;\n        }\n\n        // stroke and stroke-width can be redefined with <use>\n        if (node.attributes.id != null) {\n          return;\n        }\n\n        // if there are no 'stroke' attr and references to other objects such as\n        // gradiends or clip-path which are also subjects to transform.\n        if (\n          node.attributes.transform == null ||\n          node.attributes.transform === '' ||\n          // styles are not considered when applying transform\n          // can be fixed properly with new style engine\n          node.attributes.style != null ||\n          Object.entries(node.attributes).some(\n            ([name, value]) =>\n              referencesProps.includes(name) && value.includes('url(')\n          )\n        ) {\n          return;\n        }\n\n        const matrix = transformsMultiply(\n          transform2js(node.attributes.transform)\n        );\n        const stroke =\n          computedStyle.stroke != null && computedStyle.stroke.type === 'static'\n            ? computedStyle.stroke.value\n            : null;\n\n        const strokeWidth =\n          computedStyle['stroke-width'] != null &&\n          computedStyle['stroke-width'].type === 'static'\n            ? computedStyle['stroke-width'].value\n            : null;\n        const transformPrecision = params.transformPrecision;\n\n        if (\n          (computedStyle.stroke != null &&\n            computedStyle.stroke.type === 'dynamic') ||\n          (computedStyle.strokeWidth != null &&\n            computedStyle['stroke-width'].type === 'dynamic')\n        ) {\n          return;\n        }\n\n        const scale = Number(\n          Math.sqrt(\n            matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]\n          ).toFixed(transformPrecision)\n        );\n\n        if (stroke && stroke != 'none') {\n          if (params.applyTransformsStroked === false) {\n            return;\n          }\n\n          // stroke cannot be transformed with different vertical and horizontal scale or skew\n          if (\n            (matrix.data[0] !== matrix.data[3] ||\n              matrix.data[1] !== -matrix.data[2]) &&\n            (matrix.data[0] !== -matrix.data[3] ||\n              matrix.data[1] !== matrix.data[2])\n          ) {\n            return;\n          }\n\n          // apply transform to stroke-width, stroke-dashoffset and stroke-dasharray\n          if (scale !== 1) {\n            if (node.attributes['vector-effect'] !== 'non-scaling-stroke') {\n              node.attributes['stroke-width'] = (\n                strokeWidth || attrsGroupsDefaults.presentation['stroke-width']\n              )\n                .trim()\n                .replace(regNumericValues, (num) =>\n                  removeLeadingZero(Number(num) * scale)\n                );\n\n              if (node.attributes['stroke-dashoffset'] != null) {\n                node.attributes['stroke-dashoffset'] = node.attributes[\n                  'stroke-dashoffset'\n                ]\n                  .trim()\n                  .replace(regNumericValues, (num) =>\n                    removeLeadingZero(Number(num) * scale)\n                  );\n              }\n\n              if (node.attributes['stroke-dasharray'] != null) {\n                node.attributes['stroke-dasharray'] = node.attributes[\n                  'stroke-dasharray'\n                ]\n                  .trim()\n                  .replace(regNumericValues, (num) =>\n                    removeLeadingZero(Number(num) * scale)\n                  );\n              }\n            }\n          }\n        }\n\n        const pathData = path2js(node);\n        applyMatrixToPathData(pathData, matrix.data);\n\n        // remove transform attr\n        delete node.attributes.transform;\n      },\n    },\n  };\n};\nexports.applyTransforms = applyTransforms;\n\n/**\n * @type {(matrix: Matrix, x: number, y: number) => [number, number]}\n */\nconst transformAbsolutePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y + matrix[4];\n  const newY = matrix[1] * x + matrix[3] * y + matrix[5];\n  return [newX, newY];\n};\n\n/**\n * @type {(matrix: Matrix, x: number, y: number) => [number, number]}\n */\nconst transformRelativePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y;\n  const newY = matrix[1] * x + matrix[3] * y;\n  return [newX, newY];\n};\n\n/**\n * @type {(pathData: PathData, matrix: Matrix) => void}\n */\nconst applyMatrixToPathData = (pathData, matrix) => {\n  /**\n   * @type {[number, number]}\n   */\n  const start = [0, 0];\n  /**\n   * @type {[number, number]}\n   */\n  const cursor = [0, 0];\n\n  for (const pathItem of pathData) {\n    let { command, args } = pathItem;\n\n    // moveto (x y)\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 'm') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // horizontal lineto (x)\n    // convert to lineto to handle two-dimentional transforms\n    if (command === 'H') {\n      command = 'L';\n      args = [args[0], cursor[1]];\n    }\n    if (command === 'h') {\n      command = 'l';\n      args = [args[0], 0];\n    }\n\n    // vertical lineto (y)\n    // convert to lineto to handle two-dimentional transforms\n    if (command === 'V') {\n      command = 'L';\n      args = [cursor[0], args[0]];\n    }\n    if (command === 'v') {\n      command = 'l';\n      args = [0, args[0]];\n    }\n\n    // lineto (x y)\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);\n      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    }\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);\n      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    }\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    }\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'A') {\n      transformArc(cursor, args, matrix);\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n      // reduce number of digits in rotation angle\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    }\n    if (command === 'a') {\n      transformArc([0, 0], args, matrix);\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n      // reduce number of digits in rotation angle\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    }\n\n    // closepath\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n\n    pathItem.command = command;\n    pathItem.args = args;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}