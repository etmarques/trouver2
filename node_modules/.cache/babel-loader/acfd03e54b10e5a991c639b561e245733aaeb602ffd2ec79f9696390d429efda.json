{"ast":null,"code":"'use strict';\n\nvar core = require('@babel/core');\nconst elements = [\"svg\", \"Svg\"];\nconst createTagElement = function (tag) {\n  let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const eleName = core.types.jsxIdentifier(tag);\n  return core.types.jsxElement(core.types.jsxOpeningElement(eleName, attributes), core.types.jsxClosingElement(eleName), children);\n};\nconst createTagIdAttribute = tag => core.types.jsxAttribute(core.types.jsxIdentifier(\"id\"), core.types.jsxExpressionContainer(core.types.identifier(`${tag}Id`)));\nconst addTagIdAttribute = (tag, attributes) => {\n  const existingId = attributes.find(attribute => core.types.isJSXAttribute(attribute) && attribute.name.name === \"id\");\n  if (!existingId) {\n    return [...attributes, createTagIdAttribute(tag)];\n  }\n  existingId.value = core.types.jsxExpressionContainer(core.types.isStringLiteral(existingId.value) ? core.types.logicalExpression(\"||\", core.types.identifier(`${tag}Id`), existingId.value) : core.types.identifier(`${tag}Id`));\n  return attributes;\n};\nconst plugin = () => ({\n  visitor: {\n    JSXElement(path, state) {\n      const tag = state.opts.tag || \"title\";\n      if (!elements.length) return;\n      const openingElement = path.get(\"openingElement\");\n      const openingElementName = openingElement.get(\"name\");\n      if (!elements.some(element => openingElementName.isJSXIdentifier({\n        name: element\n      }))) {\n        return;\n      }\n      const getTagElement = existingTitle => {\n        var _a;\n        const tagExpression = core.types.identifier(tag);\n        if (existingTitle) {\n          existingTitle.openingElement.attributes = addTagIdAttribute(tag, existingTitle.openingElement.attributes);\n        }\n        const conditionalTitle = core.types.conditionalExpression(tagExpression, createTagElement(tag, [core.types.jsxExpressionContainer(tagExpression)], existingTitle ? existingTitle.openingElement.attributes : [createTagIdAttribute(tag)]), core.types.nullLiteral());\n        if ((_a = existingTitle == null ? void 0 : existingTitle.children) == null ? void 0 : _a.length) {\n          return core.types.jsxExpressionContainer(core.types.conditionalExpression(core.types.binaryExpression(\"===\", tagExpression, core.types.identifier(\"undefined\")), existingTitle, conditionalTitle));\n        }\n        return core.types.jsxExpressionContainer(conditionalTitle);\n      };\n      let tagElement = null;\n      const hasTitle = path.get(\"children\").some(childPath => {\n        if (childPath.node === tagElement) return false;\n        if (!childPath.isJSXElement()) return false;\n        const name = childPath.get(\"openingElement\").get(\"name\");\n        if (!name.isJSXIdentifier()) return false;\n        if (name.node.name !== tag) return false;\n        tagElement = getTagElement(childPath.node);\n        childPath.replaceWith(tagElement);\n        return true;\n      });\n      tagElement = tagElement || getTagElement();\n      if (!hasTitle) {\n        path.node.children.unshift(tagElement);\n        path.replaceWith(path.node);\n      }\n    }\n  }\n});\nmodule.exports = plugin;","map":{"version":3,"names":["elements","createTagElement","tag","children","arguments","length","undefined","attributes","eleName","core","types","jsxIdentifier","jsxElement","jsxOpeningElement","jsxClosingElement","createTagIdAttribute","jsxAttribute","jsxExpressionContainer","identifier","addTagIdAttribute","existingId","find","attribute","isJSXAttribute","name","value","isStringLiteral","logicalExpression","plugin","visitor","JSXElement","path","state","opts","openingElement","get","openingElementName","some","element","isJSXIdentifier","getTagElement","existingTitle","_a","tagExpression","conditionalTitle","conditionalExpression","nullLiteral","binaryExpression","tagElement","hasTitle","childPath","node","isJSXElement","replaceWith","unshift"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@svgr\\babel-plugin-svg-dynamic-title\\src\\index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { NodePath, types as t } from '@babel/core'\n\nconst elements = ['svg', 'Svg']\n\ntype tag = 'title' | 'desc'\n\nexport interface Options {\n  tag: tag | null\n}\n\ninterface State {\n  opts: Options\n}\n\nconst createTagElement = (\n  tag: tag,\n  children: t.JSXExpressionContainer[] = [],\n  attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[] = [],\n) => {\n  const eleName = t.jsxIdentifier(tag)\n  return t.jsxElement(\n    t.jsxOpeningElement(eleName, attributes),\n    t.jsxClosingElement(eleName),\n    children,\n  )\n}\n\nconst createTagIdAttribute = (tag: tag) =>\n  t.jsxAttribute(\n    t.jsxIdentifier('id'),\n    t.jsxExpressionContainer(t.identifier(`${tag}Id`)),\n  )\n\nconst addTagIdAttribute = (\n  tag: tag,\n  attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[],\n) => {\n  const existingId = attributes.find(\n    (attribute) => t.isJSXAttribute(attribute) && attribute.name.name === 'id',\n  ) as t.JSXAttribute | undefined\n\n  if (!existingId) {\n    return [...attributes, createTagIdAttribute(tag)]\n  }\n  existingId.value = t.jsxExpressionContainer(\n    t.isStringLiteral(existingId.value)\n      ? t.logicalExpression('||', t.identifier(`${tag}Id`), existingId.value)\n      : t.identifier(`${tag}Id`),\n  )\n  return attributes\n}\n\nconst plugin = () => ({\n  visitor: {\n    JSXElement(path: NodePath<t.JSXElement>, state: State) {\n      const tag = state.opts.tag || 'title'\n      if (!elements.length) return\n\n      const openingElement = path.get('openingElement')\n      const openingElementName = openingElement.get('name')\n      if (\n        !elements.some((element) =>\n          openingElementName.isJSXIdentifier({ name: element }),\n        )\n      ) {\n        return\n      }\n\n      const getTagElement = (\n        existingTitle?: t.JSXElement,\n      ): t.JSXExpressionContainer => {\n        const tagExpression = t.identifier(tag)\n        if (existingTitle) {\n          existingTitle.openingElement.attributes = addTagIdAttribute(\n            tag,\n            existingTitle.openingElement.attributes,\n          )\n        }\n        const conditionalTitle = t.conditionalExpression(\n          tagExpression,\n          createTagElement(\n            tag,\n            [t.jsxExpressionContainer(tagExpression)],\n            existingTitle\n              ? existingTitle.openingElement.attributes\n              : [createTagIdAttribute(tag)],\n          ),\n          t.nullLiteral(),\n        )\n        if (existingTitle?.children?.length) {\n          // If title already exists render as follows\n          // `{title === undefined ? fallbackTitleElement : titleElement}`\n          return t.jsxExpressionContainer(\n            t.conditionalExpression(\n              t.binaryExpression(\n                '===',\n                tagExpression,\n                t.identifier('undefined'),\n              ),\n              existingTitle,\n              conditionalTitle,\n            ),\n          )\n        }\n        return t.jsxExpressionContainer(conditionalTitle)\n      }\n\n      // store the title element\n      let tagElement: t.JSXExpressionContainer | null = null\n\n      const hasTitle = path.get('children').some((childPath) => {\n        if (childPath.node === tagElement) return false\n        if (!childPath.isJSXElement()) return false\n        const name = childPath.get('openingElement').get('name')\n        if (!name.isJSXIdentifier()) return false\n        if (name.node.name !== tag) return false\n        tagElement = getTagElement(childPath.node)\n        childPath.replaceWith(tagElement)\n        return true\n      })\n\n      // create a title element if not already create\n      tagElement = tagElement || getTagElement()\n      if (!hasTitle) {\n        // path.unshiftContainer is not working well :(\n        // path.unshiftContainer('children', titleElement)\n        path.node.children.unshift(tagElement)\n        path.replaceWith(path.node)\n      }\n    },\n  },\n})\n\nexport default plugin\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}