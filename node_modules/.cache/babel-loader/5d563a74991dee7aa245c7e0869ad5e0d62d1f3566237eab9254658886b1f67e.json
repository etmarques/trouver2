{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\nconst {\n  parsePathData,\n  stringifyPathData\n} = require('../lib/path.js');\n\n/**\n * @type {[number, number]}\n */\nvar prevCtrlPoint;\n\n/**\n * Convert path string to JS representation.\n *\n * @type {(path: XastElement) => Array<PathDataItem>}\n */\nconst path2js = path => {\n  // @ts-ignore legacy\n  if (path.pathJS) return path.pathJS;\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = []; // JS representation of the path data\n  const newPathData = parsePathData(path.attributes.d);\n  for (const {\n    command,\n    args\n  } of newPathData) {\n    pathData.push({\n      command,\n      args\n    });\n  }\n  // First moveto is actually absolute. Subsequent coordinates were separated above.\n  if (pathData.length && pathData[0].command == 'm') {\n    pathData[0].command = 'M';\n  }\n  // @ts-ignore legacy\n  path.pathJS = pathData;\n  return pathData;\n};\nexports.path2js = path2js;\n\n/**\n * Convert relative Path data to absolute.\n *\n * @type {(data: Array<PathDataItem>) => Array<PathDataItem>}\n *\n */\nconst convertRelativeToAbsolute = data => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const newData = [];\n  let start = [0, 0];\n  let cursor = [0, 0];\n  for (let {\n    command,\n    args\n  } of data) {\n    args = args.slice();\n\n    // moveto (x y)\n    if (command === 'm') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'M';\n    }\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    // horizontal lineto (x)\n    if (command === 'h') {\n      args[0] += cursor[0];\n      command = 'H';\n    }\n    if (command === 'H') {\n      cursor[0] = args[0];\n    }\n\n    // vertical lineto (y)\n    if (command === 'v') {\n      args[0] += cursor[1];\n      command = 'V';\n    }\n    if (command === 'V') {\n      cursor[1] = args[0];\n    }\n\n    // lineto (x y)\n    if (command === 'l') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'L';\n    }\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'c') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      args[4] += cursor[0];\n      args[5] += cursor[1];\n      command = 'C';\n    }\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 's') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'S';\n    }\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'q') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'Q';\n    }\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 't') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'T';\n    }\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'a') {\n      args[5] += cursor[0];\n      args[6] += cursor[1];\n      command = 'A';\n    }\n    if (command === 'A') {\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n    }\n\n    // closepath\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n      command = 'z';\n    }\n    newData.push({\n      command,\n      args\n    });\n  }\n  return newData;\n};\n\n/**\n * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams\n */\n\n/**\n * Convert path array to string.\n *\n * @type {(path: XastElement, data: Array<PathDataItem>, params: Js2PathParams) => void}\n */\nexports.js2path = function (path, data, params) {\n  // @ts-ignore legacy\n  path.pathJS = data;\n  const pathData = [];\n  for (const item of data) {\n    // remove moveto commands which are followed by moveto commands\n    if (pathData.length !== 0 && (item.command === 'M' || item.command === 'm')) {\n      const last = pathData[pathData.length - 1];\n      if (last.command === 'M' || last.command === 'm') {\n        pathData.pop();\n      }\n    }\n    pathData.push({\n      command: item.command,\n      args: item.args\n    });\n  }\n  path.attributes.d = stringifyPathData({\n    pathData,\n    precision: params.floatPrecision,\n    disableSpaceAfterFlags: params.noSpaceAfterFlags\n  });\n};\n\n/**\n * @type {(dest: Array<number>, source: Array<number>) => Array<number>}\n */\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @type {(path1: Array<PathDataItem>, path2: Array<PathDataItem>) => boolean}\n */\nexports.intersects = function (path1, path2) {\n  // Collect points of every subpath.\n  const points1 = gatherPoints(convertRelativeToAbsolute(path1));\n  const points2 = gatherPoints(convertRelativeToAbsolute(path2));\n\n  // Axis-aligned bounding box check.\n  if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.list.every(set1 => {\n    return points2.list.every(set2 => {\n      return set1.list[set1.maxX][0] <= set2.list[set2.minX][0] || set2.list[set2.maxX][0] <= set1.list[set1.minX][0] || set1.list[set1.maxY][1] <= set2.list[set2.minY][1] || set2.list[set2.maxY][1] <= set1.list[set1.minY][1];\n    });\n  })) return false;\n\n  // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n  const hullNest1 = points1.list.map(convexHull);\n  const hullNest2 = points2.list.map(convexHull);\n\n  // Check intersection of every subpath of the first path with every subpath of the second.\n  return hullNest1.some(function (hull1) {\n    if (hull1.list.length < 3) return false;\n    return hullNest2.some(function (hull2) {\n      if (hull2.list.length < 3) return false;\n      var simplex = [getSupport(hull1, hull2, [1, 0])],\n        // create the initial simplex\n        direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // eslint-disable-next-line no-constant-condition\n        if (iterations-- == 0) {\n          console.error('Error: infinite loop while processing mergePaths plugin.');\n          return true; // true is the safe value that means “do nothing with paths”\n        }\n        // add a new point\n        simplex.push(getSupport(hull1, hull2, direction));\n        // see if the new point was on the correct side of the origin\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;\n        // process the simplex\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n\n  /**\n   * @type {(a: Point, b: Point, direction: Array<number>) => Array<number>}\n   */\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  }\n\n  // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n  /**\n   * @type {(polygon: Point, direction: Array<number>) => Array<number>}\n   */\n  function supportPoint(polygon, direction) {\n    var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY,\n      max = -Infinity,\n      value;\n    while ((value = dot(polygon.list[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.list.length;\n    }\n    return polygon.list[(index || polygon.list.length) - 1];\n  }\n};\n\n/**\n * @type {(simplex: Array<Array<number>>, direction: Array<number>) => boolean}\n */\nfunction processSimplex(simplex, direction) {\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    let a = simplex[1],\n      b = simplex[0],\n      AO = minus(simplex[1]),\n      AB = sub(b, a);\n    // AO is in the same direction as AB\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO);\n      // only A remains in the simplex\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    let a = simplex[2],\n      // [a, b, c] = simplex\n      b = simplex[1],\n      c = simplex[0],\n      AB = sub(b, a),\n      AC = sub(c, a),\n      AO = minus(a),\n      ACB = orth(AB, AC),\n      // the vector perpendicular to AB facing away from C\n      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } // region 7\n    else return true;\n  }\n  return false;\n}\n\n/**\n * @type {(v: Array<number>) => Array<number>}\n */\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => number}\n */\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\n/**\n * @typedef {{\n *   list: Array<Array<number>>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Point\n */\n\n/**\n * @typedef {{\n *   list: Array<Point>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Points\n */\n\n/**\n * @type {(pathData: Array<PathDataItem>) => Points}\n */\nfunction gatherPoints(pathData) {\n  /**\n   * @type {Points}\n   */\n  const points = {\n    list: [],\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0\n  };\n\n  // Writes data about the extreme points on each axle\n  /**\n   * @type {(path: Point, point: Array<number>) => void}\n   */\n  const addPoint = (path, point) => {\n    if (!path.list.length || point[1] > path.list[path.maxY][1]) {\n      path.maxY = path.list.length;\n      points.maxY = points.list.length ? Math.max(point[1], points.maxY) : point[1];\n    }\n    if (!path.list.length || point[0] > path.list[path.maxX][0]) {\n      path.maxX = path.list.length;\n      points.maxX = points.list.length ? Math.max(point[0], points.maxX) : point[0];\n    }\n    if (!path.list.length || point[1] < path.list[path.minY][1]) {\n      path.minY = path.list.length;\n      points.minY = points.list.length ? Math.min(point[1], points.minY) : point[1];\n    }\n    if (!path.list.length || point[0] < path.list[path.minX][0]) {\n      path.minX = path.list.length;\n      points.minX = points.list.length ? Math.min(point[0], points.minX) : point[0];\n    }\n    path.list.push(point);\n  };\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathDataItem = pathData[i];\n    let subPath = points.list.length === 0 ? {\n      list: [],\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0\n    } : points.list[points.list.length - 1];\n    let prev = i === 0 ? null : pathData[i - 1];\n    let basePoint = subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];\n    let data = pathDataItem.args;\n    let ctrlPoint = basePoint;\n\n    /**\n     * @type {(n: number, i: number) => number}\n     * TODO fix null hack\n     */\n    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);\n    switch (pathDataItem.command) {\n      case 'M':\n        subPath = {\n          list: [],\n          minX: 0,\n          minY: 0,\n          maxX: 0,\n          maxY: 0\n        };\n        points.list.push(subPath);\n        break;\n      case 'H':\n        if (basePoint != null) {\n          addPoint(subPath, [data[0], basePoint[1]]);\n        }\n        break;\n      case 'V':\n        if (basePoint != null) {\n          addPoint(subPath, [basePoint[0], data[0]]);\n        }\n        break;\n      case 'Q':\n        addPoint(subPath, data.slice(0, 2));\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n        break;\n      case 'T':\n        if (basePoint != null && prev != null && (prev.command == 'Q' || prev.command == 'T')) {\n          ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n          addPoint(subPath, ctrlPoint);\n          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n        }\n        break;\n      case 'C':\n        if (basePoint != null) {\n          // Approximate quibic Bezier curve with middle points between control points\n          addPoint(subPath, [0.5 * (basePoint[0] + data[0]), 0.5 * (basePoint[1] + data[1])]);\n        }\n        addPoint(subPath, [0.5 * (data[0] + data[2]), 0.5 * (data[1] + data[3])]);\n        addPoint(subPath, [0.5 * (data[2] + data[4]), 0.5 * (data[3] + data[5])]);\n        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n        break;\n      case 'S':\n        if (basePoint != null && prev != null && (prev.command == 'C' || prev.command == 'S')) {\n          addPoint(subPath, [basePoint[0] + 0.5 * prevCtrlPoint[0], basePoint[1] + 0.5 * prevCtrlPoint[1]]);\n          ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n        }\n        if (ctrlPoint != null) {\n          addPoint(subPath, [0.5 * (ctrlPoint[0] + data[0]), 0.5 * (ctrlPoint[1] + data[1])]);\n        }\n        addPoint(subPath, [0.5 * (data[0] + data[2]), 0.5 * (data[1] + data[3])]);\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n        break;\n      case 'A':\n        if (basePoint != null) {\n          // Convert the arc to bezier curves and use the same approximation\n          // @ts-ignore no idea what's going on here\n          var curves = a2c.apply(0, basePoint.concat(data));\n          for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length;) {\n            if (basePoint != null) {\n              addPoint(subPath, [0.5 * (basePoint[0] + cData[0]), 0.5 * (basePoint[1] + cData[1])]);\n            }\n            addPoint(subPath, [0.5 * (cData[0] + cData[2]), 0.5 * (cData[1] + cData[3])]);\n            addPoint(subPath, [0.5 * (cData[2] + cData[4]), 0.5 * (cData[3] + cData[5])]);\n            if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n          }\n        }\n        break;\n    }\n\n    // Save final command coordinates\n    if (data.length >= 2) addPoint(subPath, data.slice(-2));\n  }\n  return points;\n}\n\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @type {(points: Point) => Point}\n */\nfunction convexHull(points) {\n  points.list.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n  var lower = [],\n    minY = 0,\n    bottom = 0;\n  for (let i = 0; i < points.list.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <= 0) {\n      lower.pop();\n    }\n    if (points.list[i][1] < points.list[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n    lower.push(points.list[i]);\n  }\n  var upper = [],\n    maxY = points.list.length - 1,\n    top = 0;\n  for (let i = points.list.length; i--;) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <= 0) {\n      upper.pop();\n    }\n    if (points.list[i][1] > points.list[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n    upper.push(points.list[i]);\n  }\n\n  // last points are equal to starting points of the other part\n  upper.pop();\n  lower.pop();\n  const hullList = lower.concat(upper);\n\n  /**\n   * @type {Point}\n   */\n  const hull = {\n    list: hullList,\n    minX: 0,\n    // by sorting\n    maxX: lower.length,\n    minY: bottom,\n    maxY: (lower.length + top) % hullList.length\n  };\n  return hull;\n}\n\n/**\n * @type {(o: Array<number>, a: Array<number>, b: Array<number>) => number}\n */\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\n/**\n * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n *\n * @type {(\n *  x1: number,\n *  y1: number,\n *  rx: number,\n *  ry: number,\n *  angle: number,\n *  large_arc_flag: number,\n *  sweep_flag: number,\n *  x2: number,\n *  y2: number,\n *  recursive: Array<number>\n * ) => Array<number>}\n */\nconst a2c = (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) => {\n  // for more information of where this Math came from visit:\n  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const _120 = Math.PI * 120 / 180;\n  const rad = Math.PI / 180 * (+angle || 0);\n  /**\n   * @type {Array<number>}\n   */\n  let res = [];\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateX = (x, y, rad) => {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  };\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateY = (x, y, rad) => {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n      y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n    var cx = k * rx * y / ry + (x1 + x2) / 2;\n    var cy = k * -ry * x / rx + (y1 + y2) / 2;\n    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));\n    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n  var df = f2 - f1;\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n      x2old = x2,\n      y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n    s1 = Math.sin(f1),\n    c2 = Math.cos(f2),\n    s2 = Math.sin(f2),\n    t = Math.tan(df / 4),\n    hx = 4 / 3 * rx * t,\n    hy = 4 / 3 * ry * t,\n    m = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n    }\n    return newres;\n  }\n};","map":{"version":3,"names":["parsePathData","stringifyPathData","require","prevCtrlPoint","path2js","path","pathJS","pathData","newPathData","attributes","d","command","args","push","length","exports","convertRelativeToAbsolute","data","newData","start","cursor","slice","js2path","params","item","last","pop","precision","floatPrecision","disableSpaceAfterFlags","noSpaceAfterFlags","set","dest","source","intersects","path1","path2","points1","gatherPoints","points2","maxX","minX","maxY","minY","list","every","set1","set2","hullNest1","map","convexHull","hullNest2","some","hull1","hull2","simplex","getSupport","direction","minus","iterations","console","error","dot","processSimplex","a","b","sub","supportPoint","polygon","index","max","Infinity","value","AO","AB","orth","shift","c","AC","ACB","ABC","splice","v","v1","v2","from","o","points","addPoint","point","Math","min","i","pathDataItem","subPath","prev","basePoint","ctrlPoint","toAbsolute","n","curves","a2c","apply","concat","cData","sort","lower","bottom","cross","upper","top","hullList","hull","x1","y1","rx","ry","angle","large_arc_flag","sweep_flag","x2","y2","recursive","_120","PI","rad","res","rotateX","x","y","cos","sin","rotateY","h","sqrt","rx2","ry2","k","abs","cx","cy","f1","asin","Number","toFixed","f2","df","f2old","x2old","y2old","c1","s1","c2","s2","t","tan","hx","hy","m","newres"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/_path.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { parsePathData, stringifyPathData } = require('../lib/path.js');\n\n/**\n * @type {[number, number]}\n */\nvar prevCtrlPoint;\n\n/**\n * Convert path string to JS representation.\n *\n * @type {(path: XastElement) => Array<PathDataItem>}\n */\nconst path2js = (path) => {\n  // @ts-ignore legacy\n  if (path.pathJS) return path.pathJS;\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = []; // JS representation of the path data\n  const newPathData = parsePathData(path.attributes.d);\n  for (const { command, args } of newPathData) {\n    pathData.push({ command, args });\n  }\n  // First moveto is actually absolute. Subsequent coordinates were separated above.\n  if (pathData.length && pathData[0].command == 'm') {\n    pathData[0].command = 'M';\n  }\n  // @ts-ignore legacy\n  path.pathJS = pathData;\n  return pathData;\n};\nexports.path2js = path2js;\n\n/**\n * Convert relative Path data to absolute.\n *\n * @type {(data: Array<PathDataItem>) => Array<PathDataItem>}\n *\n */\nconst convertRelativeToAbsolute = (data) => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const newData = [];\n  let start = [0, 0];\n  let cursor = [0, 0];\n\n  for (let { command, args } of data) {\n    args = args.slice();\n\n    // moveto (x y)\n    if (command === 'm') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'M';\n    }\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    // horizontal lineto (x)\n    if (command === 'h') {\n      args[0] += cursor[0];\n      command = 'H';\n    }\n    if (command === 'H') {\n      cursor[0] = args[0];\n    }\n\n    // vertical lineto (y)\n    if (command === 'v') {\n      args[0] += cursor[1];\n      command = 'V';\n    }\n    if (command === 'V') {\n      cursor[1] = args[0];\n    }\n\n    // lineto (x y)\n    if (command === 'l') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'L';\n    }\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'c') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      args[4] += cursor[0];\n      args[5] += cursor[1];\n      command = 'C';\n    }\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 's') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'S';\n    }\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'q') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'Q';\n    }\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 't') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'T';\n    }\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'a') {\n      args[5] += cursor[0];\n      args[6] += cursor[1];\n      command = 'A';\n    }\n    if (command === 'A') {\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n    }\n\n    // closepath\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n      command = 'z';\n    }\n\n    newData.push({ command, args });\n  }\n  return newData;\n};\n\n/**\n * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams\n */\n\n/**\n * Convert path array to string.\n *\n * @type {(path: XastElement, data: Array<PathDataItem>, params: Js2PathParams) => void}\n */\nexports.js2path = function (path, data, params) {\n  // @ts-ignore legacy\n  path.pathJS = data;\n\n  const pathData = [];\n  for (const item of data) {\n    // remove moveto commands which are followed by moveto commands\n    if (\n      pathData.length !== 0 &&\n      (item.command === 'M' || item.command === 'm')\n    ) {\n      const last = pathData[pathData.length - 1];\n      if (last.command === 'M' || last.command === 'm') {\n        pathData.pop();\n      }\n    }\n    pathData.push({\n      command: item.command,\n      args: item.args,\n    });\n  }\n\n  path.attributes.d = stringifyPathData({\n    pathData,\n    precision: params.floatPrecision,\n    disableSpaceAfterFlags: params.noSpaceAfterFlags,\n  });\n};\n\n/**\n * @type {(dest: Array<number>, source: Array<number>) => Array<number>}\n */\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @type {(path1: Array<PathDataItem>, path2: Array<PathDataItem>) => boolean}\n */\nexports.intersects = function (path1, path2) {\n  // Collect points of every subpath.\n  const points1 = gatherPoints(convertRelativeToAbsolute(path1));\n  const points2 = gatherPoints(convertRelativeToAbsolute(path2));\n\n  // Axis-aligned bounding box check.\n  if (\n    points1.maxX <= points2.minX ||\n    points2.maxX <= points1.minX ||\n    points1.maxY <= points2.minY ||\n    points2.maxY <= points1.minY ||\n    points1.list.every((set1) => {\n      return points2.list.every((set2) => {\n        return (\n          set1.list[set1.maxX][0] <= set2.list[set2.minX][0] ||\n          set2.list[set2.maxX][0] <= set1.list[set1.minX][0] ||\n          set1.list[set1.maxY][1] <= set2.list[set2.minY][1] ||\n          set2.list[set2.maxY][1] <= set1.list[set1.minY][1]\n        );\n      });\n    })\n  )\n    return false;\n\n  // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n  const hullNest1 = points1.list.map(convexHull);\n  const hullNest2 = points2.list.map(convexHull);\n\n  // Check intersection of every subpath of the first path with every subpath of the second.\n  return hullNest1.some(function (hull1) {\n    if (hull1.list.length < 3) return false;\n\n    return hullNest2.some(function (hull2) {\n      if (hull2.list.length < 3) return false;\n\n      var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex\n        direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // eslint-disable-next-line no-constant-condition\n        if (iterations-- == 0) {\n          console.error(\n            'Error: infinite loop while processing mergePaths plugin.'\n          );\n          return true; // true is the safe value that means “do nothing with paths”\n        }\n        // add a new point\n        simplex.push(getSupport(hull1, hull2, direction));\n        // see if the new point was on the correct side of the origin\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;\n        // process the simplex\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n\n  /**\n   * @type {(a: Point, b: Point, direction: Array<number>) => Array<number>}\n   */\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  }\n\n  // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n  /**\n   * @type {(polygon: Point, direction: Array<number>) => Array<number>}\n   */\n  function supportPoint(polygon, direction) {\n    var index =\n        direction[1] >= 0\n          ? direction[0] < 0\n            ? polygon.maxY\n            : polygon.maxX\n          : direction[0] < 0\n          ? polygon.minX\n          : polygon.minY,\n      max = -Infinity,\n      value;\n    while ((value = dot(polygon.list[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.list.length;\n    }\n    return polygon.list[(index || polygon.list.length) - 1];\n  }\n};\n\n/**\n * @type {(simplex: Array<Array<number>>, direction: Array<number>) => boolean}\n */\nfunction processSimplex(simplex, direction) {\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    let a = simplex[1],\n      b = simplex[0],\n      AO = minus(simplex[1]),\n      AB = sub(b, a);\n    // AO is in the same direction as AB\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO);\n      // only A remains in the simplex\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    let a = simplex[2], // [a, b, c] = simplex\n      b = simplex[1],\n      c = simplex[0],\n      AB = sub(b, a),\n      AC = sub(c, a),\n      AO = minus(a),\n      ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C\n      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } // region 7\n    else return true;\n  }\n  return false;\n}\n\n/**\n * @type {(v: Array<number>) => Array<number>}\n */\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => number}\n */\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\n/**\n * @typedef {{\n *   list: Array<Array<number>>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Point\n */\n\n/**\n * @typedef {{\n *   list: Array<Point>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Points\n */\n\n/**\n * @type {(pathData: Array<PathDataItem>) => Points}\n */\nfunction gatherPoints(pathData) {\n  /**\n   * @type {Points}\n   */\n  const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };\n\n  // Writes data about the extreme points on each axle\n  /**\n   * @type {(path: Point, point: Array<number>) => void}\n   */\n  const addPoint = (path, point) => {\n    if (!path.list.length || point[1] > path.list[path.maxY][1]) {\n      path.maxY = path.list.length;\n      points.maxY = points.list.length\n        ? Math.max(point[1], points.maxY)\n        : point[1];\n    }\n    if (!path.list.length || point[0] > path.list[path.maxX][0]) {\n      path.maxX = path.list.length;\n      points.maxX = points.list.length\n        ? Math.max(point[0], points.maxX)\n        : point[0];\n    }\n    if (!path.list.length || point[1] < path.list[path.minY][1]) {\n      path.minY = path.list.length;\n      points.minY = points.list.length\n        ? Math.min(point[1], points.minY)\n        : point[1];\n    }\n    if (!path.list.length || point[0] < path.list[path.minX][0]) {\n      path.minX = path.list.length;\n      points.minX = points.list.length\n        ? Math.min(point[0], points.minX)\n        : point[0];\n    }\n    path.list.push(point);\n  };\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathDataItem = pathData[i];\n    let subPath =\n      points.list.length === 0\n        ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }\n        : points.list[points.list.length - 1];\n    let prev = i === 0 ? null : pathData[i - 1];\n    let basePoint =\n      subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];\n    let data = pathDataItem.args;\n    let ctrlPoint = basePoint;\n\n    /**\n     * @type {(n: number, i: number) => number}\n     * TODO fix null hack\n     */\n    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);\n\n    switch (pathDataItem.command) {\n      case 'M':\n        subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };\n        points.list.push(subPath);\n        break;\n\n      case 'H':\n        if (basePoint != null) {\n          addPoint(subPath, [data[0], basePoint[1]]);\n        }\n        break;\n\n      case 'V':\n        if (basePoint != null) {\n          addPoint(subPath, [basePoint[0], data[0]]);\n        }\n        break;\n\n      case 'Q':\n        addPoint(subPath, data.slice(0, 2));\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n        break;\n\n      case 'T':\n        if (\n          basePoint != null &&\n          prev != null &&\n          (prev.command == 'Q' || prev.command == 'T')\n        ) {\n          ctrlPoint = [\n            basePoint[0] + prevCtrlPoint[0],\n            basePoint[1] + prevCtrlPoint[1],\n          ];\n          addPoint(subPath, ctrlPoint);\n          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n        }\n        break;\n\n      case 'C':\n        if (basePoint != null) {\n          // Approximate quibic Bezier curve with middle points between control points\n          addPoint(subPath, [\n            0.5 * (basePoint[0] + data[0]),\n            0.5 * (basePoint[1] + data[1]),\n          ]);\n        }\n        addPoint(subPath, [\n          0.5 * (data[0] + data[2]),\n          0.5 * (data[1] + data[3]),\n        ]);\n        addPoint(subPath, [\n          0.5 * (data[2] + data[4]),\n          0.5 * (data[3] + data[5]),\n        ]);\n        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n        break;\n\n      case 'S':\n        if (\n          basePoint != null &&\n          prev != null &&\n          (prev.command == 'C' || prev.command == 'S')\n        ) {\n          addPoint(subPath, [\n            basePoint[0] + 0.5 * prevCtrlPoint[0],\n            basePoint[1] + 0.5 * prevCtrlPoint[1],\n          ]);\n          ctrlPoint = [\n            basePoint[0] + prevCtrlPoint[0],\n            basePoint[1] + prevCtrlPoint[1],\n          ];\n        }\n        if (ctrlPoint != null) {\n          addPoint(subPath, [\n            0.5 * (ctrlPoint[0] + data[0]),\n            0.5 * (ctrlPoint[1] + data[1]),\n          ]);\n        }\n        addPoint(subPath, [\n          0.5 * (data[0] + data[2]),\n          0.5 * (data[1] + data[3]),\n        ]);\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n        break;\n\n      case 'A':\n        if (basePoint != null) {\n          // Convert the arc to bezier curves and use the same approximation\n          // @ts-ignore no idea what's going on here\n          var curves = a2c.apply(0, basePoint.concat(data));\n          for (\n            var cData;\n            (cData = curves.splice(0, 6).map(toAbsolute)).length;\n\n          ) {\n            if (basePoint != null) {\n              addPoint(subPath, [\n                0.5 * (basePoint[0] + cData[0]),\n                0.5 * (basePoint[1] + cData[1]),\n              ]);\n            }\n            addPoint(subPath, [\n              0.5 * (cData[0] + cData[2]),\n              0.5 * (cData[1] + cData[3]),\n            ]);\n            addPoint(subPath, [\n              0.5 * (cData[2] + cData[4]),\n              0.5 * (cData[3] + cData[5]),\n            ]);\n            if (curves.length) addPoint(subPath, (basePoint = cData.slice(-2)));\n          }\n        }\n        break;\n    }\n\n    // Save final command coordinates\n    if (data.length >= 2) addPoint(subPath, data.slice(-2));\n  }\n\n  return points;\n}\n\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @type {(points: Point) => Point}\n */\nfunction convexHull(points) {\n  points.list.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n\n  var lower = [],\n    minY = 0,\n    bottom = 0;\n  for (let i = 0; i < points.list.length; i++) {\n    while (\n      lower.length >= 2 &&\n      cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <=\n        0\n    ) {\n      lower.pop();\n    }\n    if (points.list[i][1] < points.list[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n    lower.push(points.list[i]);\n  }\n\n  var upper = [],\n    maxY = points.list.length - 1,\n    top = 0;\n  for (let i = points.list.length; i--; ) {\n    while (\n      upper.length >= 2 &&\n      cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <=\n        0\n    ) {\n      upper.pop();\n    }\n    if (points.list[i][1] > points.list[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n    upper.push(points.list[i]);\n  }\n\n  // last points are equal to starting points of the other part\n  upper.pop();\n  lower.pop();\n\n  const hullList = lower.concat(upper);\n\n  /**\n   * @type {Point}\n   */\n  const hull = {\n    list: hullList,\n    minX: 0, // by sorting\n    maxX: lower.length,\n    minY: bottom,\n    maxY: (lower.length + top) % hullList.length,\n  };\n\n  return hull;\n}\n\n/**\n * @type {(o: Array<number>, a: Array<number>, b: Array<number>) => number}\n */\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\n/**\n * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n *\n * @type {(\n *  x1: number,\n *  y1: number,\n *  rx: number,\n *  ry: number,\n *  angle: number,\n *  large_arc_flag: number,\n *  sweep_flag: number,\n *  x2: number,\n *  y2: number,\n *  recursive: Array<number>\n * ) => Array<number>}\n */\nconst a2c = (\n  x1,\n  y1,\n  rx,\n  ry,\n  angle,\n  large_arc_flag,\n  sweep_flag,\n  x2,\n  y2,\n  recursive\n) => {\n  // for more information of where this Math came from visit:\n  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const _120 = (Math.PI * 120) / 180;\n  const rad = (Math.PI / 180) * (+angle || 0);\n  /**\n   * @type {Array<number>}\n   */\n  let res = [];\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateX = (x, y, rad) => {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  };\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateY = (x, y, rad) => {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n      y = (y1 - y2) / 2;\n    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k =\n      (large_arc_flag == sweep_flag ? -1 : 1) *\n      Math.sqrt(\n        Math.abs(\n          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)\n        )\n      );\n    var cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    var cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));\n    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n  var df = f2 - f1;\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n      x2old = x2,\n      y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [\n      f2,\n      f2old,\n      cx,\n      cy,\n    ]);\n  }\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n    s1 = Math.sin(f1),\n    c2 = Math.cos(f2),\n    s2 = Math.sin(f2),\n    t = Math.tan(df / 4),\n    hx = (4 / 3) * rx * t,\n    hy = (4 / 3) * ry * t,\n    m = [\n      -hx * s1,\n      hy * c1,\n      x2 + hx * s2 - x1,\n      y2 - hy * c2 - y1,\n      x2 - x1,\n      y2 - y1,\n    ];\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] =\n        i % 2\n          ? rotateY(res[i - 1], res[i], rad)\n          : rotateX(res[i], res[i + 1], rad);\n    }\n    return newres;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}