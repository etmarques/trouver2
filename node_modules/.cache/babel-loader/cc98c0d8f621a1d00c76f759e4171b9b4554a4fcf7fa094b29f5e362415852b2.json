{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformClass;\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\nvar _core = require(\"@babel/core\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _inlineCreateSuperHelpers = require(\"./inline-createSuper-helpers\");\nfunction buildConstructor(classRef, constructorBody, node) {\n  const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);\n  _core.types.inherits(func, node);\n  return func;\n}\nfunction transformClass(path, file, builtinClasses, isLoose, assumptions, supportUnicodeId) {\n  const classState = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n    classId: undefined,\n    classRef: undefined,\n    superFnId: undefined,\n    superName: null,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n    body: [],\n    superThises: [],\n    pushedConstructor: false,\n    pushedInherits: false,\n    pushedCreateClass: false,\n    protoAlias: null,\n    isLoose: false,\n    dynamicKeys: new Map(),\n    methods: {\n      instance: {\n        hasComputed: false,\n        list: [],\n        map: new Map()\n      },\n      static: {\n        hasComputed: false,\n        list: [],\n        map: new Map()\n      }\n    }\n  };\n  const setState = newState => {\n    Object.assign(classState, newState);\n  };\n  const findThisesVisitor = _core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {\n    ThisExpression(path) {\n      classState.superThises.push(path);\n    }\n  }]);\n  function createClassHelper(args) {\n    return _core.types.callExpression(classState.file.addHelper(\"createClass\"), args);\n  }\n  function maybeCreateConstructor() {\n    let hasConstructor = false;\n    const paths = classState.path.get(\"body.body\");\n    for (const path of paths) {\n      hasConstructor = path.equals(\"kind\", \"constructor\");\n      if (hasConstructor) break;\n    }\n    if (hasConstructor) return;\n    let params, body;\n    if (classState.isDerived) {\n      const constructor = _core.template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      `;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = _core.types.blockStatement([]);\n    }\n    classState.path.get(\"body\").unshiftContainer(\"body\", _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), params, body));\n  }\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n    if (classState.userConstructor) {\n      const {\n        constructorBody,\n        userConstructor,\n        construct\n      } = classState;\n      constructorBody.body.push(...userConstructor.body.body);\n      _core.types.inherits(construct, userConstructor);\n      _core.types.inherits(constructorBody, userConstructor.body);\n    }\n    pushDescriptors();\n  }\n  function pushBody() {\n    const classBodyPaths = classState.path.get(\"body.body\");\n    for (const path of classBodyPaths) {\n      const node = path.node;\n      if (path.isClassProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\"Method has decorators, put the decorator plugin before the classes one.\");\n      }\n      if (_core.types.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n        const replaceSupers = new _helperReplaceSupers.default({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          constantSuper: assumptions.constantSuper,\n          file: classState.file,\n          refToPreserve: classState.classRef\n        });\n        replaceSupers.replace();\n        const superReturns = [];\n        path.traverse(_core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {\n          ReturnStatement(path) {\n            if (!path.getFunctionParent().isArrowFunctionExpression()) {\n              superReturns.push(path);\n            }\n          }\n        }]));\n        if (isConstructor) {\n          pushConstructor(superReturns, node, path);\n        } else {\n          pushMethod(node, path);\n        }\n      }\n    }\n  }\n  function pushDescriptors() {\n    pushInheritsToBody();\n    const {\n      body\n    } = classState;\n    const props = {\n      instance: null,\n      static: null\n    };\n    for (const placement of [\"static\", \"instance\"]) {\n      if (classState.methods[placement].list.length) {\n        props[placement] = classState.methods[placement].list.map(desc => {\n          const obj = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"key\"), desc.key)]);\n          for (const kind of [\"get\", \"set\", \"value\"]) {\n            if (desc[kind] != null) {\n              obj.properties.push(_core.types.objectProperty(_core.types.identifier(kind), desc[kind]));\n            }\n          }\n          return obj;\n        });\n      }\n    }\n    if (props.instance || props.static) {\n      let args = [_core.types.cloneNode(classState.classRef), props.instance ? _core.types.arrayExpression(props.instance) : _core.types.nullLiteral(), props.static ? _core.types.arrayExpression(props.static) : _core.types.nullLiteral()];\n      let lastNonNullIndex = 0;\n      for (let i = 0; i < args.length; i++) {\n        if (!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n      args = args.slice(0, lastNonNullIndex + 1);\n      body.push(_core.types.expressionStatement(createClassHelper(args)));\n      classState.pushedCreateClass = true;\n    }\n  }\n  function wrapSuperCall(bareSuper, superRef, thisRef, body) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n    if (assumptions.superIsCallableConstructor) {\n      bareSuperNode.arguments.unshift(_core.types.thisExpression());\n      if (bareSuperNode.arguments.length === 2 && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {\n        name: \"arguments\"\n      })) {\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(\"apply\"));\n      } else {\n        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(\"call\"));\n      }\n      call = _core.types.logicalExpression(\"||\", bareSuperNode, _core.types.thisExpression());\n    } else {\n      call = (0, _helperOptimiseCallExpression.default)(_core.types.cloneNode(classState.superFnId), _core.types.thisExpression(), bareSuperNode.arguments, false);\n    }\n    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {\n      if (classState.superThises.length) {\n        call = _core.types.assignmentExpression(\"=\", thisRef(), call);\n      }\n      bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(_core.types.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n    path.traverse(findThisesVisitor);\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n      thisRef = () => _core.types.cloneNode(ref);\n      return ref;\n    };\n    for (const thisPath of classState.superThises) {\n      const {\n        node,\n        parentPath\n      } = thisPath;\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n      thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [thisRef()]));\n    }\n    const bareSupers = [];\n    path.traverse(_core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {\n      Super(path) {\n        const {\n          node,\n          parentPath\n        } = path;\n        if (parentPath.isCallExpression({\n          callee: node\n        })) {\n          bareSupers.unshift(parentPath);\n        }\n      }\n    }]));\n    let guaranteedSuperBeforeFinish = !!bareSupers.length;\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n      if (guaranteedSuperBeforeFinish) {\n        bareSuper.find(function (parentPath) {\n          if (parentPath === path) {\n            return true;\n          }\n          if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {\n            guaranteedSuperBeforeFinish = false;\n            return true;\n          }\n        });\n      }\n    }\n    let wrapReturn;\n    if (classState.isLoose) {\n      wrapReturn = returnArg => {\n        const thisExpr = _core.types.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [thisRef()]);\n        return returnArg ? _core.types.logicalExpression(\"||\", returnArg, thisExpr) : thisExpr;\n      };\n    } else {\n      wrapReturn = returnArg => {\n        const returnParams = [thisRef()];\n        if (returnArg != null) {\n          returnParams.push(returnArg);\n        }\n        return _core.types.callExpression(classState.file.addHelper(\"possibleConstructorReturn\"), returnParams);\n      };\n    }\n    const bodyPaths = body.get(\"body\");\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\"body\", _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : wrapReturn()));\n    }\n    for (const returnPath of classState.superReturns) {\n      returnPath.get(\"argument\").replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n  function pushMethod(node, path) {\n    const scope = path ? path.scope : classState.scope;\n    if (node.kind === \"method\") {\n      if (processMethod(node, scope)) return;\n    }\n    const placement = node.static ? \"static\" : \"instance\";\n    const methods = classState.methods[placement];\n    const descKey = node.kind === \"method\" ? \"value\" : node.kind;\n    const key = _core.types.isNumericLiteral(node.key) || _core.types.isBigIntLiteral(node.key) ? _core.types.stringLiteral(String(node.key.value)) : _core.types.toComputedKey(node);\n    let fn = _core.types.toExpression(node);\n    if (_core.types.isStringLiteral(key)) {\n      if (node.kind === \"method\") {\n        var _nameFunction;\n        fn = (_nameFunction = (0, _helperFunctionName.default)({\n          id: key,\n          node: node,\n          scope\n        }, undefined, supportUnicodeId)) != null ? _nameFunction : fn;\n      }\n    } else {\n      methods.hasComputed = true;\n    }\n    let descriptor;\n    if (!methods.hasComputed && methods.map.has(key.value)) {\n      descriptor = methods.map.get(key.value);\n      descriptor[descKey] = fn;\n      if (descKey === \"value\") {\n        descriptor.get = null;\n        descriptor.set = null;\n      } else {\n        descriptor.value = null;\n      }\n    } else {\n      descriptor = {\n        key: key,\n        [descKey]: fn\n      };\n      methods.list.push(descriptor);\n      if (!methods.hasComputed) {\n        methods.map.set(key.value, descriptor);\n      }\n    }\n  }\n  function processMethod(node, scope) {\n    if (assumptions.setClassMethods && !node.decorators) {\n      let {\n        classRef\n      } = classState;\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n      const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));\n      let func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);\n      _core.types.inherits(func, node);\n      const key = _core.types.toComputedKey(node, node.key);\n      if (_core.types.isStringLiteral(key)) {\n        var _nameFunction2;\n        func = (_nameFunction2 = (0, _helperFunctionName.default)({\n          node: func,\n          id: key,\n          scope\n        }, undefined, supportUnicodeId)) != null ? _nameFunction2 : func;\n      }\n      const expr = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", methodName, func));\n      _core.types.inheritsComments(expr, node);\n      classState.body.push(expr);\n      return true;\n    }\n    return false;\n  }\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({\n        protoAlias: classState.scope.generateUidIdentifier(\"proto\")\n      });\n      const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier(\"prototype\"));\n      const protoDeclaration = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(classState.protoAlias, classProto)]);\n      classState.body.push(protoDeclaration);\n    }\n  }\n  function pushConstructor(superReturns, method, path) {\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns\n    });\n    const {\n      construct\n    } = classState;\n    _core.types.inheritsComments(construct, method);\n    construct.params = method.params;\n    _core.types.inherits(construct.body, method.body);\n    construct.body.directives = method.body.directives;\n    pushConstructorToBody();\n  }\n  function pushConstructorToBody() {\n    if (classState.pushedConstructor) return;\n    classState.pushedConstructor = true;\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n    classState.body.push(classState.construct);\n    pushInheritsToBody();\n  }\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n    const superFnId = path.scope.generateUidIdentifier(\"super\");\n    setState({\n      pushedInherits: true,\n      superFnId\n    });\n    if (!assumptions.superIsCallableConstructor) {\n      classState.body.unshift(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(superFnId, _core.types.callExpression((0, _inlineCreateSuperHelpers.default)(classState.file), [_core.types.cloneNode(classState.classRef)]))]));\n    }\n    classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? \"inheritsLoose\" : \"inherits\"), [_core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName)])));\n  }\n  function extractDynamicKeys() {\n    const {\n      dynamicKeys,\n      node,\n      scope\n    } = classState;\n    for (const elem of node.body.body) {\n      if (!_core.types.isClassMethod(elem) || !elem.computed) continue;\n      if (scope.isPure(elem.key, true)) continue;\n      const id = scope.generateUidIdentifierBasedOnNode(elem.key);\n      dynamicKeys.set(id.name, elem.key);\n      elem.key = id;\n    }\n  }\n  function setupClosureParamsArgs() {\n    const {\n      superName,\n      dynamicKeys\n    } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n    if (classState.isDerived) {\n      let arg = _core.types.cloneNode(superName);\n      if (classState.extendsNative) {\n        arg = _core.types.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [arg]);\n        (0, _helperAnnotateAsPure.default)(arg);\n      }\n      const param = classState.scope.generateUidIdentifierBasedOnNode(superName);\n      closureParams.push(param);\n      closureArgs.push(arg);\n      setState({\n        superName: _core.types.cloneNode(param)\n      });\n    }\n    for (const [name, value] of dynamicKeys) {\n      closureParams.push(_core.types.identifier(name));\n      closureArgs.push(value);\n    }\n    return {\n      closureParams,\n      closureArgs\n    };\n  }\n  function classTransformer(path, file, builtinClasses, isLoose) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose\n    });\n    setState({\n      classId: classState.node.id,\n      classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: _core.types.blockStatement([])\n    });\n    setState({\n      extendsNative: _core.types.isIdentifier(classState.superName) && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)\n    });\n    const {\n      classRef,\n      node,\n      constructorBody\n    } = classState;\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node)\n    });\n    extractDynamicKeys();\n    const {\n      body\n    } = classState;\n    const {\n      closureParams,\n      closureArgs\n    } = setupClosureParamsArgs();\n    buildBody();\n    if (!assumptions.noClassCalls) {\n      constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(\"classCallCheck\"), [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)])));\n    }\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = classState.classId && body.length === 1;\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        if (!_core.types.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n    const directives = constructorOnly ? body[0].body.directives : [];\n    if (!isStrict) {\n      directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n    }\n    if (constructorOnly) {\n      const expr = _core.types.toExpression(body[0]);\n      return classState.isLoose ? expr : createClassHelper([expr]);\n    }\n    let returnArg = _core.types.cloneNode(classState.classRef);\n    if (!classState.pushedCreateClass && !classState.isLoose) {\n      returnArg = createClassHelper([returnArg]);\n    }\n    body.push(_core.types.returnStatement(returnArg));\n    const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));\n    return _core.types.callExpression(container, closureArgs);\n  }\n  return classTransformer(path, file, builtinClasses, isLoose);\n}","map":{"version":3,"names":["_helperFunctionName","require","_helperReplaceSupers","_helperEnvironmentVisitor","_helperOptimiseCallExpression","_core","_helperAnnotateAsPure","_inlineCreateSuperHelpers","buildConstructor","classRef","constructorBody","node","func","types","functionDeclaration","cloneNode","inherits","transformClass","path","file","builtinClasses","isLoose","assumptions","supportUnicodeId","classState","parent","undefined","scope","classId","superFnId","superName","superReturns","isDerived","extendsNative","construct","userConstructor","userConstructorPath","hasConstructor","body","superThises","pushedConstructor","pushedInherits","pushedCreateClass","protoAlias","dynamicKeys","Map","methods","instance","hasComputed","list","map","static","setState","newState","Object","assign","findThisesVisitor","traverse","visitors","merge","default","ThisExpression","push","createClassHelper","args","callExpression","addHelper","maybeCreateConstructor","paths","get","equals","params","constructor","template","expression","ast","blockStatement","unshiftContainer","classMethod","identifier","buildBody","pushBody","verifyConstructor","pushDescriptors","classBodyPaths","isClassProperty","buildCodeFrameError","decorators","isClassMethod","isConstructor","kind","replaceSupers","methodPath","objectRef","superRef","constantSuper","refToPreserve","replace","ReturnStatement","getFunctionParent","isArrowFunctionExpression","pushConstructor","pushMethod","pushInheritsToBody","props","placement","length","desc","obj","objectExpression","objectProperty","key","properties","arrayExpression","nullLiteral","lastNonNullIndex","i","isNullLiteral","slice","expressionStatement","wrapSuperCall","bareSuper","thisRef","bareSuperNode","call","superIsCallableConstructor","arguments","unshift","thisExpression","isSpreadElement","isIdentifier","argument","name","callee","memberExpression","logicalExpression","parentPath","isExpressionStatement","container","assignmentExpression","replaceWith","returnStatement","ref","generateDeclaredUidIdentifier","thisPath","isMemberExpression","object","bareSupers","Super","isCallExpression","guaranteedSuperBeforeFinish","find","isLoop","isConditional","wrapReturn","returnArg","thisExpr","returnParams","bodyPaths","pop","isReturnStatement","pushContainer","returnPath","processMethod","descKey","isNumericLiteral","isBigIntLiteral","stringLiteral","String","value","toComputedKey","fn","toExpression","isStringLiteral","_nameFunction","id","descriptor","has","set","setClassMethods","insertProtoAliasOnce","methodName","computed","isLiteral","functionExpression","generator","async","_nameFunction2","expr","inheritsComments","generateUidIdentifier","classProto","protoDeclaration","variableDeclaration","variableDeclarator","method","directives","pushConstructorToBody","hasInstanceDescriptors","hasStaticDescriptors","extractDynamicKeys","elem","isPure","generateUidIdentifierBasedOnNode","setupClosureParamsArgs","closureParams","closureArgs","arg","param","classTransformer","superClass","hasBinding","noClassCalls","isStrict","isInStrictMode","constructorOnly","directive","directiveLiteral","arrowFunctionExpression"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@babel\\plugin-transform-classes\\src\\transformClass.ts"],"sourcesContent":["import type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport { traverse, template, types as t, type File } from \"@babel/core\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport addCreateSuperHelper from \"./inline-createSuper-helpers\";\n\ntype ClassAssumptions = {\n  setClassMethods: boolean;\n  constantSuper: boolean;\n  superIsCallableConstructor: boolean;\n  noClassCalls: boolean;\n};\n\ntype ClassConstructor = t.ClassMethod & { kind: \"constructor\" };\n\nfunction buildConstructor(\n  classRef: t.Identifier,\n  constructorBody: t.BlockStatement,\n  node: t.Class,\n) {\n  const func = t.functionDeclaration(\n    t.cloneNode(classRef),\n    [],\n    constructorBody,\n  );\n  t.inherits(func, node);\n  return func;\n}\n\ntype Descriptor = {\n  key: t.Expression;\n  get?: t.Expression | null;\n  set?: t.Expression | null;\n  value?: t.Expression | null;\n  constructor?: t.Expression | null;\n};\n\ntype State = {\n  parent: t.Node;\n  scope: Scope;\n  node: t.Class;\n  path: NodePath<t.Class>;\n  file: File;\n\n  classId: t.Identifier | void;\n  classRef: t.Identifier;\n  superFnId: t.Identifier;\n  superName: t.Expression | null;\n  superReturns: NodePath<t.ReturnStatement>[];\n  isDerived: boolean;\n  extendsNative: boolean;\n\n  construct: t.FunctionDeclaration;\n  constructorBody: t.BlockStatement;\n  userConstructor: ClassConstructor;\n  userConstructorPath: NodePath<ClassConstructor>;\n  hasConstructor: boolean;\n\n  body: t.Statement[];\n  superThises: NodePath<t.ThisExpression>[];\n  pushedConstructor: boolean;\n  pushedInherits: boolean;\n  pushedCreateClass: boolean;\n  protoAlias: t.Identifier | null;\n  isLoose: boolean;\n\n  dynamicKeys: Map<string, t.Expression>;\n\n  methods: {\n    // 'list' is in the same order as the elements appear in the class body.\n    // if there aren't computed keys, we can safely reorder class elements\n    // and use 'map' to merge duplicates.\n    instance: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n    static: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n  };\n};\n\ntype PropertyInfo = {\n  instance: t.ObjectExpression[] | null;\n  static: t.ObjectExpression[] | null;\n};\n\nexport default function transformClass(\n  path: NodePath<t.Class>,\n  file: File,\n  builtinClasses: ReadonlySet<string>,\n  isLoose: boolean,\n  assumptions: ClassAssumptions,\n  supportUnicodeId: boolean,\n) {\n  const classState: State = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n\n    classId: undefined,\n    classRef: undefined,\n    superFnId: undefined,\n    superName: null,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n\n    body: [],\n    superThises: [],\n    pushedConstructor: false,\n    pushedInherits: false,\n    pushedCreateClass: false,\n    protoAlias: null,\n    isLoose: false,\n\n    dynamicKeys: new Map(),\n\n    methods: {\n      instance: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n      static: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n    },\n  };\n\n  const setState = (newState: Partial<State>) => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = traverse.visitors.merge([\n    environmentVisitor,\n    {\n      ThisExpression(path) {\n        classState.superThises.push(path);\n      },\n    },\n  ]);\n\n  function createClassHelper(args: t.Expression[]) {\n    return t.callExpression(classState.file.addHelper(\"createClass\"), args);\n  }\n\n  /**\n   * Creates a class constructor or bail out if there is none\n   */\n  function maybeCreateConstructor() {\n    let hasConstructor = false;\n    const paths = classState.path.get(\"body.body\");\n    for (const path of paths) {\n      // @ts-expect-error: StaticBlock does not have `kind` property\n      hasConstructor = path.equals(\"kind\", \"constructor\");\n      if (hasConstructor) break;\n    }\n    if (hasConstructor) return;\n\n    let params: t.FunctionExpression[\"params\"], body;\n\n    if (classState.isDerived) {\n      const constructor = template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      ` as t.FunctionExpression;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = t.blockStatement([]);\n    }\n\n    classState.path\n      .get(\"body\")\n      .unshiftContainer(\n        \"body\",\n        t.classMethod(\"constructor\", t.identifier(\"constructor\"), params, body),\n      );\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const { constructorBody, userConstructor, construct } = classState;\n\n      constructorBody.body.push(...userConstructor.body.body);\n      t.inherits(construct, userConstructor);\n      t.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths: Array<any> = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\n          \"Method has decorators, put the decorator plugin before the classes one.\",\n        );\n      }\n\n      if (t.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n\n        const replaceSupers = new ReplaceSupers({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          constantSuper: assumptions.constantSuper,\n          file: classState.file,\n          refToPreserve: classState.classRef,\n        });\n\n        replaceSupers.replace();\n\n        const superReturns: NodePath<t.ReturnStatement>[] = [];\n        path.traverse(\n          traverse.visitors.merge([\n            environmentVisitor,\n            {\n              ReturnStatement(path) {\n                if (!path.getFunctionParent().isArrowFunctionExpression()) {\n                  superReturns.push(path);\n                }\n              },\n            },\n          ]),\n        );\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node as ClassConstructor, path);\n        } else {\n          pushMethod(node, path);\n        }\n      }\n    }\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n\n    const { body } = classState;\n\n    const props: PropertyInfo = {\n      instance: null,\n      static: null,\n    };\n\n    for (const placement of [\"static\", \"instance\"] as const) {\n      if (classState.methods[placement].list.length) {\n        props[placement] = classState.methods[placement].list.map(desc => {\n          const obj = t.objectExpression([\n            t.objectProperty(t.identifier(\"key\"), desc.key),\n          ]);\n\n          for (const kind of [\"get\", \"set\", \"value\"] as const) {\n            if (desc[kind] != null) {\n              obj.properties.push(\n                t.objectProperty(t.identifier(kind), desc[kind]),\n              );\n            }\n          }\n\n          return obj;\n        });\n      }\n    }\n\n    if (props.instance || props.static) {\n      let args = [\n        t.cloneNode(classState.classRef), // Constructor\n        props.instance ? t.arrayExpression(props.instance) : t.nullLiteral(), // instanceDescriptors\n        props.static ? t.arrayExpression(props.static) : t.nullLiteral(), // staticDescriptors\n      ];\n\n      let lastNonNullIndex = 0;\n      for (let i = 0; i < args.length; i++) {\n        if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n      args = args.slice(0, lastNonNullIndex + 1);\n\n      body.push(t.expressionStatement(createClassHelper(args)));\n      classState.pushedCreateClass = true;\n    }\n  }\n\n  function wrapSuperCall(\n    bareSuper: NodePath<t.CallExpression>,\n    superRef: t.Expression,\n    thisRef: () => t.Identifier,\n    body: NodePath<t.BlockStatement>,\n  ) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (assumptions.superIsCallableConstructor) {\n      bareSuperNode.arguments.unshift(t.thisExpression());\n      if (\n        bareSuperNode.arguments.length === 2 &&\n        t.isSpreadElement(bareSuperNode.arguments[1]) &&\n        t.isIdentifier(bareSuperNode.arguments[1].argument, {\n          name: \"arguments\",\n        })\n      ) {\n        // special case single arguments spread\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"apply\"),\n        );\n      } else {\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"call\"),\n        );\n      }\n\n      call = t.logicalExpression(\"||\", bareSuperNode, t.thisExpression());\n    } else {\n      call = optimiseCall(\n        t.cloneNode(classState.superFnId),\n        t.thisExpression(),\n        bareSuperNode.arguments,\n        false,\n      );\n    }\n\n    if (\n      bareSuper.parentPath.isExpressionStatement() &&\n      bareSuper.parentPath.container === body.node.body &&\n      body.node.body.length - 1 === bareSuper.parentPath.key\n    ) {\n      // this super call is the last statement in the body so we can just straight up\n      // turn it into a return\n\n      if (classState.superThises.length) {\n        call = t.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(t.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(t.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n      thisRef = () => t.cloneNode(ref);\n      return ref;\n    };\n\n    for (const thisPath of classState.superThises) {\n      const { node, parentPath } = thisPath;\n      if (parentPath.isMemberExpression({ object: node })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n      thisPath.replaceWith(\n        t.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [\n          thisRef(),\n        ]),\n      );\n    }\n\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    path.traverse(\n      traverse.visitors.merge([\n        environmentVisitor,\n        {\n          Super(path) {\n            const { node, parentPath } = path;\n            if (parentPath.isCallExpression({ callee: node })) {\n              bareSupers.unshift(parentPath);\n            }\n          },\n        } as Visitor,\n      ]),\n    );\n\n    let guaranteedSuperBeforeFinish = !!bareSupers.length;\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (guaranteedSuperBeforeFinish) {\n        bareSuper.find(function (parentPath) {\n          // hit top so short circuit\n          if (parentPath === path) {\n            return true;\n          }\n\n          if (\n            parentPath.isLoop() ||\n            parentPath.isConditional() ||\n            parentPath.isArrowFunctionExpression()\n          ) {\n            guaranteedSuperBeforeFinish = false;\n            return true;\n          }\n        });\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = (returnArg: t.Expression | void) => {\n        const thisExpr = t.callExpression(\n          classState.file.addHelper(\"assertThisInitialized\"),\n          [thisRef()],\n        );\n        return returnArg\n          ? t.logicalExpression(\"||\", returnArg, thisExpr)\n          : thisExpr;\n      };\n    } else {\n      wrapReturn = (returnArg: t.Expression | undefined) => {\n        const returnParams: t.Expression[] = [thisRef()];\n        if (returnArg != null) {\n          returnParams.push(returnArg);\n        }\n        return t.callExpression(\n          classState.file.addHelper(\"possibleConstructorReturn\"),\n          returnParams,\n        );\n      };\n    }\n\n    // if we have a return as the last node in the body then we've already caught that\n    // return\n    const bodyPaths = body.get(\"body\");\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\n        \"body\",\n        t.returnStatement(\n          guaranteedSuperBeforeFinish ? thisRef() : wrapReturn(),\n        ),\n      );\n    }\n\n    for (const returnPath of classState.superReturns) {\n      returnPath\n        .get(\"argument\")\n        .replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n\n  /**\n   * Push a method to its respective mutatorMap.\n   */\n  function pushMethod(node: t.ClassMethod, path?: NodePath) {\n    const scope = path ? path.scope : classState.scope;\n\n    if (node.kind === \"method\") {\n      if (processMethod(node, scope)) return;\n    }\n\n    const placement = node.static ? \"static\" : \"instance\";\n    const methods = classState.methods[placement];\n\n    const descKey = node.kind === \"method\" ? \"value\" : node.kind;\n    const key =\n      t.isNumericLiteral(node.key) || t.isBigIntLiteral(node.key)\n        ? t.stringLiteral(String(node.key.value))\n        : t.toComputedKey(node);\n\n    let fn: t.Expression = t.toExpression(node);\n\n    if (t.isStringLiteral(key)) {\n      // infer function name\n      if (node.kind === \"method\") {\n        // @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction\n        // does not seem to support it\n        fn =\n          nameFunction(\n            // @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction\n            // does not seem to support it\n            { id: key, node: node, scope },\n            undefined,\n            supportUnicodeId,\n          ) ?? fn;\n      }\n    } else {\n      // todo(flow->ts) find a way to avoid \"key as t.StringLiteral\" below which relies on this assignment\n      methods.hasComputed = true;\n    }\n\n    let descriptor: Descriptor;\n    if (\n      !methods.hasComputed &&\n      methods.map.has((key as t.StringLiteral).value)\n    ) {\n      descriptor = methods.map.get((key as t.StringLiteral).value);\n      descriptor[descKey] = fn;\n\n      if (descKey === \"value\") {\n        descriptor.get = null;\n        descriptor.set = null;\n      } else {\n        descriptor.value = null;\n      }\n    } else {\n      descriptor = {\n        key:\n          // private name has been handled in class-properties transform\n          key as t.Expression,\n        [descKey]: fn,\n      } as Descriptor;\n      methods.list.push(descriptor);\n\n      if (!methods.hasComputed) {\n        methods.map.set((key as t.StringLiteral).value, descriptor);\n      }\n    }\n  }\n\n  function processMethod(node: t.ClassMethod, scope: Scope) {\n    if (assumptions.setClassMethods && !node.decorators) {\n      // use assignments instead of define properties for loose classes\n      let { classRef } = classState;\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n      const methodName = t.memberExpression(\n        t.cloneNode(classRef),\n        node.key,\n        node.computed || t.isLiteral(node.key),\n      );\n\n      let func: t.Expression = t.functionExpression(\n        null,\n        // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n        node.params,\n        node.body,\n        node.generator,\n        node.async,\n      );\n      t.inherits(func, node);\n\n      const key = t.toComputedKey(node, node.key);\n      if (t.isStringLiteral(key)) {\n        // @ts-expect-error: requires strictNullCheck\n        func =\n          nameFunction(\n            {\n              node: func,\n              id: key,\n              scope,\n            },\n            undefined,\n            supportUnicodeId,\n          ) ?? func;\n      }\n\n      const expr = t.expressionStatement(\n        t.assignmentExpression(\"=\", methodName, func),\n      );\n      t.inheritsComments(expr, node);\n      classState.body.push(expr);\n      return true;\n    }\n\n    return false;\n  }\n\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({ protoAlias: classState.scope.generateUidIdentifier(\"proto\") });\n      const classProto = t.memberExpression(\n        classState.classRef,\n        t.identifier(\"prototype\"),\n      );\n      const protoDeclaration = t.variableDeclaration(\"var\", [\n        t.variableDeclarator(classState.protoAlias, classProto),\n      ]);\n\n      classState.body.push(protoDeclaration);\n    }\n  }\n\n  /**\n   * Replace the constructor body of our class.\n   */\n  function pushConstructor(\n    superReturns: NodePath<t.ReturnStatement>[],\n    method: ClassConstructor,\n    path: NodePath<ClassConstructor>,\n  ) {\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns,\n    });\n\n    const { construct } = classState;\n\n    t.inheritsComments(construct, method);\n\n    // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n    construct.params = method.params;\n\n    t.inherits(construct.body, method.body);\n    construct.body.directives = method.body.directives;\n\n    pushConstructorToBody();\n  }\n\n  function pushConstructorToBody() {\n    if (classState.pushedConstructor) return;\n    classState.pushedConstructor = true;\n\n    // we haven't pushed any descriptors yet\n    // @ts-expect-error todo(flow->ts) maybe remove this block - properties from condition are not used anywhere else\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n\n    classState.body.push(classState.construct);\n\n    pushInheritsToBody();\n  }\n\n  /**\n   * Push inherits helper to body.\n   */\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n\n    const superFnId = path.scope.generateUidIdentifier(\"super\");\n\n    setState({ pushedInherits: true, superFnId });\n\n    // Unshift to ensure that the constructor inheritance is set up before\n    // any properties can be assigned to the prototype.\n\n    if (!assumptions.superIsCallableConstructor) {\n      classState.body.unshift(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            superFnId,\n            t.callExpression(addCreateSuperHelper(classState.file), [\n              t.cloneNode(classState.classRef),\n            ]),\n          ),\n        ]),\n      );\n    }\n\n    classState.body.unshift(\n      t.expressionStatement(\n        t.callExpression(\n          classState.file.addHelper(\n            classState.isLoose ? \"inheritsLoose\" : \"inherits\",\n          ),\n          [t.cloneNode(classState.classRef), t.cloneNode(classState.superName)],\n        ),\n      ),\n    );\n  }\n\n  function extractDynamicKeys() {\n    const { dynamicKeys, node, scope } = classState;\n\n    for (const elem of node.body.body) {\n      if (!t.isClassMethod(elem) || !elem.computed) continue;\n      if (scope.isPure(elem.key, /* constants only*/ true)) continue;\n\n      const id = scope.generateUidIdentifierBasedOnNode(elem.key);\n      dynamicKeys.set(id.name, elem.key);\n\n      elem.key = id;\n    }\n  }\n\n  function setupClosureParamsArgs() {\n    const { superName, dynamicKeys } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n\n    if (classState.isDerived) {\n      let arg = t.cloneNode(superName);\n      if (classState.extendsNative) {\n        arg = t.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [\n          arg,\n        ]);\n        annotateAsPure(arg);\n      }\n\n      const param =\n        classState.scope.generateUidIdentifierBasedOnNode(superName);\n\n      closureParams.push(param);\n      closureArgs.push(arg);\n\n      setState({ superName: t.cloneNode(param) });\n    }\n\n    for (const [name, value] of dynamicKeys) {\n      closureParams.push(t.identifier(name));\n      closureArgs.push(value);\n    }\n\n    return { closureParams, closureArgs };\n  }\n\n  function classTransformer(\n    path: NodePath<t.Class>,\n    file: File,\n    builtinClasses: ReadonlySet<string>,\n    isLoose: boolean,\n  ) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose,\n    });\n\n    setState({\n      classId: classState.node.id,\n      // this is the name of the binding that will **always** reference the class we've constructed\n      classRef: classState.node.id\n        ? t.identifier(classState.node.id.name)\n        : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: t.blockStatement([]),\n    });\n\n    setState({\n      extendsNative:\n        t.isIdentifier(classState.superName) &&\n        builtinClasses.has(classState.superName.name) &&\n        !classState.scope.hasBinding(\n          classState.superName.name,\n          /* noGlobals */ true,\n        ),\n    });\n\n    const { classRef, node, constructorBody } = classState;\n\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node),\n    });\n\n    extractDynamicKeys();\n\n    const { body } = classState;\n    const { closureParams, closureArgs } = setupClosureParamsArgs();\n\n    buildBody();\n\n    // make sure this class isn't directly called (with A() instead new A())\n    if (!assumptions.noClassCalls) {\n      constructorBody.body.unshift(\n        t.expressionStatement(\n          t.callExpression(classState.file.addHelper(\"classCallCheck\"), [\n            t.thisExpression(),\n            t.cloneNode(classState.classRef),\n          ]),\n        ),\n      );\n    }\n\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = classState.classId && body.length === 1;\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        // It's illegal to put a use strict directive into the body of a function\n        // with non-simple parameters for some reason. So, we have to use a strict\n        // wrapper function.\n        if (!t.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n\n    const directives = constructorOnly\n      ? (body[0] as t.FunctionExpression | t.FunctionDeclaration).body\n          .directives\n      : [];\n    if (!isStrict) {\n      directives.push(t.directive(t.directiveLiteral(\"use strict\")));\n    }\n\n    if (constructorOnly) {\n      // named class with only a constructor\n      const expr = t.toExpression(\n        body[0] as t.FunctionExpression | t.FunctionDeclaration,\n      );\n      return classState.isLoose ? expr : createClassHelper([expr]);\n    }\n\n    let returnArg: t.Expression = t.cloneNode(classState.classRef);\n    if (!classState.pushedCreateClass && !classState.isLoose) {\n      returnArg = createClassHelper([returnArg]);\n    }\n\n    body.push(t.returnStatement(returnArg));\n    const container = t.arrowFunctionExpression(\n      closureParams,\n      t.blockStatement(body, directives),\n    );\n    return t.callExpression(container, closureArgs);\n  }\n\n  return classTransformer(path, file, builtinClasses, isLoose);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}