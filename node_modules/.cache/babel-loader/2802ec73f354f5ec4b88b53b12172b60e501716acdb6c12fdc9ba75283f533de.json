{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').Specificity} Specificity\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\nconst csstree = require('css-tree');\nconst {\n  // @ts-ignore not defined in @types/csso\n  syntax: {\n    specificity\n  }\n} = require('csso');\nconst {\n  visitSkip,\n  querySelectorAll,\n  detachNodeFromParent\n} = require('../lib/xast.js');\nexports.name = 'inlineStyles';\nexports.description = 'inline styles (additional options)';\n\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/main/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n  return 0;\n};\n\n/**\n * @type {(value: any) => any}\n */\nconst toAny = value => value;\n\n/**\n * Moves + merges styles from style elements to element styles\n *\n * Options\n *   onlyMatchedOnce (default: true)\n *     inline only selectors that match once\n *\n *   removeMatchedSelectors (default: true)\n *     clean up matched selectors,\n *     leave selectors that hadn't matched\n *\n *   useMqs (default: ['', 'screen'])\n *     what media queries to be used\n *     empty string element for styles outside media queries\n *\n *   usePseudos (default: [''])\n *     what pseudo-classes/-elements to be used\n *     empty string element for all non-pseudo-classes and/or -elements\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('./plugins-types').Plugin<'inlineStyles'>}\n */\nexports.fn = (root, params) => {\n  const {\n    onlyMatchedOnce = true,\n    removeMatchedSelectors = true,\n    useMqs = ['', 'screen'],\n    usePseudos = ['']\n  } = params;\n\n  /**\n   * @type {Array<{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }>}\n   */\n  const styles = [];\n  /**\n   * @type {Array<{\n   *   node: csstree.Selector,\n   *   item: csstree.ListItem<csstree.CssNode>,\n   *   rule: csstree.Rule,\n   *   matchedElements?: Array<XastElement>\n   * }>}\n   */\n  let selectors = [];\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject /> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n        // collect only non-empty <style /> elements\n        if (node.name !== 'style' || node.children.length === 0) {\n          return;\n        }\n        // values other than the empty string or text/css are not used\n        if (node.attributes.type != null && node.attributes.type !== '' && node.attributes.type !== 'text/css') {\n          return;\n        }\n        // parse css in style element\n        let cssText = '';\n        for (const child of node.children) {\n          if (child.type === 'text' || child.type === 'cdata') {\n            cssText += child.value;\n          }\n        }\n        /**\n         * @type {null | csstree.CssNode}\n         */\n        let cssAst = null;\n        try {\n          cssAst = csstree.parse(cssText, {\n            parseValue: false,\n            parseCustomProperty: false\n          });\n        } catch {\n          return;\n        }\n        if (cssAst.type === 'StyleSheet') {\n          styles.push({\n            node,\n            parentNode,\n            cssAst\n          });\n        }\n\n        // collect selectors\n        csstree.walk(cssAst, {\n          visit: 'Selector',\n          enter(node, item) {\n            const atrule = this.atrule;\n            const rule = this.rule;\n            if (rule == null) {\n              return;\n            }\n\n            // skip media queries not included into useMqs param\n            let mq = '';\n            if (atrule != null) {\n              mq = atrule.name;\n              if (atrule.prelude != null) {\n                mq += ` ${csstree.generate(atrule.prelude)}`;\n              }\n            }\n            if (useMqs.includes(mq) === false) {\n              return;\n            }\n\n            /**\n             * @type {Array<{\n             *   item: csstree.ListItem<csstree.CssNode>,\n             *   list: csstree.List<csstree.CssNode>\n             * }>}\n             */\n            const pseudos = [];\n            if (node.type === 'Selector') {\n              node.children.forEach((childNode, childItem, childList) => {\n                if (childNode.type === 'PseudoClassSelector' || childNode.type === 'PseudoElementSelector') {\n                  pseudos.push({\n                    item: childItem,\n                    list: childList\n                  });\n                }\n              });\n            }\n\n            // skip pseudo classes and pseudo elements not includes into usePseudos param\n            const pseudoSelectors = csstree.generate({\n              type: 'Selector',\n              children: new csstree.List().fromArray(pseudos.map(pseudo => pseudo.item.data))\n            });\n            if (usePseudos.includes(pseudoSelectors) === false) {\n              return;\n            }\n\n            // remove pseudo classes and elements to allow querySelector match elements\n            // TODO this is not very accurate since some pseudo classes like first-child\n            // are used for selection\n            for (const pseudo of pseudos) {\n              pseudo.list.remove(pseudo.item);\n            }\n            selectors.push({\n              node,\n              item,\n              rule\n            });\n          }\n        });\n      }\n    },\n    root: {\n      exit: () => {\n        if (styles.length === 0) {\n          return;\n        }\n        // stable sort selectors\n        const sortedSelectors = [...selectors].sort((a, b) => {\n          const aSpecificity = specificity(a.item.data);\n          const bSpecificity = specificity(b.item.data);\n          return compareSpecificity(aSpecificity, bSpecificity);\n        }).reverse();\n        for (const selector of sortedSelectors) {\n          // match selectors\n          const selectorText = csstree.generate(selector.item.data);\n          /**\n           * @type {Array<XastElement>}\n           */\n          const matchedElements = [];\n          try {\n            for (const node of querySelectorAll(root, selectorText)) {\n              if (node.type === 'element') {\n                matchedElements.push(node);\n              }\n            }\n          } catch (selectError) {\n            continue;\n          }\n          // nothing selected\n          if (matchedElements.length === 0) {\n            continue;\n          }\n\n          // apply styles to matched elements\n          // skip selectors that match more than once if option onlyMatchedOnce is enabled\n          if (onlyMatchedOnce && matchedElements.length > 1) {\n            continue;\n          }\n\n          // apply <style/> to matched elements\n          for (const selectedEl of matchedElements) {\n            const styleDeclarationList = csstree.parse(selectedEl.attributes.style == null ? '' : selectedEl.attributes.style, {\n              context: 'declarationList',\n              parseValue: false\n            });\n            if (styleDeclarationList.type !== 'DeclarationList') {\n              continue;\n            }\n            const styleDeclarationItems = new Map();\n            csstree.walk(styleDeclarationList, {\n              visit: 'Declaration',\n              enter(node, item) {\n                styleDeclarationItems.set(node.property, item);\n              }\n            });\n            // merge declarations\n            csstree.walk(selector.rule, {\n              visit: 'Declaration',\n              enter(ruleDeclaration) {\n                // existing inline styles have higher priority\n                // no inline styles, external styles,                                    external styles used\n                // inline styles,    external styles same   priority as inline styles,   inline   styles used\n                // inline styles,    external styles higher priority than inline styles, external styles used\n                const matchedItem = styleDeclarationItems.get(ruleDeclaration.property);\n                const ruleDeclarationItem = styleDeclarationList.children.createItem(ruleDeclaration);\n                if (matchedItem == null) {\n                  styleDeclarationList.children.append(ruleDeclarationItem);\n                } else if (matchedItem.data.important !== true && ruleDeclaration.important === true) {\n                  styleDeclarationList.children.replace(matchedItem, ruleDeclarationItem);\n                  styleDeclarationItems.set(ruleDeclaration.property, ruleDeclarationItem);\n                }\n              }\n            });\n            selectedEl.attributes.style = csstree.generate(styleDeclarationList);\n          }\n          if (removeMatchedSelectors && matchedElements.length !== 0 && selector.rule.prelude.type === 'SelectorList') {\n            // clean up matching simple selectors if option removeMatchedSelectors is enabled\n            selector.rule.prelude.children.remove(selector.item);\n          }\n          selector.matchedElements = matchedElements;\n        }\n\n        // no further processing required\n        if (removeMatchedSelectors === false) {\n          return;\n        }\n\n        // clean up matched class + ID attribute values\n        for (const selector of sortedSelectors) {\n          if (selector.matchedElements == null) {\n            continue;\n          }\n          if (onlyMatchedOnce && selector.matchedElements.length > 1) {\n            // skip selectors that match more than once if option onlyMatchedOnce is enabled\n            continue;\n          }\n          for (const selectedEl of selector.matchedElements) {\n            // class\n            const classList = new Set(selectedEl.attributes.class == null ? null : selectedEl.attributes.class.split(' '));\n            /**\n             * csstree v2 changed this type\n             * @type {csstree.CssNode}\n             */\n            const firstSubSelector = toAny(selector.node.children.first);\n            if (firstSubSelector != null && firstSubSelector.type === 'ClassSelector') {\n              classList.delete(firstSubSelector.name);\n            }\n            if (classList.size === 0) {\n              delete selectedEl.attributes.class;\n            } else {\n              selectedEl.attributes.class = Array.from(classList).join(' ');\n            }\n\n            // ID\n            if (firstSubSelector != null && firstSubSelector.type === 'IdSelector') {\n              if (selectedEl.attributes.id === firstSubSelector.name) {\n                delete selectedEl.attributes.id;\n              }\n            }\n          }\n        }\n        for (const style of styles) {\n          csstree.walk(style.cssAst, {\n            visit: 'Rule',\n            enter: function (node, item, list) {\n              // clean up <style/> rulesets without any css selectors left\n              if (node.type === 'Rule' && node.prelude.type === 'SelectorList' &&\n              // csstree v2 changed this type\n              toAny(node.prelude.children.isEmpty)) {\n                list.remove(item);\n              }\n            }\n          });\n\n          // csstree v2 changed this type\n          if (toAny(style.cssAst.children.isEmpty)) {\n            // remove emtpy style element\n            detachNodeFromParent(style.node, style.parentNode);\n          } else {\n            // update style element if any styles left\n            const firstChild = style.node.children[0];\n            if (firstChild.type === 'text' || firstChild.type === 'cdata') {\n              firstChild.value = csstree.generate(style.cssAst);\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["csstree","require","syntax","specificity","visitSkip","querySelectorAll","detachNodeFromParent","exports","name","description","compareSpecificity","a","b","i","toAny","value","fn","root","params","onlyMatchedOnce","removeMatchedSelectors","useMqs","usePseudos","styles","selectors","element","enter","node","parentNode","children","length","attributes","type","cssText","child","cssAst","parse","parseValue","parseCustomProperty","push","walk","visit","item","atrule","rule","mq","prelude","generate","includes","pseudos","forEach","childNode","childItem","childList","list","pseudoSelectors","List","fromArray","map","pseudo","data","remove","exit","sortedSelectors","sort","aSpecificity","bSpecificity","reverse","selector","selectorText","matchedElements","selectError","selectedEl","styleDeclarationList","style","context","styleDeclarationItems","Map","set","property","ruleDeclaration","matchedItem","get","ruleDeclarationItem","createItem","append","important","replace","classList","Set","class","split","firstSubSelector","first","delete","size","Array","from","join","id","isEmpty","firstChild"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/inlineStyles.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').Specificity} Specificity\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\n\nconst csstree = require('css-tree');\nconst {\n  // @ts-ignore not defined in @types/csso\n  syntax: { specificity },\n} = require('csso');\nconst {\n  visitSkip,\n  querySelectorAll,\n  detachNodeFromParent,\n} = require('../lib/xast.js');\n\nexports.name = 'inlineStyles';\nexports.description = 'inline styles (additional options)';\n\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/main/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n  return 0;\n};\n\n/**\n * @type {(value: any) => any}\n */\nconst toAny = (value) => value;\n\n/**\n * Moves + merges styles from style elements to element styles\n *\n * Options\n *   onlyMatchedOnce (default: true)\n *     inline only selectors that match once\n *\n *   removeMatchedSelectors (default: true)\n *     clean up matched selectors,\n *     leave selectors that hadn't matched\n *\n *   useMqs (default: ['', 'screen'])\n *     what media queries to be used\n *     empty string element for styles outside media queries\n *\n *   usePseudos (default: [''])\n *     what pseudo-classes/-elements to be used\n *     empty string element for all non-pseudo-classes and/or -elements\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('./plugins-types').Plugin<'inlineStyles'>}\n */\nexports.fn = (root, params) => {\n  const {\n    onlyMatchedOnce = true,\n    removeMatchedSelectors = true,\n    useMqs = ['', 'screen'],\n    usePseudos = [''],\n  } = params;\n\n  /**\n   * @type {Array<{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }>}\n   */\n  const styles = [];\n  /**\n   * @type {Array<{\n   *   node: csstree.Selector,\n   *   item: csstree.ListItem<csstree.CssNode>,\n   *   rule: csstree.Rule,\n   *   matchedElements?: Array<XastElement>\n   * }>}\n   */\n  let selectors = [];\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject /> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n        // collect only non-empty <style /> elements\n        if (node.name !== 'style' || node.children.length === 0) {\n          return;\n        }\n        // values other than the empty string or text/css are not used\n        if (\n          node.attributes.type != null &&\n          node.attributes.type !== '' &&\n          node.attributes.type !== 'text/css'\n        ) {\n          return;\n        }\n        // parse css in style element\n        let cssText = '';\n        for (const child of node.children) {\n          if (child.type === 'text' || child.type === 'cdata') {\n            cssText += child.value;\n          }\n        }\n        /**\n         * @type {null | csstree.CssNode}\n         */\n        let cssAst = null;\n        try {\n          cssAst = csstree.parse(cssText, {\n            parseValue: false,\n            parseCustomProperty: false,\n          });\n        } catch {\n          return;\n        }\n        if (cssAst.type === 'StyleSheet') {\n          styles.push({ node, parentNode, cssAst });\n        }\n\n        // collect selectors\n        csstree.walk(cssAst, {\n          visit: 'Selector',\n          enter(node, item) {\n            const atrule = this.atrule;\n            const rule = this.rule;\n            if (rule == null) {\n              return;\n            }\n\n            // skip media queries not included into useMqs param\n            let mq = '';\n            if (atrule != null) {\n              mq = atrule.name;\n              if (atrule.prelude != null) {\n                mq += ` ${csstree.generate(atrule.prelude)}`;\n              }\n            }\n            if (useMqs.includes(mq) === false) {\n              return;\n            }\n\n            /**\n             * @type {Array<{\n             *   item: csstree.ListItem<csstree.CssNode>,\n             *   list: csstree.List<csstree.CssNode>\n             * }>}\n             */\n            const pseudos = [];\n            if (node.type === 'Selector') {\n              node.children.forEach((childNode, childItem, childList) => {\n                if (\n                  childNode.type === 'PseudoClassSelector' ||\n                  childNode.type === 'PseudoElementSelector'\n                ) {\n                  pseudos.push({ item: childItem, list: childList });\n                }\n              });\n            }\n\n            // skip pseudo classes and pseudo elements not includes into usePseudos param\n            const pseudoSelectors = csstree.generate({\n              type: 'Selector',\n              children: new csstree.List().fromArray(\n                pseudos.map((pseudo) => pseudo.item.data)\n              ),\n            });\n            if (usePseudos.includes(pseudoSelectors) === false) {\n              return;\n            }\n\n            // remove pseudo classes and elements to allow querySelector match elements\n            // TODO this is not very accurate since some pseudo classes like first-child\n            // are used for selection\n            for (const pseudo of pseudos) {\n              pseudo.list.remove(pseudo.item);\n            }\n\n            selectors.push({ node, item, rule });\n          },\n        });\n      },\n    },\n\n    root: {\n      exit: () => {\n        if (styles.length === 0) {\n          return;\n        }\n        // stable sort selectors\n        const sortedSelectors = [...selectors]\n          .sort((a, b) => {\n            const aSpecificity = specificity(a.item.data);\n            const bSpecificity = specificity(b.item.data);\n            return compareSpecificity(aSpecificity, bSpecificity);\n          })\n          .reverse();\n\n        for (const selector of sortedSelectors) {\n          // match selectors\n          const selectorText = csstree.generate(selector.item.data);\n          /**\n           * @type {Array<XastElement>}\n           */\n          const matchedElements = [];\n          try {\n            for (const node of querySelectorAll(root, selectorText)) {\n              if (node.type === 'element') {\n                matchedElements.push(node);\n              }\n            }\n          } catch (selectError) {\n            continue;\n          }\n          // nothing selected\n          if (matchedElements.length === 0) {\n            continue;\n          }\n\n          // apply styles to matched elements\n          // skip selectors that match more than once if option onlyMatchedOnce is enabled\n          if (onlyMatchedOnce && matchedElements.length > 1) {\n            continue;\n          }\n\n          // apply <style/> to matched elements\n          for (const selectedEl of matchedElements) {\n            const styleDeclarationList = csstree.parse(\n              selectedEl.attributes.style == null\n                ? ''\n                : selectedEl.attributes.style,\n              {\n                context: 'declarationList',\n                parseValue: false,\n              }\n            );\n            if (styleDeclarationList.type !== 'DeclarationList') {\n              continue;\n            }\n            const styleDeclarationItems = new Map();\n            csstree.walk(styleDeclarationList, {\n              visit: 'Declaration',\n              enter(node, item) {\n                styleDeclarationItems.set(node.property, item);\n              },\n            });\n            // merge declarations\n            csstree.walk(selector.rule, {\n              visit: 'Declaration',\n              enter(ruleDeclaration) {\n                // existing inline styles have higher priority\n                // no inline styles, external styles,                                    external styles used\n                // inline styles,    external styles same   priority as inline styles,   inline   styles used\n                // inline styles,    external styles higher priority than inline styles, external styles used\n                const matchedItem = styleDeclarationItems.get(\n                  ruleDeclaration.property\n                );\n                const ruleDeclarationItem =\n                  styleDeclarationList.children.createItem(ruleDeclaration);\n                if (matchedItem == null) {\n                  styleDeclarationList.children.append(ruleDeclarationItem);\n                } else if (\n                  matchedItem.data.important !== true &&\n                  ruleDeclaration.important === true\n                ) {\n                  styleDeclarationList.children.replace(\n                    matchedItem,\n                    ruleDeclarationItem\n                  );\n                  styleDeclarationItems.set(\n                    ruleDeclaration.property,\n                    ruleDeclarationItem\n                  );\n                }\n              },\n            });\n            selectedEl.attributes.style =\n              csstree.generate(styleDeclarationList);\n          }\n\n          if (\n            removeMatchedSelectors &&\n            matchedElements.length !== 0 &&\n            selector.rule.prelude.type === 'SelectorList'\n          ) {\n            // clean up matching simple selectors if option removeMatchedSelectors is enabled\n            selector.rule.prelude.children.remove(selector.item);\n          }\n          selector.matchedElements = matchedElements;\n        }\n\n        // no further processing required\n        if (removeMatchedSelectors === false) {\n          return;\n        }\n\n        // clean up matched class + ID attribute values\n        for (const selector of sortedSelectors) {\n          if (selector.matchedElements == null) {\n            continue;\n          }\n\n          if (onlyMatchedOnce && selector.matchedElements.length > 1) {\n            // skip selectors that match more than once if option onlyMatchedOnce is enabled\n            continue;\n          }\n\n          for (const selectedEl of selector.matchedElements) {\n            // class\n            const classList = new Set(\n              selectedEl.attributes.class == null\n                ? null\n                : selectedEl.attributes.class.split(' ')\n            );\n            /**\n             * csstree v2 changed this type\n             * @type {csstree.CssNode}\n             */\n            const firstSubSelector = toAny(selector.node.children.first);\n            if (\n              firstSubSelector != null &&\n              firstSubSelector.type === 'ClassSelector'\n            ) {\n              classList.delete(firstSubSelector.name);\n            }\n            if (classList.size === 0) {\n              delete selectedEl.attributes.class;\n            } else {\n              selectedEl.attributes.class = Array.from(classList).join(' ');\n            }\n\n            // ID\n            if (\n              firstSubSelector != null &&\n              firstSubSelector.type === 'IdSelector'\n            ) {\n              if (selectedEl.attributes.id === firstSubSelector.name) {\n                delete selectedEl.attributes.id;\n              }\n            }\n          }\n        }\n\n        for (const style of styles) {\n          csstree.walk(style.cssAst, {\n            visit: 'Rule',\n            enter: function (node, item, list) {\n              // clean up <style/> rulesets without any css selectors left\n              if (\n                node.type === 'Rule' &&\n                node.prelude.type === 'SelectorList' &&\n                // csstree v2 changed this type\n                toAny(node.prelude.children.isEmpty)\n              ) {\n                list.remove(item);\n              }\n            },\n          });\n\n          // csstree v2 changed this type\n          if (toAny(style.cssAst.children.isEmpty)) {\n            // remove emtpy style element\n            detachNodeFromParent(style.node, style.parentNode);\n          } else {\n            // update style element if any styles left\n            const firstChild = style.node.children[0];\n            if (firstChild.type === 'text' || firstChild.type === 'cdata') {\n              firstChild.value = csstree.generate(style.cssAst);\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAU,CAAC;AACnC,MAAM;EACJ;EACAC,MAAM,EAAE;IAAEC;EAAY;AACxB,CAAC,GAAGF,OAAO,CAAC,MAAM,CAAC;AACnB,MAAM;EACJG,SAAS;EACTC,gBAAgB;EAChBC;AACF,CAAC,GAAGL,OAAO,CAAC,gBAAgB,CAAC;AAE7BM,OAAO,CAACC,IAAI,GAAG,cAAc;AAC7BD,OAAO,CAACE,WAAW,GAAG,oCAAoC;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;EACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC7B,IAAIF,CAAC,CAACE,CAAC,CAAC,GAAGD,CAAC,CAACC,CAAC,CAAC,EAAE;MACf,OAAO,CAAC,CAAC;IACX,CAAC,MAAM,IAAIF,CAAC,CAACE,CAAC,CAAC,GAAGD,CAAC,CAACC,CAAC,CAAC,EAAE;MACtB,OAAO,CAAC;IACV;EACF;EACA,OAAO,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA,MAAMC,KAAK,GAAIC,KAAK,IAAKA,KAAK;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,OAAO,CAACS,EAAE,GAAG,CAACC,IAAI,EAAEC,MAAM,KAAK;EAC7B,MAAM;IACJC,eAAe,GAAG,IAAI;IACtBC,sBAAsB,GAAG,IAAI;IAC7BC,MAAM,GAAG,CAAC,EAAE,EAAE,QAAQ,CAAC;IACvBC,UAAU,GAAG,CAAC,EAAE;EAClB,CAAC,GAAGJ,MAAM;;EAEV;AACF;AACA;EACE,MAAMK,MAAM,GAAG,EAAE;EACjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIC,SAAS,GAAG,EAAE;EAElB,OAAO;IACLC,OAAO,EAAE;MACPC,KAAK,EAAEA,CAACC,IAAI,EAAEC,UAAU,KAAK;QAC3B;QACA,IAAID,IAAI,CAACnB,IAAI,KAAK,eAAe,EAAE;UACjC,OAAOJ,SAAS;QAClB;QACA;QACA,IAAIuB,IAAI,CAACnB,IAAI,KAAK,OAAO,IAAImB,IAAI,CAACE,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE;UACvD;QACF;QACA;QACA,IACEH,IAAI,CAACI,UAAU,CAACC,IAAI,IAAI,IAAI,IAC5BL,IAAI,CAACI,UAAU,CAACC,IAAI,KAAK,EAAE,IAC3BL,IAAI,CAACI,UAAU,CAACC,IAAI,KAAK,UAAU,EACnC;UACA;QACF;QACA;QACA,IAAIC,OAAO,GAAG,EAAE;QAChB,KAAK,MAAMC,KAAK,IAAIP,IAAI,CAACE,QAAQ,EAAE;UACjC,IAAIK,KAAK,CAACF,IAAI,KAAK,MAAM,IAAIE,KAAK,CAACF,IAAI,KAAK,OAAO,EAAE;YACnDC,OAAO,IAAIC,KAAK,CAACnB,KAAK;UACxB;QACF;QACA;AACR;AACA;QACQ,IAAIoB,MAAM,GAAG,IAAI;QACjB,IAAI;UACFA,MAAM,GAAGnC,OAAO,CAACoC,KAAK,CAACH,OAAO,EAAE;YAC9BI,UAAU,EAAE,KAAK;YACjBC,mBAAmB,EAAE;UACvB,CAAC,CAAC;QACJ,CAAC,CAAC,MAAM;UACN;QACF;QACA,IAAIH,MAAM,CAACH,IAAI,KAAK,YAAY,EAAE;UAChCT,MAAM,CAACgB,IAAI,CAAC;YAAEZ,IAAI;YAAEC,UAAU;YAAEO;UAAO,CAAC,CAAC;QAC3C;;QAEA;QACAnC,OAAO,CAACwC,IAAI,CAACL,MAAM,EAAE;UACnBM,KAAK,EAAE,UAAU;UACjBf,KAAKA,CAACC,IAAI,EAAEe,IAAI,EAAE;YAChB,MAAMC,MAAM,GAAG,IAAI,CAACA,MAAM;YAC1B,MAAMC,IAAI,GAAG,IAAI,CAACA,IAAI;YACtB,IAAIA,IAAI,IAAI,IAAI,EAAE;cAChB;YACF;;YAEA;YACA,IAAIC,EAAE,GAAG,EAAE;YACX,IAAIF,MAAM,IAAI,IAAI,EAAE;cAClBE,EAAE,GAAGF,MAAM,CAACnC,IAAI;cAChB,IAAImC,MAAM,CAACG,OAAO,IAAI,IAAI,EAAE;gBAC1BD,EAAE,IAAK,IAAG7C,OAAO,CAAC+C,QAAQ,CAACJ,MAAM,CAACG,OAAO,CAAE,EAAC;cAC9C;YACF;YACA,IAAIzB,MAAM,CAAC2B,QAAQ,CAACH,EAAE,CAAC,KAAK,KAAK,EAAE;cACjC;YACF;;YAEA;AACZ;AACA;AACA;AACA;AACA;YACY,MAAMI,OAAO,GAAG,EAAE;YAClB,IAAItB,IAAI,CAACK,IAAI,KAAK,UAAU,EAAE;cAC5BL,IAAI,CAACE,QAAQ,CAACqB,OAAO,CAAC,CAACC,SAAS,EAAEC,SAAS,EAAEC,SAAS,KAAK;gBACzD,IACEF,SAAS,CAACnB,IAAI,KAAK,qBAAqB,IACxCmB,SAAS,CAACnB,IAAI,KAAK,uBAAuB,EAC1C;kBACAiB,OAAO,CAACV,IAAI,CAAC;oBAAEG,IAAI,EAAEU,SAAS;oBAAEE,IAAI,EAAED;kBAAU,CAAC,CAAC;gBACpD;cACF,CAAC,CAAC;YACJ;;YAEA;YACA,MAAME,eAAe,GAAGvD,OAAO,CAAC+C,QAAQ,CAAC;cACvCf,IAAI,EAAE,UAAU;cAChBH,QAAQ,EAAE,IAAI7B,OAAO,CAACwD,IAAI,CAAC,CAAC,CAACC,SAAS,CACpCR,OAAO,CAACS,GAAG,CAAEC,MAAM,IAAKA,MAAM,CAACjB,IAAI,CAACkB,IAAI,CAC1C;YACF,CAAC,CAAC;YACF,IAAItC,UAAU,CAAC0B,QAAQ,CAACO,eAAe,CAAC,KAAK,KAAK,EAAE;cAClD;YACF;;YAEA;YACA;YACA;YACA,KAAK,MAAMI,MAAM,IAAIV,OAAO,EAAE;cAC5BU,MAAM,CAACL,IAAI,CAACO,MAAM,CAACF,MAAM,CAACjB,IAAI,CAAC;YACjC;YAEAlB,SAAS,CAACe,IAAI,CAAC;cAAEZ,IAAI;cAAEe,IAAI;cAAEE;YAAK,CAAC,CAAC;UACtC;QACF,CAAC,CAAC;MACJ;IACF,CAAC;IAED3B,IAAI,EAAE;MACJ6C,IAAI,EAAEA,CAAA,KAAM;QACV,IAAIvC,MAAM,CAACO,MAAM,KAAK,CAAC,EAAE;UACvB;QACF;QACA;QACA,MAAMiC,eAAe,GAAG,CAAC,GAAGvC,SAAS,CAAC,CACnCwC,IAAI,CAAC,CAACrD,CAAC,EAAEC,CAAC,KAAK;UACd,MAAMqD,YAAY,GAAG9D,WAAW,CAACQ,CAAC,CAAC+B,IAAI,CAACkB,IAAI,CAAC;UAC7C,MAAMM,YAAY,GAAG/D,WAAW,CAACS,CAAC,CAAC8B,IAAI,CAACkB,IAAI,CAAC;UAC7C,OAAOlD,kBAAkB,CAACuD,YAAY,EAAEC,YAAY,CAAC;QACvD,CAAC,CAAC,CACDC,OAAO,CAAC,CAAC;QAEZ,KAAK,MAAMC,QAAQ,IAAIL,eAAe,EAAE;UACtC;UACA,MAAMM,YAAY,GAAGrE,OAAO,CAAC+C,QAAQ,CAACqB,QAAQ,CAAC1B,IAAI,CAACkB,IAAI,CAAC;UACzD;AACV;AACA;UACU,MAAMU,eAAe,GAAG,EAAE;UAC1B,IAAI;YACF,KAAK,MAAM3C,IAAI,IAAItB,gBAAgB,CAACY,IAAI,EAAEoD,YAAY,CAAC,EAAE;cACvD,IAAI1C,IAAI,CAACK,IAAI,KAAK,SAAS,EAAE;gBAC3BsC,eAAe,CAAC/B,IAAI,CAACZ,IAAI,CAAC;cAC5B;YACF;UACF,CAAC,CAAC,OAAO4C,WAAW,EAAE;YACpB;UACF;UACA;UACA,IAAID,eAAe,CAACxC,MAAM,KAAK,CAAC,EAAE;YAChC;UACF;;UAEA;UACA;UACA,IAAIX,eAAe,IAAImD,eAAe,CAACxC,MAAM,GAAG,CAAC,EAAE;YACjD;UACF;;UAEA;UACA,KAAK,MAAM0C,UAAU,IAAIF,eAAe,EAAE;YACxC,MAAMG,oBAAoB,GAAGzE,OAAO,CAACoC,KAAK,CACxCoC,UAAU,CAACzC,UAAU,CAAC2C,KAAK,IAAI,IAAI,GAC/B,EAAE,GACFF,UAAU,CAACzC,UAAU,CAAC2C,KAAK,EAC/B;cACEC,OAAO,EAAE,iBAAiB;cAC1BtC,UAAU,EAAE;YACd,CACF,CAAC;YACD,IAAIoC,oBAAoB,CAACzC,IAAI,KAAK,iBAAiB,EAAE;cACnD;YACF;YACA,MAAM4C,qBAAqB,GAAG,IAAIC,GAAG,CAAC,CAAC;YACvC7E,OAAO,CAACwC,IAAI,CAACiC,oBAAoB,EAAE;cACjChC,KAAK,EAAE,aAAa;cACpBf,KAAKA,CAACC,IAAI,EAAEe,IAAI,EAAE;gBAChBkC,qBAAqB,CAACE,GAAG,CAACnD,IAAI,CAACoD,QAAQ,EAAErC,IAAI,CAAC;cAChD;YACF,CAAC,CAAC;YACF;YACA1C,OAAO,CAACwC,IAAI,CAAC4B,QAAQ,CAACxB,IAAI,EAAE;cAC1BH,KAAK,EAAE,aAAa;cACpBf,KAAKA,CAACsD,eAAe,EAAE;gBACrB;gBACA;gBACA;gBACA;gBACA,MAAMC,WAAW,GAAGL,qBAAqB,CAACM,GAAG,CAC3CF,eAAe,CAACD,QAClB,CAAC;gBACD,MAAMI,mBAAmB,GACvBV,oBAAoB,CAAC5C,QAAQ,CAACuD,UAAU,CAACJ,eAAe,CAAC;gBAC3D,IAAIC,WAAW,IAAI,IAAI,EAAE;kBACvBR,oBAAoB,CAAC5C,QAAQ,CAACwD,MAAM,CAACF,mBAAmB,CAAC;gBAC3D,CAAC,MAAM,IACLF,WAAW,CAACrB,IAAI,CAAC0B,SAAS,KAAK,IAAI,IACnCN,eAAe,CAACM,SAAS,KAAK,IAAI,EAClC;kBACAb,oBAAoB,CAAC5C,QAAQ,CAAC0D,OAAO,CACnCN,WAAW,EACXE,mBACF,CAAC;kBACDP,qBAAqB,CAACE,GAAG,CACvBE,eAAe,CAACD,QAAQ,EACxBI,mBACF,CAAC;gBACH;cACF;YACF,CAAC,CAAC;YACFX,UAAU,CAACzC,UAAU,CAAC2C,KAAK,GACzB1E,OAAO,CAAC+C,QAAQ,CAAC0B,oBAAoB,CAAC;UAC1C;UAEA,IACErD,sBAAsB,IACtBkD,eAAe,CAACxC,MAAM,KAAK,CAAC,IAC5BsC,QAAQ,CAACxB,IAAI,CAACE,OAAO,CAACd,IAAI,KAAK,cAAc,EAC7C;YACA;YACAoC,QAAQ,CAACxB,IAAI,CAACE,OAAO,CAACjB,QAAQ,CAACgC,MAAM,CAACO,QAAQ,CAAC1B,IAAI,CAAC;UACtD;UACA0B,QAAQ,CAACE,eAAe,GAAGA,eAAe;QAC5C;;QAEA;QACA,IAAIlD,sBAAsB,KAAK,KAAK,EAAE;UACpC;QACF;;QAEA;QACA,KAAK,MAAMgD,QAAQ,IAAIL,eAAe,EAAE;UACtC,IAAIK,QAAQ,CAACE,eAAe,IAAI,IAAI,EAAE;YACpC;UACF;UAEA,IAAInD,eAAe,IAAIiD,QAAQ,CAACE,eAAe,CAACxC,MAAM,GAAG,CAAC,EAAE;YAC1D;YACA;UACF;UAEA,KAAK,MAAM0C,UAAU,IAAIJ,QAAQ,CAACE,eAAe,EAAE;YACjD;YACA,MAAMkB,SAAS,GAAG,IAAIC,GAAG,CACvBjB,UAAU,CAACzC,UAAU,CAAC2D,KAAK,IAAI,IAAI,GAC/B,IAAI,GACJlB,UAAU,CAACzC,UAAU,CAAC2D,KAAK,CAACC,KAAK,CAAC,GAAG,CAC3C,CAAC;YACD;AACZ;AACA;AACA;YACY,MAAMC,gBAAgB,GAAG9E,KAAK,CAACsD,QAAQ,CAACzC,IAAI,CAACE,QAAQ,CAACgE,KAAK,CAAC;YAC5D,IACED,gBAAgB,IAAI,IAAI,IACxBA,gBAAgB,CAAC5D,IAAI,KAAK,eAAe,EACzC;cACAwD,SAAS,CAACM,MAAM,CAACF,gBAAgB,CAACpF,IAAI,CAAC;YACzC;YACA,IAAIgF,SAAS,CAACO,IAAI,KAAK,CAAC,EAAE;cACxB,OAAOvB,UAAU,CAACzC,UAAU,CAAC2D,KAAK;YACpC,CAAC,MAAM;cACLlB,UAAU,CAACzC,UAAU,CAAC2D,KAAK,GAAGM,KAAK,CAACC,IAAI,CAACT,SAAS,CAAC,CAACU,IAAI,CAAC,GAAG,CAAC;YAC/D;;YAEA;YACA,IACEN,gBAAgB,IAAI,IAAI,IACxBA,gBAAgB,CAAC5D,IAAI,KAAK,YAAY,EACtC;cACA,IAAIwC,UAAU,CAACzC,UAAU,CAACoE,EAAE,KAAKP,gBAAgB,CAACpF,IAAI,EAAE;gBACtD,OAAOgE,UAAU,CAACzC,UAAU,CAACoE,EAAE;cACjC;YACF;UACF;QACF;QAEA,KAAK,MAAMzB,KAAK,IAAInD,MAAM,EAAE;UAC1BvB,OAAO,CAACwC,IAAI,CAACkC,KAAK,CAACvC,MAAM,EAAE;YACzBM,KAAK,EAAE,MAAM;YACbf,KAAK,EAAE,SAAAA,CAAUC,IAAI,EAAEe,IAAI,EAAEY,IAAI,EAAE;cACjC;cACA,IACE3B,IAAI,CAACK,IAAI,KAAK,MAAM,IACpBL,IAAI,CAACmB,OAAO,CAACd,IAAI,KAAK,cAAc;cACpC;cACAlB,KAAK,CAACa,IAAI,CAACmB,OAAO,CAACjB,QAAQ,CAACuE,OAAO,CAAC,EACpC;gBACA9C,IAAI,CAACO,MAAM,CAACnB,IAAI,CAAC;cACnB;YACF;UACF,CAAC,CAAC;;UAEF;UACA,IAAI5B,KAAK,CAAC4D,KAAK,CAACvC,MAAM,CAACN,QAAQ,CAACuE,OAAO,CAAC,EAAE;YACxC;YACA9F,oBAAoB,CAACoE,KAAK,CAAC/C,IAAI,EAAE+C,KAAK,CAAC9C,UAAU,CAAC;UACpD,CAAC,MAAM;YACL;YACA,MAAMyE,UAAU,GAAG3B,KAAK,CAAC/C,IAAI,CAACE,QAAQ,CAAC,CAAC,CAAC;YACzC,IAAIwE,UAAU,CAACrE,IAAI,KAAK,MAAM,IAAIqE,UAAU,CAACrE,IAAI,KAAK,OAAO,EAAE;cAC7DqE,UAAU,CAACtF,KAAK,GAAGf,OAAO,CAAC+C,QAAQ,CAAC2B,KAAK,CAACvC,MAAM,CAAC;YACnD;UACF;QACF;MACF;IACF;EACF,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}