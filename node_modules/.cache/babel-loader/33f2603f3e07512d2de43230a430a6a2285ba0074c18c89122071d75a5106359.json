{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastNode} XastNode\n */\nconst {\n  inheritableAttrs,\n  elemsGroups\n} = require('./_collections.js');\nexports.name = 'collapseGroups';\nexports.description = 'collapses useless groups';\n\n/**\n * @type {(node: XastNode, name: string) => boolean}\n */\nconst hasAnimatedAttr = (node, name) => {\n  if (node.type === 'element') {\n    if (elemsGroups.animation.includes(node.name) && node.attributes.attributeName === name) {\n      return true;\n    }\n    for (const child of node.children) {\n      if (hasAnimatedAttr(child, name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Collapse useless groups.\n *\n * @example\n * <g>\n *     <g attr1=\"val1\">\n *         <path d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <g>\n *     <g>\n *         <path attr1=\"val1\" d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <path attr1=\"val1\" d=\"...\"/>\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'collapseGroups'>}\n */\nexports.fn = () => {\n  return {\n    element: {\n      exit: (node, parentNode) => {\n        if (parentNode.type === 'root' || parentNode.name === 'switch') {\n          return;\n        }\n        // non-empty groups\n        if (node.name !== 'g' || node.children.length === 0) {\n          return;\n        }\n\n        // move group attibutes to the single child element\n        if (Object.keys(node.attributes).length !== 0 && node.children.length === 1) {\n          const firstChild = node.children[0];\n          // TODO untangle this mess\n          if (firstChild.type === 'element' && firstChild.attributes.id == null && node.attributes.filter == null && (node.attributes.class == null || firstChild.attributes.class == null) && (node.attributes['clip-path'] == null && node.attributes.mask == null || firstChild.name === 'g' && node.attributes.transform == null && firstChild.attributes.transform == null)) {\n            for (const [name, value] of Object.entries(node.attributes)) {\n              // avoid copying to not conflict with animated attribute\n              if (hasAnimatedAttr(firstChild, name)) {\n                return;\n              }\n              if (firstChild.attributes[name] == null) {\n                firstChild.attributes[name] = value;\n              } else if (name === 'transform') {\n                firstChild.attributes[name] = value + ' ' + firstChild.attributes[name];\n              } else if (firstChild.attributes[name] === 'inherit') {\n                firstChild.attributes[name] = value;\n              } else if (inheritableAttrs.includes(name) === false && firstChild.attributes[name] !== value) {\n                return;\n              }\n              delete node.attributes[name];\n            }\n          }\n        }\n\n        // collapse groups without attributes\n        if (Object.keys(node.attributes).length === 0) {\n          // animation elements \"add\" attributes to group\n          // group should be preserved\n          for (const child of node.children) {\n            if (child.type === 'element' && elemsGroups.animation.includes(child.name)) {\n              return;\n            }\n          }\n          // replace current node with all its children\n          const index = parentNode.children.indexOf(node);\n          parentNode.children.splice(index, 1, ...node.children);\n          // TODO remove legacy parentNode in v4\n          for (const child of node.children) {\n            Object.defineProperty(child, 'parentNode', {\n              writable: true,\n              value: parentNode\n            });\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["inheritableAttrs","elemsGroups","require","exports","name","description","hasAnimatedAttr","node","type","animation","includes","attributes","attributeName","child","children","fn","element","exit","parentNode","length","Object","keys","firstChild","id","filter","class","mask","transform","value","entries","index","indexOf","splice","defineProperty","writable"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/collapseGroups.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastNode} XastNode\n */\n\nconst { inheritableAttrs, elemsGroups } = require('./_collections.js');\n\nexports.name = 'collapseGroups';\nexports.description = 'collapses useless groups';\n\n/**\n * @type {(node: XastNode, name: string) => boolean}\n */\nconst hasAnimatedAttr = (node, name) => {\n  if (node.type === 'element') {\n    if (\n      elemsGroups.animation.includes(node.name) &&\n      node.attributes.attributeName === name\n    ) {\n      return true;\n    }\n    for (const child of node.children) {\n      if (hasAnimatedAttr(child, name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Collapse useless groups.\n *\n * @example\n * <g>\n *     <g attr1=\"val1\">\n *         <path d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <g>\n *     <g>\n *         <path attr1=\"val1\" d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <path attr1=\"val1\" d=\"...\"/>\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'collapseGroups'>}\n */\nexports.fn = () => {\n  return {\n    element: {\n      exit: (node, parentNode) => {\n        if (parentNode.type === 'root' || parentNode.name === 'switch') {\n          return;\n        }\n        // non-empty groups\n        if (node.name !== 'g' || node.children.length === 0) {\n          return;\n        }\n\n        // move group attibutes to the single child element\n        if (\n          Object.keys(node.attributes).length !== 0 &&\n          node.children.length === 1\n        ) {\n          const firstChild = node.children[0];\n          // TODO untangle this mess\n          if (\n            firstChild.type === 'element' &&\n            firstChild.attributes.id == null &&\n            node.attributes.filter == null &&\n            (node.attributes.class == null ||\n              firstChild.attributes.class == null) &&\n            ((node.attributes['clip-path'] == null &&\n              node.attributes.mask == null) ||\n              (firstChild.name === 'g' &&\n                node.attributes.transform == null &&\n                firstChild.attributes.transform == null))\n          ) {\n            for (const [name, value] of Object.entries(node.attributes)) {\n              // avoid copying to not conflict with animated attribute\n              if (hasAnimatedAttr(firstChild, name)) {\n                return;\n              }\n              if (firstChild.attributes[name] == null) {\n                firstChild.attributes[name] = value;\n              } else if (name === 'transform') {\n                firstChild.attributes[name] =\n                  value + ' ' + firstChild.attributes[name];\n              } else if (firstChild.attributes[name] === 'inherit') {\n                firstChild.attributes[name] = value;\n              } else if (\n                inheritableAttrs.includes(name) === false &&\n                firstChild.attributes[name] !== value\n              ) {\n                return;\n              }\n              delete node.attributes[name];\n            }\n          }\n        }\n\n        // collapse groups without attributes\n        if (Object.keys(node.attributes).length === 0) {\n          // animation elements \"add\" attributes to group\n          // group should be preserved\n          for (const child of node.children) {\n            if (\n              child.type === 'element' &&\n              elemsGroups.animation.includes(child.name)\n            ) {\n              return;\n            }\n          }\n          // replace current node with all its children\n          const index = parentNode.children.indexOf(node);\n          parentNode.children.splice(index, 1, ...node.children);\n          // TODO remove legacy parentNode in v4\n          for (const child of node.children) {\n            Object.defineProperty(child, 'parentNode', {\n              writable: true,\n              value: parentNode,\n            });\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}