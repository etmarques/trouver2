{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _pluginSyntaxPrivatePropertyInObject = require(\"@babel/plugin-syntax-private-property-in-object\");\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _default = (0, _helperPluginUtils.declare)((api, opt) => {\n  api.assertVersion(7);\n  const {\n    types: t,\n    template\n  } = api;\n  const {\n    loose\n  } = opt;\n  const classWeakSets = new WeakMap();\n  const fieldsWeakSets = new WeakMap();\n  function unshadow(name, targetScope, scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n  function injectToFieldInit(fieldPath, expr) {\n    let before = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n  function injectInitialization(classPath, init) {\n    let firstFieldPath;\n    let constructorPath;\n    for (const el of classPath.get(\"body.body\")) {\n      if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!constructorPath && el.isClassMethod({\n        kind: \"constructor\"\n      })) {\n        constructorPath = el;\n      }\n    }\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, constructorPath, [t.expressionStatement(init)]);\n    }\n  }\n  function getWeakSetId(weakSets, outerClass, reference) {\n    let name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    let inject = arguments.length > 4 ? arguments[4] : undefined;\n    let id = weakSets.get(reference.node);\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      weakSets.set(reference.node, id);\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      (0, _helperAnnotateAsPure.default)(newExpr);\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n    return t.cloneNode(id);\n  }\n  return {\n    name: \"transform-private-property-in-object\",\n    inherits: _pluginSyntaxPrivatePropertyInObject.default,\n    pre() {\n      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.privateIn, loose);\n    },\n    visitor: {\n      BinaryExpression(path, state) {\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = state;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n        const {\n          name\n        } = node.left.id;\n        let privateElement;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n          privateElement = path.get(\"body.body\").find(_ref => {\n            let {\n              node\n            } = _ref;\n            return t.isPrivate(node) && node.key.id.name === name;\n          });\n          return !!privateElement;\n        });\n        if (outerClass.parentPath.scope.path.isPattern()) {\n          outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`);\n          return;\n        }\n        if (privateElement.node.type === \"ClassPrivateMethod\") {\n          if (privateElement.node.static) {\n            if (outerClass.node.id) {\n              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);\n            } else {\n              outerClass.set(\"id\", path.scope.generateUidIdentifier(\"class\"));\n            }\n            path.replaceWith(template.expression.ast`\n                ${t.cloneNode(outerClass.node.id)} === ${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)}\n              `);\n          } else {\n            var _outerClass$node$id;\n            const id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization);\n            path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);\n          }\n        } else {\n          const id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);\n          path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);\n        }\n      }\n    }\n  };\n});\nexports.default = _default;","map":{"version":3,"names":["_helperPluginUtils","require","_pluginSyntaxPrivatePropertyInObject","_helperCreateClassFeaturesPlugin","_helperAnnotateAsPure","_default","declare","api","opt","assertVersion","types","t","template","loose","classWeakSets","WeakMap","fieldsWeakSets","unshadow","name","targetScope","scope","hasOwnBinding","rename","parent","injectToFieldInit","fieldPath","expr","before","arguments","length","undefined","node","value","get","insertBefore","insertAfter","set","unaryExpression","injectInitialization","classPath","init","firstFieldPath","constructorPath","el","isClassProperty","isClassPrivateProperty","static","isClassMethod","kind","expressionStatement","getWeakSetId","weakSets","outerClass","reference","inject","id","generateUidIdentifier","expression","ast","cloneNode","newExpr","newExpression","identifier","default","inherits","pre","enableFeature","file","FEATURES","privateIn","visitor","BinaryExpression","path","state","operator","isPrivateName","left","privateElement","findParent","isClass","find","_ref","isPrivate","key","parentPath","isPattern","replaceWith","type","buildCheckInRHS","right","_outerClass$node$id","exports"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@babel\\plugin-transform-private-property-in-object\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxPlugin from \"@babel/plugin-syntax-private-property-in-object\";\nimport {\n  enableFeature,\n  FEATURES,\n  injectInitialization as injectConstructorInit,\n  buildCheckInRHS,\n} from \"@babel/helper-create-class-features-plugin\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\n\nexport interface Options {\n  loose?: boolean;\n}\nexport default declare((api, opt: Options) => {\n  api.assertVersion(7);\n  const { types: t, template } = api;\n  const { loose } = opt;\n\n  // NOTE: When using the class fields or private methods plugins,\n  // they will also take care of '#priv in obj' checks when visiting\n  // the ClassExpression or ClassDeclaration nodes.\n  // The visitor of this plugin is only effective when not compiling\n  // private fields and methods.\n\n  const classWeakSets: WeakMap<t.Class, t.Identifier> = new WeakMap();\n  const fieldsWeakSets: WeakMap<\n    t.ClassPrivateProperty | t.ClassPrivateMethod,\n    t.Identifier\n  > = new WeakMap();\n\n  function unshadow(name: string, targetScope: Scope, scope: Scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n\n  function injectToFieldInit(\n    fieldPath: NodePath<t.ClassPrivateProperty | t.ClassProperty>,\n    expr: t.Expression,\n    before = false,\n  ) {\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n\n  function injectInitialization(\n    classPath: NodePath<t.Class>,\n    init: t.Expression,\n  ) {\n    let firstFieldPath;\n    let constructorPath;\n\n    for (const el of classPath.get(\"body.body\")) {\n      if (\n        (el.isClassProperty() || el.isClassPrivateProperty()) &&\n        !el.node.static\n      ) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!constructorPath && el.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = el;\n      }\n    }\n\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      injectConstructorInit(classPath, constructorPath, [\n        t.expressionStatement(init),\n      ]);\n    }\n  }\n\n  function getWeakSetId<Ref extends t.Node>(\n    weakSets: WeakMap<Ref, t.Identifier>,\n    outerClass: NodePath<t.Class>,\n    reference: NodePath<Ref>,\n    name = \"\",\n    inject: (\n      reference: NodePath<Ref>,\n      expression: t.Expression,\n      before?: boolean,\n    ) => void,\n  ) {\n    let id = weakSets.get(reference.node);\n\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      weakSets.set(reference.node, id);\n\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      annotateAsPure(newExpr);\n\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n\n    return t.cloneNode(id);\n  }\n\n  return {\n    name: \"transform-private-property-in-object\",\n    inherits: syntaxPlugin.default,\n    pre() {\n      // Enable this in @babel/helper-create-class-features-plugin, so that it\n      // can be handled by the private fields and methods transform.\n      enableFeature(this.file, FEATURES.privateIn, loose);\n    },\n    visitor: {\n      BinaryExpression(path, state) {\n        const { node } = path;\n        const { file } = state;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n\n        const { name } = node.left.id;\n\n        let privateElement: NodePath<\n          t.ClassPrivateMethod | t.ClassPrivateProperty\n        >;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n\n          privateElement = path.get(\"body.body\").find(\n            ({ node }) =>\n              // fixme: Support class accessor property\n              t.isPrivate(node) && node.key.id.name === name,\n          ) as NodePath<t.ClassPrivateMethod | t.ClassPrivateProperty>;\n\n          return !!privateElement;\n        }) as NodePath<t.Class>;\n\n        if (outerClass.parentPath.scope.path.isPattern()) {\n          outerClass.replaceWith(\n            template.ast`(() => ${outerClass.node})()` as t.Statement,\n          );\n          // The injected class will be queued and eventually transformed when visited\n          return;\n        }\n\n        if (privateElement.node.type === \"ClassPrivateMethod\") {\n          if (privateElement.node.static) {\n            if (outerClass.node.id) {\n              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);\n            } else {\n              outerClass.set(\"id\", path.scope.generateUidIdentifier(\"class\"));\n            }\n            path.replaceWith(\n              template.expression.ast`\n                ${t.cloneNode(outerClass.node.id)} === ${buildCheckInRHS(\n                  node.right,\n                  file,\n                )}\n              `,\n            );\n          } else {\n            const id = getWeakSetId(\n              classWeakSets,\n              outerClass,\n              outerClass,\n              outerClass.node.id?.name,\n              injectInitialization,\n            );\n\n            path.replaceWith(\n              template.expression.ast`${id}.has(${buildCheckInRHS(\n                node.right,\n                file,\n              )})`,\n            );\n          }\n        } else {\n          // Private fields might not all be initialized: see the 'halfConstructed'\n          // example at https://v8.dev/features/private-brand-checks.\n\n          const id = getWeakSetId<t.ClassPrivateProperty>(\n            fieldsWeakSets,\n            outerClass,\n            privateElement as NodePath<t.ClassPrivateProperty>,\n            privateElement.node.key.id.name,\n            injectToFieldInit,\n          );\n\n          path.replaceWith(\n            template.expression.ast`${id}.has(${buildCheckInRHS(\n              node.right,\n              file,\n            )})`,\n          );\n        }\n      },\n    },\n  };\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}