{"ast":null,"code":"function getLocator(source, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var offsetLine = options.offsetLine || 0;\n  var offsetColumn = options.offsetColumn || 0;\n  var originalLines = source.split('\\n');\n  var start = 0;\n  var lineRanges = originalLines.map(function (line, i) {\n    var end = start + line.length + 1;\n    var range = {\n      start: start,\n      end: end,\n      line: i\n    };\n    start = end;\n    return range;\n  });\n  var i = 0;\n  function rangeContains(range, index) {\n    return range.start <= index && index < range.end;\n  }\n  function getLocation(range, index) {\n    return {\n      line: offsetLine + range.line,\n      column: offsetColumn + index - range.start,\n      character: index\n    };\n  }\n  function locate(search, startIndex) {\n    if (typeof search === 'string') {\n      search = source.indexOf(search, startIndex || 0);\n    }\n    var range = lineRanges[i];\n    var d = search >= range.end ? 1 : -1;\n    while (range) {\n      if (rangeContains(range, search)) return getLocation(range, search);\n      i += d;\n      range = lineRanges[i];\n    }\n  }\n  return locate;\n}\nfunction locate(source, search, options) {\n  if (typeof options === 'number') {\n    throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n  }\n  return getLocator(source, options)(search, options && options.startIndex);\n}\nvar validNameCharacters = /[a-zA-Z0-9:_-]/;\nvar whitespace = /[\\s\\t\\r\\n]/;\nvar quotemark = /['\"]/;\nfunction repeat(str, i) {\n  var result = '';\n  while (i--) {\n    result += str;\n  }\n  return result;\n}\nfunction parse(source) {\n  var header = '';\n  var stack = [];\n  var state = metadata;\n  var currentElement = null;\n  var root = null;\n  function error(message) {\n    var ref = locate(source, i);\n    var line = ref.line;\n    var column = ref.column;\n    var before = source.slice(0, i);\n    var beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n    var after = source.slice(i);\n    var afterLine = /.*(\\n|$)/.exec(after)[0];\n    var snippet = \"\" + beforeLine + afterLine + \"\\n\" + repeat(' ', beforeLine.length) + \"^\";\n    throw new Error(message + \" (\" + line + \":\" + column + \"). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n\" + snippet);\n  }\n  function metadata() {\n    while (i < source.length && source[i] !== '<' || !validNameCharacters.test(source[i + 1])) {\n      header += source[i++];\n    }\n    return neutral();\n  }\n  function neutral() {\n    var text = '';\n    while (i < source.length && source[i] !== '<') {\n      text += source[i++];\n    }\n    if (/\\S/.test(text)) {\n      currentElement.children.push({\n        type: 'text',\n        value: text\n      });\n    }\n    if (source[i] === '<') {\n      return tag;\n    }\n    return neutral;\n  }\n  function tag() {\n    var char = source[i];\n    if (char === '?') {\n      return neutral;\n    } // <?xml...\n\n    if (char === '!') {\n      if (source.slice(i + 1, i + 3) === '--') {\n        return comment;\n      }\n      if (source.slice(i + 1, i + 8) === '[CDATA[') {\n        return cdata;\n      }\n      if (/doctype/i.test(source.slice(i + 1, i + 8))) {\n        return neutral;\n      }\n    }\n    if (char === '/') {\n      return closingTag;\n    }\n    var tagName = getName();\n    var element = {\n      type: 'element',\n      tagName: tagName,\n      properties: {},\n      children: []\n    };\n    if (currentElement) {\n      currentElement.children.push(element);\n    } else {\n      root = element;\n    }\n    var attribute;\n    while (i < source.length && (attribute = getAttribute())) {\n      element.properties[attribute.name] = attribute.value;\n    }\n    var selfClosing = false;\n    if (source[i] === '/') {\n      i += 1;\n      selfClosing = true;\n    }\n    if (source[i] !== '>') {\n      error('Expected >');\n    }\n    if (!selfClosing) {\n      currentElement = element;\n      stack.push(element);\n    }\n    return neutral;\n  }\n  function comment() {\n    var index = source.indexOf('-->', i);\n    if (!~index) {\n      error('expected -->');\n    }\n    i = index + 2;\n    return neutral;\n  }\n  function cdata() {\n    var index = source.indexOf(']]>', i);\n    if (!~index) {\n      error('expected ]]>');\n    }\n    currentElement.children.push(source.slice(i + 7, index));\n    i = index + 2;\n    return neutral;\n  }\n  function closingTag() {\n    var tagName = getName();\n    if (!tagName) {\n      error('Expected tag name');\n    }\n    if (tagName !== currentElement.tagName) {\n      error(\"Expected closing tag </\" + tagName + \"> to match opening tag <\" + currentElement.tagName + \">\");\n    }\n    allowSpaces();\n    if (source[i] !== '>') {\n      error('Expected >');\n    }\n    stack.pop();\n    currentElement = stack[stack.length - 1];\n    return neutral;\n  }\n  function getName() {\n    var name = '';\n    while (i < source.length && validNameCharacters.test(source[i])) {\n      name += source[i++];\n    }\n    return name;\n  }\n  function getAttribute() {\n    if (!whitespace.test(source[i])) {\n      return null;\n    }\n    allowSpaces();\n    var name = getName();\n    if (!name) {\n      return null;\n    }\n    var value = true;\n    allowSpaces();\n    if (source[i] === '=') {\n      i += 1;\n      allowSpaces();\n      value = getAttributeValue();\n      if (!isNaN(value) && value.trim() !== '') {\n        value = +value;\n      } // TODO whitelist numeric attributes?\n    }\n\n    return {\n      name: name,\n      value: value\n    };\n  }\n  function getAttributeValue() {\n    return quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n  }\n  function getUnquotedAttributeValue() {\n    var value = '';\n    do {\n      var char = source[i];\n      if (char === ' ' || char === '>' || char === '/') {\n        return value;\n      }\n      value += char;\n      i += 1;\n    } while (i < source.length);\n    return value;\n  }\n  function getQuotedAttributeValue() {\n    var quotemark = source[i++];\n    var value = '';\n    var escaped = false;\n    while (i < source.length) {\n      var char = source[i++];\n      if (char === quotemark && !escaped) {\n        return value;\n      }\n      if (char === '\\\\' && !escaped) {\n        escaped = true;\n      }\n      value += escaped ? \"\\\\\" + char : char;\n      escaped = false;\n    }\n  }\n  function allowSpaces() {\n    while (i < source.length && whitespace.test(source[i])) {\n      i += 1;\n    }\n  }\n  var i = metadata.length;\n  while (i < source.length) {\n    if (!state) {\n      error('Unexpected character');\n    }\n    state = state();\n    i += 1;\n  }\n  if (state !== neutral) {\n    error('Unexpected end of input');\n  }\n  if (root.tagName === 'svg') {\n    root.metadata = header;\n  }\n  return {\n    type: 'root',\n    children: [root]\n  };\n}\nexport { parse };","map":{"version":3,"names":["getLocator","source","options","offsetLine","offsetColumn","originalLines","split","start","lineRanges","map","line","i","end","length","range","rangeContains","index","getLocation","column","character","locate","search","startIndex","indexOf","d","Error","validNameCharacters","whitespace","quotemark","repeat","str","result","parse","header","stack","state","metadata","currentElement","root","error","message","ref","before","slice","beforeLine","exec","replace","after","afterLine","snippet","test","neutral","text","children","push","type","value","tag","char","comment","cdata","closingTag","tagName","getName","element","properties","attribute","getAttribute","name","selfClosing","allowSpaces","pop","getAttributeValue","isNaN","trim","getQuotedAttributeValue","getUnquotedAttributeValue","escaped"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\svg-parser\\node_modules\\locate-character\\dist\\locate-character.es.js","C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\svg-parser\\src\\index.js"],"sourcesContent":["function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };","import { locate } from 'locate-character';\n\nconst validNameCharacters = /[a-zA-Z0-9:_-]/;\nconst whitespace = /[\\s\\t\\r\\n]/;\nconst quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n\tlet result = '';\n\twhile (i--) result += str;\n\treturn result;\n}\n\nexport function parse(source) {\n\tlet header = '';\n\tlet stack = [];\n\n\tlet state = metadata;\n\tlet currentElement = null;\n\tlet root = null;\n\n\tfunction error(message) {\n\t\tconst { line, column } = locate(source, i);\n\t\tconst before = source.slice(0, i);\n\t\tconst beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n\t\tconst after = source.slice(i);\n\t\tconst afterLine = /.*(\\n|$)/.exec(after)[0];\n\n\t\tconst snippet = `${beforeLine}${afterLine}\\n${repeat(' ', beforeLine.length)}^`;\n\n\t\tthrow new Error(\n\t\t\t`${message} (${line}:${column}). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n${snippet}`\n\t\t);\n\t}\n\n\tfunction metadata() {\n\t\twhile ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n\t\t\theader += source[i++];\n\t\t}\n\n\t\treturn neutral();\n\t}\n\n\tfunction neutral() {\n\t\tlet text = '';\n\t\twhile (i < source.length && source[i] !== '<') text += source[i++];\n\n\t\tif (/\\S/.test(text)) {\n\t\t\tcurrentElement.children.push({ type: 'text', value: text });\n\t\t}\n\n\t\tif (source[i] === '<') {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag() {\n\t\tconst char = source[i];\n\n\t\tif (char === '?') return neutral; // <?xml...\n\n\t\tif (char === '!') {\n\t\t\tif (source.slice(i + 1, i + 3) === '--') return comment;\n\t\t\tif (source.slice(i + 1, i + 8) === '[CDATA[') return cdata;\n\t\t\tif (/doctype/i.test(source.slice(i + 1, i + 8))) return neutral;\n\t\t}\n\n\t\tif (char === '/') return closingTag;\n\n\t\tconst tagName = getName();\n\n\t\tconst element = {\n\t\t\ttype: 'element',\n\t\t\ttagName,\n\t\t\tproperties: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (currentElement) {\n\t\t\tcurrentElement.children.push(element);\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tlet attribute;\n\t\twhile (i < source.length && (attribute = getAttribute())) {\n\t\t\telement.properties[attribute.name] = attribute.value;\n\t\t}\n\n\t\tlet selfClosing = false;\n\n\t\tif (source[i] === '/') {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tif (!selfClosing) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push(element);\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment() {\n\t\tconst index = source.indexOf('-->', i);\n\t\tif (!~index) error('expected -->');\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction cdata() {\n\t\tconst index = source.indexOf(']]>', i);\n\t\tif (!~index) error('expected ]]>');\n\n\t\tcurrentElement.children.push(source.slice(i + 7, index));\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag() {\n\t\tconst tagName = getName();\n\n\t\tif (!tagName) error('Expected tag name');\n\n\t\tif (tagName !== currentElement.tagName) {\n\t\t\terror(`Expected closing tag </${tagName}> to match opening tag <${currentElement.tagName}>`);\n\t\t}\n\n\t\tallowSpaces();\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[stack.length - 1];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName() {\n\t\tlet name = '';\n\t\twhile (i < source.length && validNameCharacters.test(source[i])) name += source[i++];\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute() {\n\t\tif (!whitespace.test(source[i])) return null;\n\t\tallowSpaces();\n\n\t\tconst name = getName();\n\t\tif (!name) return null;\n\n\t\tlet value = true;\n\n\t\tallowSpaces();\n\t\tif (source[i] === '=') {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif (!isNaN(value) && value.trim() !== '') value = +value; // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name, value };\n\t}\n\n\tfunction getAttributeValue() {\n\t\treturn quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue() {\n\t\tlet value = '';\n\t\tdo {\n\t\t\tconst char = source[i];\n\t\t\tif (char === ' ' || char === '>' || char === '/') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while (i < source.length);\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue() {\n\t\tconst quotemark = source[i++];\n\n\t\tlet value = '';\n\t\tlet escaped = false;\n\n\t\twhile (i < source.length) {\n\t\t\tconst char = source[i++];\n\t\t\tif (char === quotemark && !escaped) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (char === '\\\\' && !escaped) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? `\\\\${char}` : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces() {\n\t\twhile (i < source.length && whitespace.test(source[i])) i += 1;\n\t}\n\n\tlet i = metadata.length;\n\twhile (i < source.length) {\n\t\tif (!state) error('Unexpected character');\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif (state !== neutral) {\n\t\terror('Unexpected end of input');\n\t}\n\n\tif (root.tagName === 'svg') root.metadata = header;\n\treturn {\n\t\ttype: 'root',\n\t\tchildren: [root]\n\t};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}