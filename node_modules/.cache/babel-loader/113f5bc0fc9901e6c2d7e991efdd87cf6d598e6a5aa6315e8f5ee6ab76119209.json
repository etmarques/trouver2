{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canSkipRegexpu = canSkipRegexpu;\nexports.generateRegexpuOptions = generateRegexpuOptions;\nexports.transformFlags = transformFlags;\nvar _features = require(\"./features\");\nfunction generateRegexpuOptions(pattern, toTransform) {\n  const feat = function (name) {\n    let ok = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"transform\";\n    return (0, _features.hasFeature)(toTransform, _features.FEATURES[name]) ? ok : false;\n  };\n  const featDuplicateNamedGroups = () => {\n    if (!feat(\"duplicateNamedCaptureGroups\")) return false;\n    const regex = /\\(\\?<([^>]+)>/g;\n    const seen = new Set();\n    for (let match; match = regex.exec(pattern); seen.add(match[1])) {\n      if (seen.has(match[1])) return \"transform\";\n    }\n    return false;\n  };\n  return {\n    unicodeFlag: feat(\"unicodeFlag\"),\n    unicodeSetsFlag: feat(\"unicodeSetsFlag\") || \"parse\",\n    dotAllFlag: feat(\"dotAllFlag\"),\n    unicodePropertyEscapes: feat(\"unicodePropertyEscape\"),\n    namedGroups: feat(\"namedCaptureGroups\") || featDuplicateNamedGroups(),\n    onNamedGroup: () => {},\n    modifiers: feat(\"modifiers\")\n  };\n}\nfunction canSkipRegexpu(node, options) {\n  const {\n    flags,\n    pattern\n  } = node;\n  if (flags.includes(\"v\")) {\n    if (options.unicodeSetsFlag === \"transform\") return false;\n  }\n  if (flags.includes(\"u\")) {\n    if (options.unicodeFlag === \"transform\") return false;\n    if (options.unicodePropertyEscapes === \"transform\" && /\\\\[pP]{/.test(pattern)) {\n      return false;\n    }\n  }\n  if (flags.includes(\"s\")) {\n    if (options.dotAllFlag === \"transform\") return false;\n  }\n  if (options.namedGroups === \"transform\" && /\\(\\?<(?![=!])/.test(pattern)) {\n    return false;\n  }\n  if (options.modifiers === \"transform\" && /\\(\\?[\\w-]+:/.test(pattern)) {\n    return false;\n  }\n  return true;\n}\nfunction transformFlags(regexpuOptions, flags) {\n  if (regexpuOptions.unicodeSetsFlag === \"transform\") {\n    flags = flags.replace(\"v\", \"u\");\n  }\n  if (regexpuOptions.unicodeFlag === \"transform\") {\n    flags = flags.replace(\"u\", \"\");\n  }\n  if (regexpuOptions.dotAllFlag === \"transform\") {\n    flags = flags.replace(\"s\", \"\");\n  }\n  return flags;\n}","map":{"version":3,"names":["_features","require","generateRegexpuOptions","pattern","toTransform","feat","name","ok","arguments","length","undefined","hasFeature","FEATURES","featDuplicateNamedGroups","regex","seen","Set","match","exec","add","has","unicodeFlag","unicodeSetsFlag","dotAllFlag","unicodePropertyEscapes","namedGroups","onNamedGroup","modifiers","canSkipRegexpu","node","options","flags","includes","test","transformFlags","regexpuOptions","replace"],"sources":["C:\\Users\\AGU\\Documents\\trouver2\\node_modules\\@babel\\helper-create-regexp-features-plugin\\src\\util.ts"],"sourcesContent":["import type { types as t } from \"@babel/core\";\nimport { FEATURES, hasFeature } from \"./features\";\n\nimport type { RegexpuOptions } from \"regexpu-core\";\n\nexport function generateRegexpuOptions(\n  pattern: string,\n  toTransform: number,\n): RegexpuOptions {\n  type Experimental = 1;\n\n  const feat = <Stability extends 0 | 1 = 0>(\n    name: keyof typeof FEATURES,\n    ok: \"transform\" | (Stability extends 0 ? never : \"parse\") = \"transform\",\n  ) => {\n    return hasFeature(toTransform, FEATURES[name]) ? ok : false;\n  };\n\n  const featDuplicateNamedGroups = (): \"transform\" | false => {\n    if (!feat(\"duplicateNamedCaptureGroups\")) return false;\n\n    // This can return false positive, for example for /\\(?<a>\\)/.\n    // However, it's such a rare occurrence that it's ok to compile\n    // the regexp even if we only need to compile regexps with\n    // duplicate named capturing groups.\n    const regex = /\\(\\?<([^>]+)>/g;\n    const seen = new Set();\n    for (let match; (match = regex.exec(pattern)); seen.add(match[1])) {\n      if (seen.has(match[1])) return \"transform\";\n    }\n    return false;\n  };\n\n  return {\n    unicodeFlag: feat(\"unicodeFlag\"),\n    unicodeSetsFlag: feat<Experimental>(\"unicodeSetsFlag\") || \"parse\",\n    dotAllFlag: feat(\"dotAllFlag\"),\n    unicodePropertyEscapes: feat(\"unicodePropertyEscape\"),\n    namedGroups: feat(\"namedCaptureGroups\") || featDuplicateNamedGroups(),\n    onNamedGroup: () => {},\n    modifiers: feat(\"modifiers\"),\n  };\n}\n\nexport function canSkipRegexpu(\n  node: t.RegExpLiteral,\n  options: RegexpuOptions,\n): boolean {\n  const { flags, pattern } = node;\n\n  if (flags.includes(\"v\")) {\n    if (options.unicodeSetsFlag === \"transform\") return false;\n  }\n\n  if (flags.includes(\"u\")) {\n    if (options.unicodeFlag === \"transform\") return false;\n    if (\n      options.unicodePropertyEscapes === \"transform\" &&\n      /\\\\[pP]{/.test(pattern)\n    ) {\n      return false;\n    }\n  }\n\n  if (flags.includes(\"s\")) {\n    if (options.dotAllFlag === \"transform\") return false;\n  }\n\n  if (options.namedGroups === \"transform\" && /\\(\\?<(?![=!])/.test(pattern)) {\n    return false;\n  }\n\n  if (options.modifiers === \"transform\" && /\\(\\?[\\w-]+:/.test(pattern)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function transformFlags(regexpuOptions: RegexpuOptions, flags: string) {\n  if (regexpuOptions.unicodeSetsFlag === \"transform\") {\n    flags = flags.replace(\"v\", \"u\");\n  }\n  if (regexpuOptions.unicodeFlag === \"transform\") {\n    flags = flags.replace(\"u\", \"\");\n  }\n  if (regexpuOptions.dotAllFlag === \"transform\") {\n    flags = flags.replace(\"s\", \"\");\n  }\n  return flags;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}