{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastChild} XastChild\n */\nconst {\n  visitSkip,\n  detachNodeFromParent\n} = require('../lib/xast.js');\nexports.name = 'mergeStyles';\nexports.description = 'merge multiple style elements into one';\n\n/**\n * Merge multiple style elements into one.\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('./plugins-types').Plugin<'mergeStyles'>}\n */\nexports.fn = () => {\n  /**\n   * @type {null | XastElement}\n   */\n  let firstStyleElement = null;\n  let collectedStyles = '';\n  /**\n   * @type {'text' | 'cdata'}\n   */\n  let styleContentType = 'text';\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n\n        // collect style elements\n        if (node.name !== 'style') {\n          return;\n        }\n\n        // skip <style> with invalid type attribute\n        if (node.attributes.type != null && node.attributes.type !== '' && node.attributes.type !== 'text/css') {\n          return;\n        }\n\n        // extract style element content\n        let css = '';\n        for (const child of node.children) {\n          if (child.type === 'text') {\n            css += child.value;\n          }\n          if (child.type === 'cdata') {\n            styleContentType = 'cdata';\n            css += child.value;\n          }\n        }\n\n        // remove empty style elements\n        if (css.trim().length === 0) {\n          detachNodeFromParent(node, parentNode);\n          return;\n        }\n\n        // collect css and wrap with media query if present in attribute\n        if (node.attributes.media == null) {\n          collectedStyles += css;\n        } else {\n          collectedStyles += `@media ${node.attributes.media}{${css}}`;\n          delete node.attributes.media;\n        }\n\n        // combine collected styles in the first style element\n        if (firstStyleElement == null) {\n          firstStyleElement = node;\n        } else {\n          detachNodeFromParent(node, parentNode);\n          /**\n           * @type {XastChild}\n           */\n          const child = {\n            type: styleContentType,\n            value: collectedStyles\n          };\n          // TODO remove legacy parentNode in v4\n          Object.defineProperty(child, 'parentNode', {\n            writable: true,\n            value: firstStyleElement\n          });\n          firstStyleElement.children = [child];\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["visitSkip","detachNodeFromParent","require","exports","name","description","fn","firstStyleElement","collectedStyles","styleContentType","element","enter","node","parentNode","attributes","type","css","child","children","value","trim","length","media","Object","defineProperty","writable"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/mergeStyles.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastChild} XastChild\n */\n\nconst { visitSkip, detachNodeFromParent } = require('../lib/xast.js');\n\nexports.name = 'mergeStyles';\nexports.description = 'merge multiple style elements into one';\n\n/**\n * Merge multiple style elements into one.\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('./plugins-types').Plugin<'mergeStyles'>}\n */\nexports.fn = () => {\n  /**\n   * @type {null | XastElement}\n   */\n  let firstStyleElement = null;\n  let collectedStyles = '';\n  /**\n   * @type {'text' | 'cdata'}\n   */\n  let styleContentType = 'text';\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n\n        // collect style elements\n        if (node.name !== 'style') {\n          return;\n        }\n\n        // skip <style> with invalid type attribute\n        if (\n          node.attributes.type != null &&\n          node.attributes.type !== '' &&\n          node.attributes.type !== 'text/css'\n        ) {\n          return;\n        }\n\n        // extract style element content\n        let css = '';\n        for (const child of node.children) {\n          if (child.type === 'text') {\n            css += child.value;\n          }\n          if (child.type === 'cdata') {\n            styleContentType = 'cdata';\n            css += child.value;\n          }\n        }\n\n        // remove empty style elements\n        if (css.trim().length === 0) {\n          detachNodeFromParent(node, parentNode);\n          return;\n        }\n\n        // collect css and wrap with media query if present in attribute\n        if (node.attributes.media == null) {\n          collectedStyles += css;\n        } else {\n          collectedStyles += `@media ${node.attributes.media}{${css}}`;\n          delete node.attributes.media;\n        }\n\n        // combine collected styles in the first style element\n        if (firstStyleElement == null) {\n          firstStyleElement = node;\n        } else {\n          detachNodeFromParent(node, parentNode);\n          /**\n           * @type {XastChild}\n           */\n          const child = { type: styleContentType, value: collectedStyles };\n          // TODO remove legacy parentNode in v4\n          Object.defineProperty(child, 'parentNode', {\n            writable: true,\n            value: firstStyleElement,\n          });\n          firstStyleElement.children = [child];\n        }\n      },\n    },\n  };\n};\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AAEA,MAAM;EAAEA,SAAS;EAAEC;AAAqB,CAAC,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAErEC,OAAO,CAACC,IAAI,GAAG,aAAa;AAC5BD,OAAO,CAACE,WAAW,GAAG,wCAAwC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,OAAO,CAACG,EAAE,GAAG,MAAM;EACjB;AACF;AACA;EACE,IAAIC,iBAAiB,GAAG,IAAI;EAC5B,IAAIC,eAAe,GAAG,EAAE;EACxB;AACF;AACA;EACE,IAAIC,gBAAgB,GAAG,MAAM;EAE7B,OAAO;IACLC,OAAO,EAAE;MACPC,KAAK,EAAEA,CAACC,IAAI,EAAEC,UAAU,KAAK;QAC3B;QACA,IAAID,IAAI,CAACR,IAAI,KAAK,eAAe,EAAE;UACjC,OAAOJ,SAAS;QAClB;;QAEA;QACA,IAAIY,IAAI,CAACR,IAAI,KAAK,OAAO,EAAE;UACzB;QACF;;QAEA;QACA,IACEQ,IAAI,CAACE,UAAU,CAACC,IAAI,IAAI,IAAI,IAC5BH,IAAI,CAACE,UAAU,CAACC,IAAI,KAAK,EAAE,IAC3BH,IAAI,CAACE,UAAU,CAACC,IAAI,KAAK,UAAU,EACnC;UACA;QACF;;QAEA;QACA,IAAIC,GAAG,GAAG,EAAE;QACZ,KAAK,MAAMC,KAAK,IAAIL,IAAI,CAACM,QAAQ,EAAE;UACjC,IAAID,KAAK,CAACF,IAAI,KAAK,MAAM,EAAE;YACzBC,GAAG,IAAIC,KAAK,CAACE,KAAK;UACpB;UACA,IAAIF,KAAK,CAACF,IAAI,KAAK,OAAO,EAAE;YAC1BN,gBAAgB,GAAG,OAAO;YAC1BO,GAAG,IAAIC,KAAK,CAACE,KAAK;UACpB;QACF;;QAEA;QACA,IAAIH,GAAG,CAACI,IAAI,CAAC,CAAC,CAACC,MAAM,KAAK,CAAC,EAAE;UAC3BpB,oBAAoB,CAACW,IAAI,EAAEC,UAAU,CAAC;UACtC;QACF;;QAEA;QACA,IAAID,IAAI,CAACE,UAAU,CAACQ,KAAK,IAAI,IAAI,EAAE;UACjCd,eAAe,IAAIQ,GAAG;QACxB,CAAC,MAAM;UACLR,eAAe,IAAK,UAASI,IAAI,CAACE,UAAU,CAACQ,KAAM,IAAGN,GAAI,GAAE;UAC5D,OAAOJ,IAAI,CAACE,UAAU,CAACQ,KAAK;QAC9B;;QAEA;QACA,IAAIf,iBAAiB,IAAI,IAAI,EAAE;UAC7BA,iBAAiB,GAAGK,IAAI;QAC1B,CAAC,MAAM;UACLX,oBAAoB,CAACW,IAAI,EAAEC,UAAU,CAAC;UACtC;AACV;AACA;UACU,MAAMI,KAAK,GAAG;YAAEF,IAAI,EAAEN,gBAAgB;YAAEU,KAAK,EAAEX;UAAgB,CAAC;UAChE;UACAe,MAAM,CAACC,cAAc,CAACP,KAAK,EAAE,YAAY,EAAE;YACzCQ,QAAQ,EAAE,IAAI;YACdN,KAAK,EAAEZ;UACT,CAAC,CAAC;UACFA,iBAAiB,CAACW,QAAQ,GAAG,CAACD,KAAK,CAAC;QACtC;MACF;IACF;EACF,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}