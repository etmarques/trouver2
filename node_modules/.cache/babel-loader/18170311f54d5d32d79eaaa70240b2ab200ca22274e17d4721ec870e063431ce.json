{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\nconst {\n  visitSkip,\n  detachNodeFromParent\n} = require('../lib/xast.js');\nconst {\n  parsePathData\n} = require('../lib/path.js');\nconst {\n  intersects\n} = require('./_path.js');\nexports.name = 'removeOffCanvasPaths';\nexports.description = 'removes elements that are drawn outside of the viewbox (disabled by default)';\n\n/**\n * Remove elements that are drawn outside of the viewbox.\n *\n * @author JoshyPHP\n *\n * @type {import('./plugins-types').Plugin<'removeOffCanvasPaths'>}\n */\nexports.fn = () => {\n  /**\n   * @type {null | {\n   *   top: number,\n   *   right: number,\n   *   bottom: number,\n   *   left: number,\n   *   width: number,\n   *   height: number\n   * }}\n   */\n  let viewBoxData = null;\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          let viewBox = '';\n          // find viewbox\n          if (node.attributes.viewBox != null) {\n            // remove commas and plus signs, normalize and trim whitespace\n            viewBox = node.attributes.viewBox;\n          } else if (node.attributes.height != null && node.attributes.width != null) {\n            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;\n          }\n\n          // parse viewbox\n          // remove commas and plus signs, normalize and trim whitespace\n          viewBox = viewBox.replace(/[,+]|px/g, ' ').replace(/\\s+/g, ' ').replace(/^\\s*|\\s*$/g, '');\n          // ensure that the dimensions are 4 values separated by space\n          const m = /^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(viewBox);\n          if (m == null) {\n            return;\n          }\n          const left = Number.parseFloat(m[1]);\n          const top = Number.parseFloat(m[2]);\n          const width = Number.parseFloat(m[3]);\n          const height = Number.parseFloat(m[4]);\n\n          // store the viewBox boundaries\n          viewBoxData = {\n            left,\n            top,\n            right: left + width,\n            bottom: top + height,\n            width,\n            height\n          };\n        }\n\n        // consider that any item with a transform attribute is visible\n        if (node.attributes.transform != null) {\n          return visitSkip;\n        }\n        if (node.name === 'path' && node.attributes.d != null && viewBoxData != null) {\n          const pathData = parsePathData(node.attributes.d);\n\n          // consider that a M command within the viewBox is visible\n          let visible = false;\n          for (const pathDataItem of pathData) {\n            if (pathDataItem.command === 'M') {\n              const [x, y] = pathDataItem.args;\n              if (x >= viewBoxData.left && x <= viewBoxData.right && y >= viewBoxData.top && y <= viewBoxData.bottom) {\n                visible = true;\n              }\n            }\n          }\n          if (visible) {\n            return;\n          }\n          if (pathData.length === 2) {\n            // close the path too short for intersects()\n            pathData.push({\n              command: 'z',\n              args: []\n            });\n          }\n          const {\n            left,\n            top,\n            width,\n            height\n          } = viewBoxData;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const viewBoxPathData = [{\n            command: 'M',\n            args: [left, top]\n          }, {\n            command: 'h',\n            args: [width]\n          }, {\n            command: 'v',\n            args: [height]\n          }, {\n            command: 'H',\n            args: [left]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          if (intersects(viewBoxPathData, pathData) === false) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["visitSkip","detachNodeFromParent","require","parsePathData","intersects","exports","name","description","fn","viewBoxData","element","enter","node","parentNode","type","viewBox","attributes","height","width","replace","m","exec","left","Number","parseFloat","top","right","bottom","transform","d","pathData","visible","pathDataItem","command","x","y","args","length","push","viewBoxPathData"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/removeOffCanvasPaths.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { visitSkip, detachNodeFromParent } = require('../lib/xast.js');\nconst { parsePathData } = require('../lib/path.js');\nconst { intersects } = require('./_path.js');\n\nexports.name = 'removeOffCanvasPaths';\nexports.description =\n  'removes elements that are drawn outside of the viewbox (disabled by default)';\n\n/**\n * Remove elements that are drawn outside of the viewbox.\n *\n * @author JoshyPHP\n *\n * @type {import('./plugins-types').Plugin<'removeOffCanvasPaths'>}\n */\nexports.fn = () => {\n  /**\n   * @type {null | {\n   *   top: number,\n   *   right: number,\n   *   bottom: number,\n   *   left: number,\n   *   width: number,\n   *   height: number\n   * }}\n   */\n  let viewBoxData = null;\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          let viewBox = '';\n          // find viewbox\n          if (node.attributes.viewBox != null) {\n            // remove commas and plus signs, normalize and trim whitespace\n            viewBox = node.attributes.viewBox;\n          } else if (\n            node.attributes.height != null &&\n            node.attributes.width != null\n          ) {\n            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;\n          }\n\n          // parse viewbox\n          // remove commas and plus signs, normalize and trim whitespace\n          viewBox = viewBox\n            .replace(/[,+]|px/g, ' ')\n            .replace(/\\s+/g, ' ')\n            .replace(/^\\s*|\\s*$/g, '');\n          // ensure that the dimensions are 4 values separated by space\n          const m =\n            /^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(\n              viewBox\n            );\n          if (m == null) {\n            return;\n          }\n          const left = Number.parseFloat(m[1]);\n          const top = Number.parseFloat(m[2]);\n          const width = Number.parseFloat(m[3]);\n          const height = Number.parseFloat(m[4]);\n\n          // store the viewBox boundaries\n          viewBoxData = {\n            left,\n            top,\n            right: left + width,\n            bottom: top + height,\n            width,\n            height,\n          };\n        }\n\n        // consider that any item with a transform attribute is visible\n        if (node.attributes.transform != null) {\n          return visitSkip;\n        }\n\n        if (\n          node.name === 'path' &&\n          node.attributes.d != null &&\n          viewBoxData != null\n        ) {\n          const pathData = parsePathData(node.attributes.d);\n\n          // consider that a M command within the viewBox is visible\n          let visible = false;\n          for (const pathDataItem of pathData) {\n            if (pathDataItem.command === 'M') {\n              const [x, y] = pathDataItem.args;\n              if (\n                x >= viewBoxData.left &&\n                x <= viewBoxData.right &&\n                y >= viewBoxData.top &&\n                y <= viewBoxData.bottom\n              ) {\n                visible = true;\n              }\n            }\n          }\n          if (visible) {\n            return;\n          }\n\n          if (pathData.length === 2) {\n            // close the path too short for intersects()\n            pathData.push({ command: 'z', args: [] });\n          }\n\n          const { left, top, width, height } = viewBoxData;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const viewBoxPathData = [\n            { command: 'M', args: [left, top] },\n            { command: 'h', args: [width] },\n            { command: 'v', args: [height] },\n            { command: 'H', args: [left] },\n            { command: 'z', args: [] },\n          ];\n\n          if (intersects(viewBoxPathData, pathData) === false) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}