{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('./types').PathDataItem} PathDataItem\n * @typedef {import('./types').PathDataCommand} PathDataCommand\n */\n\n// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF\nconst argsCountPerCommand = {\n  M: 2,\n  m: 2,\n  Z: 0,\n  z: 0,\n  L: 2,\n  l: 2,\n  H: 1,\n  h: 1,\n  V: 1,\n  v: 1,\n  C: 6,\n  c: 6,\n  S: 4,\n  s: 4,\n  Q: 4,\n  q: 4,\n  T: 2,\n  t: 2,\n  A: 7,\n  a: 7\n};\n\n/**\n * @type {(c: string) => c is PathDataCommand}\n */\nconst isCommand = c => {\n  return c in argsCountPerCommand;\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isWsp = c => {\n  const codePoint = c.codePointAt(0);\n  return codePoint === 0x20 || codePoint === 0x9 || codePoint === 0xd || codePoint === 0xa;\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isDigit = c => {\n  const codePoint = c.codePointAt(0);\n  if (codePoint == null) {\n    return false;\n  }\n  return 48 <= codePoint && codePoint <= 57;\n};\n\n/**\n * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState\n */\n\n/**\n * @type {(string: string, cursor: number) => [number, number | null]}\n */\nconst readNumber = (string, cursor) => {\n  let i = cursor;\n  let value = '';\n  let state = /** @type {ReadNumberState} */'none';\n  for (; i < string.length; i += 1) {\n    const c = string[i];\n    if (c === '+' || c === '-') {\n      if (state === 'none') {\n        state = 'sign';\n        value += c;\n        continue;\n      }\n      if (state === 'e') {\n        state = 'exponent_sign';\n        value += c;\n        continue;\n      }\n    }\n    if (isDigit(c)) {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'whole';\n        value += c;\n        continue;\n      }\n      if (state === 'decimal_point' || state === 'decimal') {\n        state = 'decimal';\n        value += c;\n        continue;\n      }\n      if (state === 'e' || state === 'exponent_sign' || state === 'exponent') {\n        state = 'exponent';\n        value += c;\n        continue;\n      }\n    }\n    if (c === '.') {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'decimal_point';\n        value += c;\n        continue;\n      }\n    }\n    if (c === 'E' || c == 'e') {\n      if (state === 'whole' || state === 'decimal_point' || state === 'decimal') {\n        state = 'e';\n        value += c;\n        continue;\n      }\n    }\n    break;\n  }\n  const number = Number.parseFloat(value);\n  if (Number.isNaN(number)) {\n    return [cursor, null];\n  } else {\n    // step back to delegate iteration to parent loop\n    return [i - 1, number];\n  }\n};\n\n/**\n * @type {(string: string) => Array<PathDataItem>}\n */\nconst parsePathData = string => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = [];\n  /**\n   * @type {null | PathDataCommand}\n   */\n  let command = null;\n  let args = /** @type {number[]} */[];\n  let argsCount = 0;\n  let canHaveComma = false;\n  let hadComma = false;\n  for (let i = 0; i < string.length; i += 1) {\n    const c = string.charAt(i);\n    if (isWsp(c)) {\n      continue;\n    }\n    // allow comma only between arguments\n    if (canHaveComma && c === ',') {\n      if (hadComma) {\n        break;\n      }\n      hadComma = true;\n      continue;\n    }\n    if (isCommand(c)) {\n      if (hadComma) {\n        return pathData;\n      }\n      if (command == null) {\n        // moveto should be leading command\n        if (c !== 'M' && c !== 'm') {\n          return pathData;\n        }\n      } else {\n        // stop if previous command arguments are not flushed\n        if (args.length !== 0) {\n          return pathData;\n        }\n      }\n      command = c;\n      args = [];\n      argsCount = argsCountPerCommand[command];\n      canHaveComma = false;\n      // flush command without arguments\n      if (argsCount === 0) {\n        pathData.push({\n          command,\n          args\n        });\n      }\n      continue;\n    }\n    // avoid parsing arguments if no command detected\n    if (command == null) {\n      return pathData;\n    }\n    // read next argument\n    let newCursor = i;\n    let number = null;\n    if (command === 'A' || command === 'a') {\n      const position = args.length;\n      if (position === 0 || position === 1) {\n        // allow only positive number without sign as first two arguments\n        if (c !== '+' && c !== '-') {\n          [newCursor, number] = readNumber(string, i);\n        }\n      }\n      if (position === 2 || position === 5 || position === 6) {\n        [newCursor, number] = readNumber(string, i);\n      }\n      if (position === 3 || position === 4) {\n        // read flags\n        if (c === '0') {\n          number = 0;\n        }\n        if (c === '1') {\n          number = 1;\n        }\n      }\n    } else {\n      [newCursor, number] = readNumber(string, i);\n    }\n    if (number == null) {\n      return pathData;\n    }\n    args.push(number);\n    canHaveComma = true;\n    hadComma = false;\n    i = newCursor;\n    // flush arguments when necessary count is reached\n    if (args.length === argsCount) {\n      pathData.push({\n        command,\n        args\n      });\n      // subsequent moveto coordinates are threated as implicit lineto commands\n      if (command === 'M') {\n        command = 'L';\n      }\n      if (command === 'm') {\n        command = 'l';\n      }\n      args = [];\n    }\n  }\n  return pathData;\n};\nexports.parsePathData = parsePathData;\n\n/**\n * @type {(number: number, precision?: number) => string}\n */\nconst stringifyNumber = (number, precision) => {\n  if (precision != null) {\n    const ratio = 10 ** precision;\n    number = Math.round(number * ratio) / ratio;\n  }\n  // remove zero whole from decimal number\n  return number.toString().replace(/^0\\./, '.').replace(/^-0\\./, '-.');\n};\n\n/**\n * Elliptical arc large-arc and sweep flags are rendered with spaces\n * because many non-browser environments are not able to parse such paths\n *\n * @type {(\n *   command: string,\n *   args: number[],\n *   precision?: number,\n *   disableSpaceAfterFlags?: boolean\n * ) => string}\n */\nconst stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {\n  let result = '';\n  let prev = '';\n  for (let i = 0; i < args.length; i += 1) {\n    const number = args[i];\n    const numberString = stringifyNumber(number, precision);\n    if (disableSpaceAfterFlags && (command === 'A' || command === 'a') && (\n    // consider combined arcs\n    i % 7 === 4 || i % 7 === 5)) {\n      result += numberString;\n    } else if (i === 0 || numberString.startsWith('-')) {\n      // avoid space before first and negative numbers\n      result += numberString;\n    } else if (prev.includes('.') && numberString.startsWith('.')) {\n      // remove space before decimal with zero whole\n      // only when previous number is also decimal\n      result += numberString;\n    } else {\n      result += ` ${numberString}`;\n    }\n    prev = numberString;\n  }\n  return result;\n};\n\n/**\n * @typedef {{\n *   pathData: Array<PathDataItem>;\n *   precision?: number;\n *   disableSpaceAfterFlags?: boolean;\n * }} StringifyPathDataOptions\n */\n\n/**\n * @type {(options: StringifyPathDataOptions) => string}\n */\nconst stringifyPathData = _ref => {\n  let {\n    pathData,\n    precision,\n    disableSpaceAfterFlags\n  } = _ref;\n  // combine sequence of the same commands\n  let combined = [];\n  for (let i = 0; i < pathData.length; i += 1) {\n    const {\n      command,\n      args\n    } = pathData[i];\n    if (i === 0) {\n      combined.push({\n        command,\n        args\n      });\n    } else {\n      /**\n       * @type {PathDataItem}\n       */\n      const last = combined[combined.length - 1];\n      // match leading moveto with following lineto\n      if (i === 1) {\n        if (command === 'L') {\n          last.command = 'M';\n        }\n        if (command === 'l') {\n          last.command = 'm';\n        }\n      }\n      if (last.command === command && last.command !== 'M' && last.command !== 'm' ||\n      // combine matching moveto and lineto sequences\n      last.command === 'M' && command === 'L' || last.command === 'm' && command === 'l') {\n        last.args = [...last.args, ...args];\n      } else {\n        combined.push({\n          command,\n          args\n        });\n      }\n    }\n  }\n  let result = '';\n  for (const {\n    command,\n    args\n  } of combined) {\n    result += command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);\n  }\n  return result;\n};\nexports.stringifyPathData = stringifyPathData;","map":{"version":3,"names":["argsCountPerCommand","M","m","Z","z","L","l","H","h","V","v","C","c","S","s","Q","q","T","t","A","a","isCommand","isWsp","codePoint","codePointAt","isDigit","readNumber","string","cursor","i","value","state","length","number","Number","parseFloat","isNaN","parsePathData","pathData","command","args","argsCount","canHaveComma","hadComma","charAt","push","newCursor","position","exports","stringifyNumber","precision","ratio","Math","round","toString","replace","stringifyArgs","disableSpaceAfterFlags","result","prev","numberString","startsWith","includes","stringifyPathData","_ref","combined","last"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/lib/path.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('./types').PathDataItem} PathDataItem\n * @typedef {import('./types').PathDataCommand} PathDataCommand\n */\n\n// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF\n\nconst argsCountPerCommand = {\n  M: 2,\n  m: 2,\n  Z: 0,\n  z: 0,\n  L: 2,\n  l: 2,\n  H: 1,\n  h: 1,\n  V: 1,\n  v: 1,\n  C: 6,\n  c: 6,\n  S: 4,\n  s: 4,\n  Q: 4,\n  q: 4,\n  T: 2,\n  t: 2,\n  A: 7,\n  a: 7,\n};\n\n/**\n * @type {(c: string) => c is PathDataCommand}\n */\nconst isCommand = (c) => {\n  return c in argsCountPerCommand;\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isWsp = (c) => {\n  const codePoint = c.codePointAt(0);\n  return (\n    codePoint === 0x20 ||\n    codePoint === 0x9 ||\n    codePoint === 0xd ||\n    codePoint === 0xa\n  );\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isDigit = (c) => {\n  const codePoint = c.codePointAt(0);\n  if (codePoint == null) {\n    return false;\n  }\n  return 48 <= codePoint && codePoint <= 57;\n};\n\n/**\n * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState\n */\n\n/**\n * @type {(string: string, cursor: number) => [number, number | null]}\n */\nconst readNumber = (string, cursor) => {\n  let i = cursor;\n  let value = '';\n  let state = /** @type {ReadNumberState} */ ('none');\n  for (; i < string.length; i += 1) {\n    const c = string[i];\n    if (c === '+' || c === '-') {\n      if (state === 'none') {\n        state = 'sign';\n        value += c;\n        continue;\n      }\n      if (state === 'e') {\n        state = 'exponent_sign';\n        value += c;\n        continue;\n      }\n    }\n    if (isDigit(c)) {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'whole';\n        value += c;\n        continue;\n      }\n      if (state === 'decimal_point' || state === 'decimal') {\n        state = 'decimal';\n        value += c;\n        continue;\n      }\n      if (state === 'e' || state === 'exponent_sign' || state === 'exponent') {\n        state = 'exponent';\n        value += c;\n        continue;\n      }\n    }\n    if (c === '.') {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'decimal_point';\n        value += c;\n        continue;\n      }\n    }\n    if (c === 'E' || c == 'e') {\n      if (\n        state === 'whole' ||\n        state === 'decimal_point' ||\n        state === 'decimal'\n      ) {\n        state = 'e';\n        value += c;\n        continue;\n      }\n    }\n    break;\n  }\n  const number = Number.parseFloat(value);\n  if (Number.isNaN(number)) {\n    return [cursor, null];\n  } else {\n    // step back to delegate iteration to parent loop\n    return [i - 1, number];\n  }\n};\n\n/**\n * @type {(string: string) => Array<PathDataItem>}\n */\nconst parsePathData = (string) => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = [];\n  /**\n   * @type {null | PathDataCommand}\n   */\n  let command = null;\n  let args = /** @type {number[]} */ ([]);\n  let argsCount = 0;\n  let canHaveComma = false;\n  let hadComma = false;\n  for (let i = 0; i < string.length; i += 1) {\n    const c = string.charAt(i);\n    if (isWsp(c)) {\n      continue;\n    }\n    // allow comma only between arguments\n    if (canHaveComma && c === ',') {\n      if (hadComma) {\n        break;\n      }\n      hadComma = true;\n      continue;\n    }\n    if (isCommand(c)) {\n      if (hadComma) {\n        return pathData;\n      }\n      if (command == null) {\n        // moveto should be leading command\n        if (c !== 'M' && c !== 'm') {\n          return pathData;\n        }\n      } else {\n        // stop if previous command arguments are not flushed\n        if (args.length !== 0) {\n          return pathData;\n        }\n      }\n      command = c;\n      args = [];\n      argsCount = argsCountPerCommand[command];\n      canHaveComma = false;\n      // flush command without arguments\n      if (argsCount === 0) {\n        pathData.push({ command, args });\n      }\n      continue;\n    }\n    // avoid parsing arguments if no command detected\n    if (command == null) {\n      return pathData;\n    }\n    // read next argument\n    let newCursor = i;\n    let number = null;\n    if (command === 'A' || command === 'a') {\n      const position = args.length;\n      if (position === 0 || position === 1) {\n        // allow only positive number without sign as first two arguments\n        if (c !== '+' && c !== '-') {\n          [newCursor, number] = readNumber(string, i);\n        }\n      }\n      if (position === 2 || position === 5 || position === 6) {\n        [newCursor, number] = readNumber(string, i);\n      }\n      if (position === 3 || position === 4) {\n        // read flags\n        if (c === '0') {\n          number = 0;\n        }\n        if (c === '1') {\n          number = 1;\n        }\n      }\n    } else {\n      [newCursor, number] = readNumber(string, i);\n    }\n    if (number == null) {\n      return pathData;\n    }\n    args.push(number);\n    canHaveComma = true;\n    hadComma = false;\n    i = newCursor;\n    // flush arguments when necessary count is reached\n    if (args.length === argsCount) {\n      pathData.push({ command, args });\n      // subsequent moveto coordinates are threated as implicit lineto commands\n      if (command === 'M') {\n        command = 'L';\n      }\n      if (command === 'm') {\n        command = 'l';\n      }\n      args = [];\n    }\n  }\n  return pathData;\n};\nexports.parsePathData = parsePathData;\n\n/**\n * @type {(number: number, precision?: number) => string}\n */\nconst stringifyNumber = (number, precision) => {\n  if (precision != null) {\n    const ratio = 10 ** precision;\n    number = Math.round(number * ratio) / ratio;\n  }\n  // remove zero whole from decimal number\n  return number.toString().replace(/^0\\./, '.').replace(/^-0\\./, '-.');\n};\n\n/**\n * Elliptical arc large-arc and sweep flags are rendered with spaces\n * because many non-browser environments are not able to parse such paths\n *\n * @type {(\n *   command: string,\n *   args: number[],\n *   precision?: number,\n *   disableSpaceAfterFlags?: boolean\n * ) => string}\n */\nconst stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {\n  let result = '';\n  let prev = '';\n  for (let i = 0; i < args.length; i += 1) {\n    const number = args[i];\n    const numberString = stringifyNumber(number, precision);\n    if (\n      disableSpaceAfterFlags &&\n      (command === 'A' || command === 'a') &&\n      // consider combined arcs\n      (i % 7 === 4 || i % 7 === 5)\n    ) {\n      result += numberString;\n    } else if (i === 0 || numberString.startsWith('-')) {\n      // avoid space before first and negative numbers\n      result += numberString;\n    } else if (prev.includes('.') && numberString.startsWith('.')) {\n      // remove space before decimal with zero whole\n      // only when previous number is also decimal\n      result += numberString;\n    } else {\n      result += ` ${numberString}`;\n    }\n    prev = numberString;\n  }\n  return result;\n};\n\n/**\n * @typedef {{\n *   pathData: Array<PathDataItem>;\n *   precision?: number;\n *   disableSpaceAfterFlags?: boolean;\n * }} StringifyPathDataOptions\n */\n\n/**\n * @type {(options: StringifyPathDataOptions) => string}\n */\nconst stringifyPathData = ({ pathData, precision, disableSpaceAfterFlags }) => {\n  // combine sequence of the same commands\n  let combined = [];\n  for (let i = 0; i < pathData.length; i += 1) {\n    const { command, args } = pathData[i];\n    if (i === 0) {\n      combined.push({ command, args });\n    } else {\n      /**\n       * @type {PathDataItem}\n       */\n      const last = combined[combined.length - 1];\n      // match leading moveto with following lineto\n      if (i === 1) {\n        if (command === 'L') {\n          last.command = 'M';\n        }\n        if (command === 'l') {\n          last.command = 'm';\n        }\n      }\n      if (\n        (last.command === command &&\n          last.command !== 'M' &&\n          last.command !== 'm') ||\n        // combine matching moveto and lineto sequences\n        (last.command === 'M' && command === 'L') ||\n        (last.command === 'm' && command === 'l')\n      ) {\n        last.args = [...last.args, ...args];\n      } else {\n        combined.push({ command, args });\n      }\n    }\n  }\n  let result = '';\n  for (const { command, args } of combined) {\n    result +=\n      command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);\n  }\n  return result;\n};\nexports.stringifyPathData = stringifyPathData;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}