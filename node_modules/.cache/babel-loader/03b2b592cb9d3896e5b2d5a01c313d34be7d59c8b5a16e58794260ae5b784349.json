{"ast":null,"code":"'use strict';\n\nconst {\n  visitSkip,\n  detachNodeFromParent\n} = require('../lib/xast.js');\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\nconst {\n  elems,\n  attrsGroups,\n  elemsGroups,\n  attrsGroupsDefaults,\n  presentationNonInheritableGroupAttrs\n} = require('./_collections');\nexports.name = 'removeUnknownsAndDefaults';\nexports.description = 'removes unknown elements content and attributes, removes attrs with default values';\n\n// resolve all groups references\n\n/**\n * @type {Map<string, Set<string>>}\n */\nconst allowedChildrenPerElement = new Map();\n/**\n * @type {Map<string, Set<string>>}\n */\nconst allowedAttributesPerElement = new Map();\n/**\n * @type {Map<string, Map<string, string>>}\n */\nconst attributesDefaultsPerElement = new Map();\nfor (const [name, config] of Object.entries(elems)) {\n  /**\n   * @type {Set<string>}\n   */\n  const allowedChildren = new Set();\n  if (config.content) {\n    for (const elementName of config.content) {\n      allowedChildren.add(elementName);\n    }\n  }\n  if (config.contentGroups) {\n    for (const contentGroupName of config.contentGroups) {\n      const elemsGroup = elemsGroups[contentGroupName];\n      if (elemsGroup) {\n        for (const elementName of elemsGroup) {\n          allowedChildren.add(elementName);\n        }\n      }\n    }\n  }\n  /**\n   * @type {Set<string>}\n   */\n  const allowedAttributes = new Set();\n  if (config.attrs) {\n    for (const attrName of config.attrs) {\n      allowedAttributes.add(attrName);\n    }\n  }\n  /**\n   * @type {Map<string, string>}\n   */\n  const attributesDefaults = new Map();\n  if (config.defaults) {\n    for (const [attrName, defaultValue] of Object.entries(config.defaults)) {\n      attributesDefaults.set(attrName, defaultValue);\n    }\n  }\n  for (const attrsGroupName of config.attrsGroups) {\n    const attrsGroup = attrsGroups[attrsGroupName];\n    if (attrsGroup) {\n      for (const attrName of attrsGroup) {\n        allowedAttributes.add(attrName);\n      }\n    }\n    const groupDefaults = attrsGroupsDefaults[attrsGroupName];\n    if (groupDefaults) {\n      for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {\n        attributesDefaults.set(attrName, defaultValue);\n      }\n    }\n  }\n  allowedChildrenPerElement.set(name, allowedChildren);\n  allowedAttributesPerElement.set(name, allowedAttributes);\n  attributesDefaultsPerElement.set(name, attributesDefaults);\n}\n\n/**\n * Remove unknown elements content and attributes,\n * remove attributes with default values.\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'removeUnknownsAndDefaults'>}\n */\nexports.fn = (root, params) => {\n  const {\n    unknownContent = true,\n    unknownAttrs = true,\n    defaultAttrs = true,\n    uselessOverrides = true,\n    keepDataAttrs = true,\n    keepAriaAttrs = true,\n    keepRoleAttr = false\n  } = params;\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip namespaced elements\n        if (node.name.includes(':')) {\n          return;\n        }\n        // skip visiting foreignObject subtree\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n\n        // remove unknown element's content\n        if (unknownContent && parentNode.type === 'element') {\n          const allowedChildren = allowedChildrenPerElement.get(parentNode.name);\n          if (allowedChildren == null || allowedChildren.size === 0) {\n            // remove unknown elements\n            if (allowedChildrenPerElement.get(node.name) == null) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          } else {\n            // remove not allowed children\n            if (allowedChildren.has(node.name) === false) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          }\n        }\n        const allowedAttributes = allowedAttributesPerElement.get(node.name);\n        const attributesDefaults = attributesDefaultsPerElement.get(node.name);\n        const computedParentStyle = parentNode.type === 'element' ? computeStyle(stylesheet, parentNode) : null;\n\n        // remove element's unknown attrs and attrs with default values\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (keepDataAttrs && name.startsWith('data-')) {\n            continue;\n          }\n          if (keepAriaAttrs && name.startsWith('aria-')) {\n            continue;\n          }\n          if (keepRoleAttr && name === 'role') {\n            continue;\n          }\n          // skip xmlns attribute\n          if (name === 'xmlns') {\n            continue;\n          }\n          // skip namespaced attributes except xml:* and xlink:*\n          if (name.includes(':')) {\n            const [prefix] = name.split(':');\n            if (prefix !== 'xml' && prefix !== 'xlink') {\n              continue;\n            }\n          }\n          if (unknownAttrs && allowedAttributes && allowedAttributes.has(name) === false) {\n            delete node.attributes[name];\n          }\n          if (defaultAttrs && node.attributes.id == null && attributesDefaults && attributesDefaults.get(name) === value) {\n            // keep defaults if parent has own or inherited style\n            if (computedParentStyle == null || computedParentStyle[name] == null) {\n              delete node.attributes[name];\n            }\n          }\n          if (uselessOverrides && node.attributes.id == null) {\n            const style = computedParentStyle == null ? null : computedParentStyle[name];\n            if (presentationNonInheritableGroupAttrs.includes(name) === false && style != null && style.type === 'static' && style.value === value) {\n              delete node.attributes[name];\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["visitSkip","detachNodeFromParent","require","collectStylesheet","computeStyle","elems","attrsGroups","elemsGroups","attrsGroupsDefaults","presentationNonInheritableGroupAttrs","exports","name","description","allowedChildrenPerElement","Map","allowedAttributesPerElement","attributesDefaultsPerElement","config","Object","entries","allowedChildren","Set","content","elementName","add","contentGroups","contentGroupName","elemsGroup","allowedAttributes","attrs","attrName","attributesDefaults","defaults","defaultValue","set","attrsGroupName","attrsGroup","groupDefaults","fn","root","params","unknownContent","unknownAttrs","defaultAttrs","uselessOverrides","keepDataAttrs","keepAriaAttrs","keepRoleAttr","stylesheet","element","enter","node","parentNode","includes","type","get","size","has","computedParentStyle","value","attributes","startsWith","prefix","split","id","style"],"sources":["C:/Users/AGU/Documents/trouver2/node_modules/svgo/plugins/removeUnknownsAndDefaults.js"],"sourcesContent":["'use strict';\n\nconst { visitSkip, detachNodeFromParent } = require('../lib/xast.js');\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst {\n  elems,\n  attrsGroups,\n  elemsGroups,\n  attrsGroupsDefaults,\n  presentationNonInheritableGroupAttrs,\n} = require('./_collections');\n\nexports.name = 'removeUnknownsAndDefaults';\nexports.description =\n  'removes unknown elements content and attributes, removes attrs with default values';\n\n// resolve all groups references\n\n/**\n * @type {Map<string, Set<string>>}\n */\nconst allowedChildrenPerElement = new Map();\n/**\n * @type {Map<string, Set<string>>}\n */\nconst allowedAttributesPerElement = new Map();\n/**\n * @type {Map<string, Map<string, string>>}\n */\nconst attributesDefaultsPerElement = new Map();\n\nfor (const [name, config] of Object.entries(elems)) {\n  /**\n   * @type {Set<string>}\n   */\n  const allowedChildren = new Set();\n  if (config.content) {\n    for (const elementName of config.content) {\n      allowedChildren.add(elementName);\n    }\n  }\n  if (config.contentGroups) {\n    for (const contentGroupName of config.contentGroups) {\n      const elemsGroup = elemsGroups[contentGroupName];\n      if (elemsGroup) {\n        for (const elementName of elemsGroup) {\n          allowedChildren.add(elementName);\n        }\n      }\n    }\n  }\n  /**\n   * @type {Set<string>}\n   */\n  const allowedAttributes = new Set();\n  if (config.attrs) {\n    for (const attrName of config.attrs) {\n      allowedAttributes.add(attrName);\n    }\n  }\n  /**\n   * @type {Map<string, string>}\n   */\n  const attributesDefaults = new Map();\n  if (config.defaults) {\n    for (const [attrName, defaultValue] of Object.entries(config.defaults)) {\n      attributesDefaults.set(attrName, defaultValue);\n    }\n  }\n  for (const attrsGroupName of config.attrsGroups) {\n    const attrsGroup = attrsGroups[attrsGroupName];\n    if (attrsGroup) {\n      for (const attrName of attrsGroup) {\n        allowedAttributes.add(attrName);\n      }\n    }\n    const groupDefaults = attrsGroupsDefaults[attrsGroupName];\n    if (groupDefaults) {\n      for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {\n        attributesDefaults.set(attrName, defaultValue);\n      }\n    }\n  }\n  allowedChildrenPerElement.set(name, allowedChildren);\n  allowedAttributesPerElement.set(name, allowedAttributes);\n  attributesDefaultsPerElement.set(name, attributesDefaults);\n}\n\n/**\n * Remove unknown elements content and attributes,\n * remove attributes with default values.\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'removeUnknownsAndDefaults'>}\n */\nexports.fn = (root, params) => {\n  const {\n    unknownContent = true,\n    unknownAttrs = true,\n    defaultAttrs = true,\n    uselessOverrides = true,\n    keepDataAttrs = true,\n    keepAriaAttrs = true,\n    keepRoleAttr = false,\n  } = params;\n  const stylesheet = collectStylesheet(root);\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip namespaced elements\n        if (node.name.includes(':')) {\n          return;\n        }\n        // skip visiting foreignObject subtree\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n\n        // remove unknown element's content\n        if (unknownContent && parentNode.type === 'element') {\n          const allowedChildren = allowedChildrenPerElement.get(\n            parentNode.name\n          );\n          if (allowedChildren == null || allowedChildren.size === 0) {\n            // remove unknown elements\n            if (allowedChildrenPerElement.get(node.name) == null) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          } else {\n            // remove not allowed children\n            if (allowedChildren.has(node.name) === false) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          }\n        }\n\n        const allowedAttributes = allowedAttributesPerElement.get(node.name);\n        const attributesDefaults = attributesDefaultsPerElement.get(node.name);\n        const computedParentStyle =\n          parentNode.type === 'element'\n            ? computeStyle(stylesheet, parentNode)\n            : null;\n\n        // remove element's unknown attrs and attrs with default values\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (keepDataAttrs && name.startsWith('data-')) {\n            continue;\n          }\n          if (keepAriaAttrs && name.startsWith('aria-')) {\n            continue;\n          }\n          if (keepRoleAttr && name === 'role') {\n            continue;\n          }\n          // skip xmlns attribute\n          if (name === 'xmlns') {\n            continue;\n          }\n          // skip namespaced attributes except xml:* and xlink:*\n          if (name.includes(':')) {\n            const [prefix] = name.split(':');\n            if (prefix !== 'xml' && prefix !== 'xlink') {\n              continue;\n            }\n          }\n\n          if (\n            unknownAttrs &&\n            allowedAttributes &&\n            allowedAttributes.has(name) === false\n          ) {\n            delete node.attributes[name];\n          }\n          if (\n            defaultAttrs &&\n            node.attributes.id == null &&\n            attributesDefaults &&\n            attributesDefaults.get(name) === value\n          ) {\n            // keep defaults if parent has own or inherited style\n            if (\n              computedParentStyle == null ||\n              computedParentStyle[name] == null\n            ) {\n              delete node.attributes[name];\n            }\n          }\n          if (uselessOverrides && node.attributes.id == null) {\n            const style =\n              computedParentStyle == null ? null : computedParentStyle[name];\n            if (\n              presentationNonInheritableGroupAttrs.includes(name) === false &&\n              style != null &&\n              style.type === 'static' &&\n              style.value === value\n            ) {\n              delete node.attributes[name];\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}